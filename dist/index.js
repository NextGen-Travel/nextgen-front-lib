var HA = Object.defineProperty;
var WA = (e, t, n) => t in e ? HA(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var V = (e, t, n) => (WA(e, typeof t != "symbol" ? t + "" : t, n), n), UA = (e, t, n) => {
  if (!t.has(e))
    throw TypeError("Cannot " + n);
};
var Hu = (e, t, n) => {
  if (t.has(e))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(e) : t.set(e, n);
};
var Lo = (e, t, n) => (UA(e, t, "access private method"), n);
import { defineComponent as be, computed as T, openBlock as j, createElementBlock as G, normalizeClass as Be, normalizeStyle as et, renderSlot as Ee, reactive as Oe, ref as oe, watch as fe, onMounted as ct, onUnmounted as zt, toRefs as db, h as er, watchEffect as Zc, provide as $i, inject as ur, unref as X, createBlock as ke, resolveDynamicComponent as hb, normalizeProps as Xl, mergeProps as Gt, withKeys as Gp, createVNode as U, withCtx as pe, createCommentVNode as ve, withDirectives as ds, createElementVNode as de, toDisplayString as Fe, nextTick as un, Fragment as Ie, renderList as _t, toRef as ss, resolveComponent as ge, Transition as Fs, createTextVNode as fn, isRef as Cr, withModifiers as U0, guardReactiveProps as YA, resolveDirective as pb, toHandlers as qA, useSlots as GA, useAttrs as XA, getCurrentInstance as $d, warn as ZA, shallowRef as gi, onScopeDispose as KA, effectScope as JA, toRaw as QA, TransitionGroup as gb, camelize as ek, Text as tk, onBeforeUnmount as Kc, onBeforeMount as nk, vShow as vb, vModelText as rk, mergeModels as ik, useModel as sk } from "vue";
import { StyleString as za, JobsQueue as Jc, Debounce as Qc, Resource as ak, ElementListenerGroup as eu, text as Va, Event as Lt, flow as Lr, Exception as mb, element as Ps, Breakpoint as Zl, LocalStorage as yb, pick as Kl, Loader as xb, Hook as bb, Ticker as _b, Cache as wb, I18n as ok, Interaction as lk, record as Ha, array as ck, calc as uk, json as El, detect as fk } from "power-helper";
import { useIntersectionObserver as $b, useResizeObserver as dk } from "@vueuse/core";
const hk = /* @__PURE__ */ be({
  __name: "ani",
  props: {
    mode: {
      type: String,
      required: !0
    },
    delay: {
      type: String,
      required: !1,
      default: () => {
      }
    },
    duration: {
      type: String,
      required: !1,
      default: () => {
      }
    },
    repeat: {
      type: String,
      required: !1,
      default: () => {
      }
    }
  },
  setup(e) {
    const t = e, n = T(() => {
      let i = new za();
      return t.delay && i.set("animationDelay", t.delay), t.duration === "super-faster" && i.set("animationDuration", ".25s"), i.join();
    }), r = T(() => {
      let i = ["animate__animated", `animate__${t.mode}`];
      return t.duration && t.duration !== "super-faster" && i.push(`animate__${t.duration}`), t.repeat && i.push(`animate__repeat-${t.repeat}`), i.join(" ");
    });
    return (i, s) => (j(), G("div", {
      class: Be(r.value),
      style: et(n.value)
    }, [
      Ee(i.$slots, "default")
    ], 6));
  }
});
var Zt = "top", vn = "bottom", mn = "right", Kt = "left", Y0 = "auto", yo = [Zt, vn, mn, Kt], hs = "start", Wa = "end", pk = "clippingParents", Eb = "viewport", Qs = "popper", gk = "reference", Xp = /* @__PURE__ */ yo.reduce(function(e, t) {
  return e.concat([t + "-" + hs, t + "-" + Wa]);
}, []), Ab = /* @__PURE__ */ [].concat(yo, [Y0]).reduce(function(e, t) {
  return e.concat([t, t + "-" + hs, t + "-" + Wa]);
}, []), vk = "beforeRead", mk = "read", yk = "afterRead", xk = "beforeMain", bk = "main", _k = "afterMain", wk = "beforeWrite", $k = "write", Ek = "afterWrite", Ak = [vk, mk, yk, xk, bk, _k, wk, $k, Ek];
function zn(e) {
  return e ? (e.nodeName || "").toLowerCase() : null;
}
function rn(e) {
  if (e == null)
    return window;
  if (e.toString() !== "[object Window]") {
    var t = e.ownerDocument;
    return t && t.defaultView || window;
  }
  return e;
}
function vi(e) {
  var t = rn(e).Element;
  return e instanceof t || e instanceof Element;
}
function hn(e) {
  var t = rn(e).HTMLElement;
  return e instanceof t || e instanceof HTMLElement;
}
function q0(e) {
  if (typeof ShadowRoot > "u")
    return !1;
  var t = rn(e).ShadowRoot;
  return e instanceof t || e instanceof ShadowRoot;
}
function kk(e) {
  var t = e.state;
  Object.keys(t.elements).forEach(function(n) {
    var r = t.styles[n] || {}, i = t.attributes[n] || {}, s = t.elements[n];
    !hn(s) || !zn(s) || (Object.assign(s.style, r), Object.keys(i).forEach(function(a) {
      var o = i[a];
      o === !1 ? s.removeAttribute(a) : s.setAttribute(a, o === !0 ? "" : o);
    }));
  });
}
function Ck(e) {
  var t = e.state, n = {
    popper: {
      position: t.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(t.elements.popper.style, n.popper), t.styles = n, t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow), function() {
    Object.keys(t.elements).forEach(function(r) {
      var i = t.elements[r], s = t.attributes[r] || {}, a = Object.keys(t.styles.hasOwnProperty(r) ? t.styles[r] : n[r]), o = a.reduce(function(l, c) {
        return l[c] = "", l;
      }, {});
      !hn(i) || !zn(i) || (Object.assign(i.style, o), Object.keys(s).forEach(function(l) {
        i.removeAttribute(l);
      }));
    });
  };
}
const Dk = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: kk,
  effect: Ck,
  requires: ["computeStyles"]
};
function jn(e) {
  return e.split("-")[0];
}
var li = Math.max, Jl = Math.min, ps = Math.round;
function Ed() {
  var e = navigator.userAgentData;
  return e != null && e.brands && Array.isArray(e.brands) ? e.brands.map(function(t) {
    return t.brand + "/" + t.version;
  }).join(" ") : navigator.userAgent;
}
function kb() {
  return !/^((?!chrome|android).)*safari/i.test(Ed());
}
function gs(e, t, n) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  var r = e.getBoundingClientRect(), i = 1, s = 1;
  t && hn(e) && (i = e.offsetWidth > 0 && ps(r.width) / e.offsetWidth || 1, s = e.offsetHeight > 0 && ps(r.height) / e.offsetHeight || 1);
  var a = vi(e) ? rn(e) : window, o = a.visualViewport, l = !kb() && n, c = (r.left + (l && o ? o.offsetLeft : 0)) / i, u = (r.top + (l && o ? o.offsetTop : 0)) / s, f = r.width / i, d = r.height / s;
  return {
    width: f,
    height: d,
    top: u,
    right: c + f,
    bottom: u + d,
    left: c,
    x: c,
    y: u
  };
}
function G0(e) {
  var t = gs(e), n = e.offsetWidth, r = e.offsetHeight;
  return Math.abs(t.width - n) <= 1 && (n = t.width), Math.abs(t.height - r) <= 1 && (r = t.height), {
    x: e.offsetLeft,
    y: e.offsetTop,
    width: n,
    height: r
  };
}
function Cb(e, t) {
  var n = t.getRootNode && t.getRootNode();
  if (e.contains(t))
    return !0;
  if (n && q0(n)) {
    var r = t;
    do {
      if (r && e.isSameNode(r))
        return !0;
      r = r.parentNode || r.host;
    } while (r);
  }
  return !1;
}
function ar(e) {
  return rn(e).getComputedStyle(e);
}
function Sk(e) {
  return ["table", "td", "th"].indexOf(zn(e)) >= 0;
}
function jr(e) {
  return ((vi(e) ? e.ownerDocument : (
    // $FlowFixMe[prop-missing]
    e.document
  )) || window.document).documentElement;
}
function tu(e) {
  return zn(e) === "html" ? e : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    e.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    e.parentNode || // DOM Element detected
    (q0(e) ? e.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    jr(e)
  );
}
function Zp(e) {
  return !hn(e) || // https://github.com/popperjs/popper-core/issues/837
  ar(e).position === "fixed" ? null : e.offsetParent;
}
function Tk(e) {
  var t = /firefox/i.test(Ed()), n = /Trident/i.test(Ed());
  if (n && hn(e)) {
    var r = ar(e);
    if (r.position === "fixed")
      return null;
  }
  var i = tu(e);
  for (q0(i) && (i = i.host); hn(i) && ["html", "body"].indexOf(zn(i)) < 0; ) {
    var s = ar(i);
    if (s.transform !== "none" || s.perspective !== "none" || s.contain === "paint" || ["transform", "perspective"].indexOf(s.willChange) !== -1 || t && s.willChange === "filter" || t && s.filter && s.filter !== "none")
      return i;
    i = i.parentNode;
  }
  return null;
}
function xo(e) {
  for (var t = rn(e), n = Zp(e); n && Sk(n) && ar(n).position === "static"; )
    n = Zp(n);
  return n && (zn(n) === "html" || zn(n) === "body" && ar(n).position === "static") ? t : n || Tk(e) || t;
}
function X0(e) {
  return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y";
}
function Aa(e, t, n) {
  return li(e, Jl(t, n));
}
function Ok(e, t, n) {
  var r = Aa(e, t, n);
  return r > n ? n : r;
}
function Db() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function Sb(e) {
  return Object.assign({}, Db(), e);
}
function Tb(e, t) {
  return t.reduce(function(n, r) {
    return n[r] = e, n;
  }, {});
}
var Mk = function(t, n) {
  return t = typeof t == "function" ? t(Object.assign({}, n.rects, {
    placement: n.placement
  })) : t, Sb(typeof t != "number" ? t : Tb(t, yo));
};
function Fk(e) {
  var t, n = e.state, r = e.name, i = e.options, s = n.elements.arrow, a = n.modifiersData.popperOffsets, o = jn(n.placement), l = X0(o), c = [Kt, mn].indexOf(o) >= 0, u = c ? "height" : "width";
  if (!(!s || !a)) {
    var f = Mk(i.padding, n), d = G0(s), h = l === "y" ? Zt : Kt, p = l === "y" ? vn : mn, g = n.rects.reference[u] + n.rects.reference[l] - a[l] - n.rects.popper[u], v = a[l] - n.rects.reference[l], m = xo(s), x = m ? l === "y" ? m.clientHeight || 0 : m.clientWidth || 0 : 0, _ = g / 2 - v / 2, y = f[h], b = x - d[u] - f[p], w = x / 2 - d[u] / 2 + _, E = Aa(y, w, b), $ = l;
    n.modifiersData[r] = (t = {}, t[$] = E, t.centerOffset = E - w, t);
  }
}
function Pk(e) {
  var t = e.state, n = e.options, r = n.element, i = r === void 0 ? "[data-popper-arrow]" : r;
  i != null && (typeof i == "string" && (i = t.elements.popper.querySelector(i), !i) || Cb(t.elements.popper, i) && (t.elements.arrow = i));
}
const Ik = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: Fk,
  effect: Pk,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function vs(e) {
  return e.split("-")[1];
}
var Rk = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function Bk(e, t) {
  var n = e.x, r = e.y, i = t.devicePixelRatio || 1;
  return {
    x: ps(n * i) / i || 0,
    y: ps(r * i) / i || 0
  };
}
function Kp(e) {
  var t, n = e.popper, r = e.popperRect, i = e.placement, s = e.variation, a = e.offsets, o = e.position, l = e.gpuAcceleration, c = e.adaptive, u = e.roundOffsets, f = e.isFixed, d = a.x, h = d === void 0 ? 0 : d, p = a.y, g = p === void 0 ? 0 : p, v = typeof u == "function" ? u({
    x: h,
    y: g
  }) : {
    x: h,
    y: g
  };
  h = v.x, g = v.y;
  var m = a.hasOwnProperty("x"), x = a.hasOwnProperty("y"), _ = Kt, y = Zt, b = window;
  if (c) {
    var w = xo(n), E = "clientHeight", $ = "clientWidth";
    if (w === rn(n) && (w = jr(n), ar(w).position !== "static" && o === "absolute" && (E = "scrollHeight", $ = "scrollWidth")), w = w, i === Zt || (i === Kt || i === mn) && s === Wa) {
      y = vn;
      var C = f && w === b && b.visualViewport ? b.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        w[E]
      );
      g -= C - r.height, g *= l ? 1 : -1;
    }
    if (i === Kt || (i === Zt || i === vn) && s === Wa) {
      _ = mn;
      var A = f && w === b && b.visualViewport ? b.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        w[$]
      );
      h -= A - r.width, h *= l ? 1 : -1;
    }
  }
  var k = Object.assign({
    position: o
  }, c && Rk), D = u === !0 ? Bk({
    x: h,
    y: g
  }, rn(n)) : {
    x: h,
    y: g
  };
  if (h = D.x, g = D.y, l) {
    var S;
    return Object.assign({}, k, (S = {}, S[y] = x ? "0" : "", S[_] = m ? "0" : "", S.transform = (b.devicePixelRatio || 1) <= 1 ? "translate(" + h + "px, " + g + "px)" : "translate3d(" + h + "px, " + g + "px, 0)", S));
  }
  return Object.assign({}, k, (t = {}, t[y] = x ? g + "px" : "", t[_] = m ? h + "px" : "", t.transform = "", t));
}
function Nk(e) {
  var t = e.state, n = e.options, r = n.gpuAcceleration, i = r === void 0 ? !0 : r, s = n.adaptive, a = s === void 0 ? !0 : s, o = n.roundOffsets, l = o === void 0 ? !0 : o, c = {
    placement: jn(t.placement),
    variation: vs(t.placement),
    popper: t.elements.popper,
    popperRect: t.rects.popper,
    gpuAcceleration: i,
    isFixed: t.options.strategy === "fixed"
  };
  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, Kp(Object.assign({}, c, {
    offsets: t.modifiersData.popperOffsets,
    position: t.options.strategy,
    adaptive: a,
    roundOffsets: l
  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, Kp(Object.assign({}, c, {
    offsets: t.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: l
  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-placement": t.placement
  });
}
const Lk = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: Nk,
  data: {}
};
var jo = {
  passive: !0
};
function jk(e) {
  var t = e.state, n = e.instance, r = e.options, i = r.scroll, s = i === void 0 ? !0 : i, a = r.resize, o = a === void 0 ? !0 : a, l = rn(t.elements.popper), c = [].concat(t.scrollParents.reference, t.scrollParents.popper);
  return s && c.forEach(function(u) {
    u.addEventListener("scroll", n.update, jo);
  }), o && l.addEventListener("resize", n.update, jo), function() {
    s && c.forEach(function(u) {
      u.removeEventListener("scroll", n.update, jo);
    }), o && l.removeEventListener("resize", n.update, jo);
  };
}
const zk = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: jk,
  data: {}
};
var Vk = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function Al(e) {
  return e.replace(/left|right|bottom|top/g, function(t) {
    return Vk[t];
  });
}
var Hk = {
  start: "end",
  end: "start"
};
function Jp(e) {
  return e.replace(/start|end/g, function(t) {
    return Hk[t];
  });
}
function Z0(e) {
  var t = rn(e), n = t.pageXOffset, r = t.pageYOffset;
  return {
    scrollLeft: n,
    scrollTop: r
  };
}
function K0(e) {
  return gs(jr(e)).left + Z0(e).scrollLeft;
}
function Wk(e, t) {
  var n = rn(e), r = jr(e), i = n.visualViewport, s = r.clientWidth, a = r.clientHeight, o = 0, l = 0;
  if (i) {
    s = i.width, a = i.height;
    var c = kb();
    (c || !c && t === "fixed") && (o = i.offsetLeft, l = i.offsetTop);
  }
  return {
    width: s,
    height: a,
    x: o + K0(e),
    y: l
  };
}
function Uk(e) {
  var t, n = jr(e), r = Z0(e), i = (t = e.ownerDocument) == null ? void 0 : t.body, s = li(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0), a = li(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0), o = -r.scrollLeft + K0(e), l = -r.scrollTop;
  return ar(i || n).direction === "rtl" && (o += li(n.clientWidth, i ? i.clientWidth : 0) - s), {
    width: s,
    height: a,
    x: o,
    y: l
  };
}
function J0(e) {
  var t = ar(e), n = t.overflow, r = t.overflowX, i = t.overflowY;
  return /auto|scroll|overlay|hidden/.test(n + i + r);
}
function Ob(e) {
  return ["html", "body", "#document"].indexOf(zn(e)) >= 0 ? e.ownerDocument.body : hn(e) && J0(e) ? e : Ob(tu(e));
}
function ka(e, t) {
  var n;
  t === void 0 && (t = []);
  var r = Ob(e), i = r === ((n = e.ownerDocument) == null ? void 0 : n.body), s = rn(r), a = i ? [s].concat(s.visualViewport || [], J0(r) ? r : []) : r, o = t.concat(a);
  return i ? o : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    o.concat(ka(tu(a)))
  );
}
function Ad(e) {
  return Object.assign({}, e, {
    left: e.x,
    top: e.y,
    right: e.x + e.width,
    bottom: e.y + e.height
  });
}
function Yk(e, t) {
  var n = gs(e, !1, t === "fixed");
  return n.top = n.top + e.clientTop, n.left = n.left + e.clientLeft, n.bottom = n.top + e.clientHeight, n.right = n.left + e.clientWidth, n.width = e.clientWidth, n.height = e.clientHeight, n.x = n.left, n.y = n.top, n;
}
function Qp(e, t, n) {
  return t === Eb ? Ad(Wk(e, n)) : vi(t) ? Yk(t, n) : Ad(Uk(jr(e)));
}
function qk(e) {
  var t = ka(tu(e)), n = ["absolute", "fixed"].indexOf(ar(e).position) >= 0, r = n && hn(e) ? xo(e) : e;
  return vi(r) ? t.filter(function(i) {
    return vi(i) && Cb(i, r) && zn(i) !== "body";
  }) : [];
}
function Gk(e, t, n, r) {
  var i = t === "clippingParents" ? qk(e) : [].concat(t), s = [].concat(i, [n]), a = s[0], o = s.reduce(function(l, c) {
    var u = Qp(e, c, r);
    return l.top = li(u.top, l.top), l.right = Jl(u.right, l.right), l.bottom = Jl(u.bottom, l.bottom), l.left = li(u.left, l.left), l;
  }, Qp(e, a, r));
  return o.width = o.right - o.left, o.height = o.bottom - o.top, o.x = o.left, o.y = o.top, o;
}
function Mb(e) {
  var t = e.reference, n = e.element, r = e.placement, i = r ? jn(r) : null, s = r ? vs(r) : null, a = t.x + t.width / 2 - n.width / 2, o = t.y + t.height / 2 - n.height / 2, l;
  switch (i) {
    case Zt:
      l = {
        x: a,
        y: t.y - n.height
      };
      break;
    case vn:
      l = {
        x: a,
        y: t.y + t.height
      };
      break;
    case mn:
      l = {
        x: t.x + t.width,
        y: o
      };
      break;
    case Kt:
      l = {
        x: t.x - n.width,
        y: o
      };
      break;
    default:
      l = {
        x: t.x,
        y: t.y
      };
  }
  var c = i ? X0(i) : null;
  if (c != null) {
    var u = c === "y" ? "height" : "width";
    switch (s) {
      case hs:
        l[c] = l[c] - (t[u] / 2 - n[u] / 2);
        break;
      case Wa:
        l[c] = l[c] + (t[u] / 2 - n[u] / 2);
        break;
    }
  }
  return l;
}
function Ua(e, t) {
  t === void 0 && (t = {});
  var n = t, r = n.placement, i = r === void 0 ? e.placement : r, s = n.strategy, a = s === void 0 ? e.strategy : s, o = n.boundary, l = o === void 0 ? pk : o, c = n.rootBoundary, u = c === void 0 ? Eb : c, f = n.elementContext, d = f === void 0 ? Qs : f, h = n.altBoundary, p = h === void 0 ? !1 : h, g = n.padding, v = g === void 0 ? 0 : g, m = Sb(typeof v != "number" ? v : Tb(v, yo)), x = d === Qs ? gk : Qs, _ = e.rects.popper, y = e.elements[p ? x : d], b = Gk(vi(y) ? y : y.contextElement || jr(e.elements.popper), l, u, a), w = gs(e.elements.reference), E = Mb({
    reference: w,
    element: _,
    strategy: "absolute",
    placement: i
  }), $ = Ad(Object.assign({}, _, E)), C = d === Qs ? $ : w, A = {
    top: b.top - C.top + m.top,
    bottom: C.bottom - b.bottom + m.bottom,
    left: b.left - C.left + m.left,
    right: C.right - b.right + m.right
  }, k = e.modifiersData.offset;
  if (d === Qs && k) {
    var D = k[i];
    Object.keys(A).forEach(function(S) {
      var L = [mn, vn].indexOf(S) >= 0 ? 1 : -1, P = [Zt, vn].indexOf(S) >= 0 ? "y" : "x";
      A[S] += D[P] * L;
    });
  }
  return A;
}
function Xk(e, t) {
  t === void 0 && (t = {});
  var n = t, r = n.placement, i = n.boundary, s = n.rootBoundary, a = n.padding, o = n.flipVariations, l = n.allowedAutoPlacements, c = l === void 0 ? Ab : l, u = vs(r), f = u ? o ? Xp : Xp.filter(function(p) {
    return vs(p) === u;
  }) : yo, d = f.filter(function(p) {
    return c.indexOf(p) >= 0;
  });
  d.length === 0 && (d = f);
  var h = d.reduce(function(p, g) {
    return p[g] = Ua(e, {
      placement: g,
      boundary: i,
      rootBoundary: s,
      padding: a
    })[jn(g)], p;
  }, {});
  return Object.keys(h).sort(function(p, g) {
    return h[p] - h[g];
  });
}
function Zk(e) {
  if (jn(e) === Y0)
    return [];
  var t = Al(e);
  return [Jp(e), t, Jp(t)];
}
function Kk(e) {
  var t = e.state, n = e.options, r = e.name;
  if (!t.modifiersData[r]._skip) {
    for (var i = n.mainAxis, s = i === void 0 ? !0 : i, a = n.altAxis, o = a === void 0 ? !0 : a, l = n.fallbackPlacements, c = n.padding, u = n.boundary, f = n.rootBoundary, d = n.altBoundary, h = n.flipVariations, p = h === void 0 ? !0 : h, g = n.allowedAutoPlacements, v = t.options.placement, m = jn(v), x = m === v, _ = l || (x || !p ? [Al(v)] : Zk(v)), y = [v].concat(_).reduce(function(I, te) {
      return I.concat(jn(te) === Y0 ? Xk(t, {
        placement: te,
        boundary: u,
        rootBoundary: f,
        padding: c,
        flipVariations: p,
        allowedAutoPlacements: g
      }) : te);
    }, []), b = t.rects.reference, w = t.rects.popper, E = /* @__PURE__ */ new Map(), $ = !0, C = y[0], A = 0; A < y.length; A++) {
      var k = y[A], D = jn(k), S = vs(k) === hs, L = [Zt, vn].indexOf(D) >= 0, P = L ? "width" : "height", H = Ua(t, {
        placement: k,
        boundary: u,
        rootBoundary: f,
        altBoundary: d,
        padding: c
      }), M = L ? S ? mn : Kt : S ? vn : Zt;
      b[P] > w[P] && (M = Al(M));
      var B = Al(M), W = [];
      if (s && W.push(H[D] <= 0), o && W.push(H[M] <= 0, H[B] <= 0), W.every(function(I) {
        return I;
      })) {
        C = k, $ = !1;
        break;
      }
      E.set(k, W);
    }
    if ($)
      for (var R = p ? 3 : 1, O = function(te) {
        var ee = y.find(function(_e) {
          var re = E.get(_e);
          if (re)
            return re.slice(0, te).every(function(Ae) {
              return Ae;
            });
        });
        if (ee)
          return C = ee, "break";
      }, N = R; N > 0; N--) {
        var z = O(N);
        if (z === "break")
          break;
      }
    t.placement !== C && (t.modifiersData[r]._skip = !0, t.placement = C, t.reset = !0);
  }
}
const Jk = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: Kk,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function eg(e, t, n) {
  return n === void 0 && (n = {
    x: 0,
    y: 0
  }), {
    top: e.top - t.height - n.y,
    right: e.right - t.width + n.x,
    bottom: e.bottom - t.height + n.y,
    left: e.left - t.width - n.x
  };
}
function tg(e) {
  return [Zt, mn, vn, Kt].some(function(t) {
    return e[t] >= 0;
  });
}
function Qk(e) {
  var t = e.state, n = e.name, r = t.rects.reference, i = t.rects.popper, s = t.modifiersData.preventOverflow, a = Ua(t, {
    elementContext: "reference"
  }), o = Ua(t, {
    altBoundary: !0
  }), l = eg(a, r), c = eg(o, i, s), u = tg(l), f = tg(c);
  t.modifiersData[n] = {
    referenceClippingOffsets: l,
    popperEscapeOffsets: c,
    isReferenceHidden: u,
    hasPopperEscaped: f
  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-reference-hidden": u,
    "data-popper-escaped": f
  });
}
const eC = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: Qk
};
function tC(e, t, n) {
  var r = jn(e), i = [Kt, Zt].indexOf(r) >= 0 ? -1 : 1, s = typeof n == "function" ? n(Object.assign({}, t, {
    placement: e
  })) : n, a = s[0], o = s[1];
  return a = a || 0, o = (o || 0) * i, [Kt, mn].indexOf(r) >= 0 ? {
    x: o,
    y: a
  } : {
    x: a,
    y: o
  };
}
function nC(e) {
  var t = e.state, n = e.options, r = e.name, i = n.offset, s = i === void 0 ? [0, 0] : i, a = Ab.reduce(function(u, f) {
    return u[f] = tC(f, t.rects, s), u;
  }, {}), o = a[t.placement], l = o.x, c = o.y;
  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += c), t.modifiersData[r] = a;
}
const rC = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: nC
};
function iC(e) {
  var t = e.state, n = e.name;
  t.modifiersData[n] = Mb({
    reference: t.rects.reference,
    element: t.rects.popper,
    strategy: "absolute",
    placement: t.placement
  });
}
const sC = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: iC,
  data: {}
};
function aC(e) {
  return e === "x" ? "y" : "x";
}
function oC(e) {
  var t = e.state, n = e.options, r = e.name, i = n.mainAxis, s = i === void 0 ? !0 : i, a = n.altAxis, o = a === void 0 ? !1 : a, l = n.boundary, c = n.rootBoundary, u = n.altBoundary, f = n.padding, d = n.tether, h = d === void 0 ? !0 : d, p = n.tetherOffset, g = p === void 0 ? 0 : p, v = Ua(t, {
    boundary: l,
    rootBoundary: c,
    padding: f,
    altBoundary: u
  }), m = jn(t.placement), x = vs(t.placement), _ = !x, y = X0(m), b = aC(y), w = t.modifiersData.popperOffsets, E = t.rects.reference, $ = t.rects.popper, C = typeof g == "function" ? g(Object.assign({}, t.rects, {
    placement: t.placement
  })) : g, A = typeof C == "number" ? {
    mainAxis: C,
    altAxis: C
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, C), k = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, D = {
    x: 0,
    y: 0
  };
  if (w) {
    if (s) {
      var S, L = y === "y" ? Zt : Kt, P = y === "y" ? vn : mn, H = y === "y" ? "height" : "width", M = w[y], B = M + v[L], W = M - v[P], R = h ? -$[H] / 2 : 0, O = x === hs ? E[H] : $[H], N = x === hs ? -$[H] : -E[H], z = t.elements.arrow, I = h && z ? G0(z) : {
        width: 0,
        height: 0
      }, te = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : Db(), ee = te[L], _e = te[P], re = Aa(0, E[H], I[H]), Ae = _ ? E[H] / 2 - R - re - ee - A.mainAxis : O - re - ee - A.mainAxis, st = _ ? -E[H] / 2 + R + re + _e + A.mainAxis : N + re + _e + A.mainAxis, ut = t.elements.arrow && xo(t.elements.arrow), yt = ut ? y === "y" ? ut.clientTop || 0 : ut.clientLeft || 0 : 0, He = (S = k == null ? void 0 : k[y]) != null ? S : 0, We = M + Ae - He - yt, wt = M + st - He, Ke = Aa(h ? Jl(B, We) : B, M, h ? li(W, wt) : W);
      w[y] = Ke, D[y] = Ke - M;
    }
    if (o) {
      var Ht, Tt = y === "x" ? Zt : Kt, ce = y === "x" ? vn : mn, xt = w[b], xe = b === "y" ? "height" : "width", he = xt + v[Tt], ft = xt - v[ce], dt = [Zt, Kt].indexOf(m) !== -1, Ft = (Ht = k == null ? void 0 : k[b]) != null ? Ht : 0, $t = dt ? he : xt - E[xe] - $[xe] - Ft + A.altAxis, J = dt ? xt + E[xe] + $[xe] - Ft - A.altAxis : ft, ne = h && dt ? Ok($t, xt, J) : Aa(h ? $t : he, xt, h ? J : ft);
      w[b] = ne, D[b] = ne - xt;
    }
    t.modifiersData[r] = D;
  }
}
const lC = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: oC,
  requiresIfExists: ["offset"]
};
function cC(e) {
  return {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  };
}
function uC(e) {
  return e === rn(e) || !hn(e) ? Z0(e) : cC(e);
}
function fC(e) {
  var t = e.getBoundingClientRect(), n = ps(t.width) / e.offsetWidth || 1, r = ps(t.height) / e.offsetHeight || 1;
  return n !== 1 || r !== 1;
}
function dC(e, t, n) {
  n === void 0 && (n = !1);
  var r = hn(t), i = hn(t) && fC(t), s = jr(t), a = gs(e, i, n), o = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = {
    x: 0,
    y: 0
  };
  return (r || !r && !n) && ((zn(t) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  J0(s)) && (o = uC(t)), hn(t) ? (l = gs(t, !0), l.x += t.clientLeft, l.y += t.clientTop) : s && (l.x = K0(s))), {
    x: a.left + o.scrollLeft - l.x,
    y: a.top + o.scrollTop - l.y,
    width: a.width,
    height: a.height
  };
}
function hC(e) {
  var t = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), r = [];
  e.forEach(function(s) {
    t.set(s.name, s);
  });
  function i(s) {
    n.add(s.name);
    var a = [].concat(s.requires || [], s.requiresIfExists || []);
    a.forEach(function(o) {
      if (!n.has(o)) {
        var l = t.get(o);
        l && i(l);
      }
    }), r.push(s);
  }
  return e.forEach(function(s) {
    n.has(s.name) || i(s);
  }), r;
}
function pC(e) {
  var t = hC(e);
  return Ak.reduce(function(n, r) {
    return n.concat(t.filter(function(i) {
      return i.phase === r;
    }));
  }, []);
}
function gC(e) {
  var t;
  return function() {
    return t || (t = new Promise(function(n) {
      Promise.resolve().then(function() {
        t = void 0, n(e());
      });
    })), t;
  };
}
function vC(e) {
  var t = e.reduce(function(n, r) {
    var i = n[r.name];
    return n[r.name] = i ? Object.assign({}, i, r, {
      options: Object.assign({}, i.options, r.options),
      data: Object.assign({}, i.data, r.data)
    }) : r, n;
  }, {});
  return Object.keys(t).map(function(n) {
    return t[n];
  });
}
var ng = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function rg() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return !t.some(function(r) {
    return !(r && typeof r.getBoundingClientRect == "function");
  });
}
function mC(e) {
  e === void 0 && (e = {});
  var t = e, n = t.defaultModifiers, r = n === void 0 ? [] : n, i = t.defaultOptions, s = i === void 0 ? ng : i;
  return function(o, l, c) {
    c === void 0 && (c = s);
    var u = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, ng, s),
      modifiersData: {},
      elements: {
        reference: o,
        popper: l
      },
      attributes: {},
      styles: {}
    }, f = [], d = !1, h = {
      state: u,
      setOptions: function(m) {
        var x = typeof m == "function" ? m(u.options) : m;
        g(), u.options = Object.assign({}, s, u.options, x), u.scrollParents = {
          reference: vi(o) ? ka(o) : o.contextElement ? ka(o.contextElement) : [],
          popper: ka(l)
        };
        var _ = pC(vC([].concat(r, u.options.modifiers)));
        return u.orderedModifiers = _.filter(function(y) {
          return y.enabled;
        }), p(), h.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!d) {
          var m = u.elements, x = m.reference, _ = m.popper;
          if (rg(x, _)) {
            u.rects = {
              reference: dC(x, xo(_), u.options.strategy === "fixed"),
              popper: G0(_)
            }, u.reset = !1, u.placement = u.options.placement, u.orderedModifiers.forEach(function(A) {
              return u.modifiersData[A.name] = Object.assign({}, A.data);
            });
            for (var y = 0; y < u.orderedModifiers.length; y++) {
              if (u.reset === !0) {
                u.reset = !1, y = -1;
                continue;
              }
              var b = u.orderedModifiers[y], w = b.fn, E = b.options, $ = E === void 0 ? {} : E, C = b.name;
              typeof w == "function" && (u = w({
                state: u,
                options: $,
                name: C,
                instance: h
              }) || u);
            }
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: gC(function() {
        return new Promise(function(v) {
          h.forceUpdate(), v(u);
        });
      }),
      destroy: function() {
        g(), d = !0;
      }
    };
    if (!rg(o, l))
      return h;
    h.setOptions(c).then(function(v) {
      !d && c.onFirstUpdate && c.onFirstUpdate(v);
    });
    function p() {
      u.orderedModifiers.forEach(function(v) {
        var m = v.name, x = v.options, _ = x === void 0 ? {} : x, y = v.effect;
        if (typeof y == "function") {
          var b = y({
            state: u,
            name: m,
            instance: h,
            options: _
          }), w = function() {
          };
          f.push(b || w);
        }
      });
    }
    function g() {
      f.forEach(function(v) {
        return v();
      }), f = [];
    }
    return h;
  };
}
var yC = [zk, sC, Lk, Dk, rC, Jk, lC, Ik, eC], xC = /* @__PURE__ */ mC({
  defaultModifiers: yC
}), bC = Object.defineProperty, _C = (e, t, n) => t in e ? bC(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, se = (e, t, n) => (_C(e, typeof t != "symbol" ? t + "" : t, n), n);
const fr = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [r, i] of t)
    n[r] = i;
  return n;
}, wC = {}, $C = {
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  viewBox: "0 0 24 24"
}, EC = /* @__PURE__ */ de("polyline", { points: "9 18 15 12 9 6" }, null, -1), AC = [
  EC
];
function kC(e, t) {
  return j(), G("svg", $C, AC);
}
const CC = /* @__PURE__ */ fr(wC, [["render", kC]]), DC = {}, SC = {
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  viewBox: "0 0 24 24"
}, TC = /* @__PURE__ */ de("polyline", { points: "15 18 9 12 15 6" }, null, -1), OC = [
  TC
];
function MC(e, t) {
  return j(), G("svg", SC, OC);
}
const FC = /* @__PURE__ */ fr(DC, [["render", MC]]), PC = {}, IC = {
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  viewBox: "0 0 24 24"
}, RC = /* @__PURE__ */ de("polyline", { points: "6 9 12 15 18 9" }, null, -1), BC = [
  RC
];
function NC(e, t) {
  return j(), G("svg", IC, BC);
}
const LC = /* @__PURE__ */ fr(PC, [["render", NC]]), jC = {}, zC = {
  fill: "none",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  "stroke-width": "2",
  viewBox: "0 0 24 24"
}, VC = /* @__PURE__ */ de("path", { d: "M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" }, null, -1), HC = [
  VC
];
function WC(e, t) {
  return j(), G("svg", zC, HC);
}
const UC = /* @__PURE__ */ fr(jC, [["render", WC]]), YC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  IconChevronDown: LC,
  IconChevronLeft: FC,
  IconChevronRight: CC,
  IconClock: UC
}, Symbol.toStringTag, { value: "Module" })), ms = /* @__PURE__ */ be({
  __name: "BaseIcon",
  props: {
    name: { type: String, required: !0 },
    width: { type: String },
    height: { type: String },
    size: { type: String, default: "26" },
    viewBox: { type: String }
  },
  setup(e) {
    const t = e, n = T(() => t.width || t.size), r = T(() => t.height || t.size), i = T(() => YC[`Icon${t.name}`]);
    return (s, a) => (j(), ke(hb(X(i)), {
      width: X(n),
      height: X(r),
      class: "vc-base-icon"
    }, null, 8, ["width", "height"]));
  }
});
function Fb() {
  return typeof window < "u";
}
function qC(e) {
  return Fb() && e in window;
}
function GC(e) {
  const t = oe(!1), n = T(() => t.value ? "dark" : "light");
  let r, i;
  function s(h) {
    t.value = h.matches;
  }
  function a() {
    qC("matchMedia") && (r = window.matchMedia("(prefers-color-scheme: dark)"), r.addEventListener("change", s), t.value = r.matches);
  }
  function o() {
    const { selector: h = ":root", darkClass: p = "dark" } = e.value, g = document.querySelector(h);
    t.value = g.classList.contains(p);
  }
  function l(h) {
    const { selector: p = ":root", darkClass: g = "dark" } = h;
    if (Fb() && p && g) {
      const v = document.querySelector(p);
      v && (i = new MutationObserver(o), i.observe(v, {
        attributes: !0,
        attributeFilter: ["class"]
      }), t.value = v.classList.contains(g));
    }
  }
  function c() {
    f();
    const h = typeof e.value;
    h === "string" && e.value.toLowerCase() === "system" ? a() : h === "object" ? l(e.value) : t.value = !!e.value;
  }
  const u = fe(() => e.value, () => c(), {
    immediate: !0
  });
  function f() {
    r && (r.removeEventListener("change", s), r = void 0), i && (i.disconnect(), i = void 0);
  }
  function d() {
    f(), u();
  }
  return zt(() => d()), {
    isDark: t,
    displayMode: n,
    cleanup: d
  };
}
var zo = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function XC(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var ZC = typeof zo == "object" && zo && zo.Object === Object && zo, Pb = ZC, KC = Pb, JC = typeof self == "object" && self && self.Object === Object && self, QC = KC || JC || Function("return this")(), Vn = QC, eD = Vn, tD = eD.Symbol, nu = tD, ig = nu, Ib = Object.prototype, nD = Ib.hasOwnProperty, rD = Ib.toString, ea = ig ? ig.toStringTag : void 0;
function iD(e) {
  var t = nD.call(e, ea), n = e[ea];
  try {
    e[ea] = void 0;
    var r = !0;
  } catch {
  }
  var i = rD.call(e);
  return r && (t ? e[ea] = n : delete e[ea]), i;
}
var sD = iD, aD = Object.prototype, oD = aD.toString;
function lD(e) {
  return oD.call(e);
}
var cD = lD, sg = nu, uD = sD, fD = cD, dD = "[object Null]", hD = "[object Undefined]", ag = sg ? sg.toStringTag : void 0;
function pD(e) {
  return e == null ? e === void 0 ? hD : dD : ag && ag in Object(e) ? uD(e) : fD(e);
}
var Hn = pD;
function gD(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var dr = gD, vD = Hn, mD = dr, yD = "[object AsyncFunction]", xD = "[object Function]", bD = "[object GeneratorFunction]", _D = "[object Proxy]";
function wD(e) {
  if (!mD(e))
    return !1;
  var t = vD(e);
  return t == xD || t == bD || t == yD || t == _D;
}
var Ei = wD, $D = Array.isArray, Cn = $D;
function ED(e) {
  return e != null && typeof e == "object";
}
var Dn = ED, AD = Hn, kD = Cn, CD = Dn, DD = "[object String]";
function SD(e) {
  return typeof e == "string" || !kD(e) && CD(e) && AD(e) == DD;
}
var Pn = SD, TD = Hn, OD = Dn, MD = "[object Boolean]";
function FD(e) {
  return e === !0 || e === !1 || OD(e) && TD(e) == MD;
}
var PD = FD, ID = Hn, RD = Dn, BD = "[object Number]";
function ND(e) {
  return typeof e == "number" || RD(e) && ID(e) == BD;
}
var kn = ND, LD = Hn, jD = Dn, zD = "[object Date]";
function VD(e) {
  return jD(e) && LD(e) == zD;
}
var HD = VD;
function WD(e) {
  return function(t) {
    return e(t);
  };
}
var Rb = WD, Ya = {}, UD = {
  get exports() {
    return Ya;
  },
  set exports(e) {
    Ya = e;
  }
};
(function(e, t) {
  var n = Pb, r = t && !t.nodeType && t, i = r && !0 && e && !e.nodeType && e, s = i && i.exports === r, a = s && n.process, o = function() {
    try {
      var l = i && i.require && i.require("util").types;
      return l || a && a.binding && a.binding("util");
    } catch {
    }
  }();
  e.exports = o;
})(UD, Ya);
var YD = HD, qD = Rb, og = Ya, lg = og && og.isDate, GD = lg ? qD(lg) : YD, XD = GD, ZD = Hn, KD = Dn, JD = "[object Symbol]";
function QD(e) {
  return typeof e == "symbol" || KD(e) && ZD(e) == JD;
}
var Q0 = QD, eS = Cn, tS = Q0, nS = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, rS = /^\w*$/;
function iS(e, t) {
  if (eS(e))
    return !1;
  var n = typeof e;
  return n == "number" || n == "symbol" || n == "boolean" || e == null || tS(e) ? !0 : rS.test(e) || !nS.test(e) || t != null && e in Object(t);
}
var eh = iS, sS = Vn, aS = sS["__core-js_shared__"], oS = aS, Wu = oS, cg = function() {
  var e = /[^.]+$/.exec(Wu && Wu.keys && Wu.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
}();
function lS(e) {
  return !!cg && cg in e;
}
var cS = lS, uS = Function.prototype, fS = uS.toString;
function dS(e) {
  if (e != null) {
    try {
      return fS.call(e);
    } catch {
    }
    try {
      return e + "";
    } catch {
    }
  }
  return "";
}
var Bb = dS, hS = Ei, pS = cS, gS = dr, vS = Bb, mS = /[\\^$.*+?()[\]{}|]/g, yS = /^\[object .+?Constructor\]$/, xS = Function.prototype, bS = Object.prototype, _S = xS.toString, wS = bS.hasOwnProperty, $S = RegExp(
  "^" + _S.call(wS).replace(mS, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function ES(e) {
  if (!gS(e) || pS(e))
    return !1;
  var t = hS(e) ? $S : yS;
  return t.test(vS(e));
}
var AS = ES;
function kS(e, t) {
  return e == null ? void 0 : e[t];
}
var CS = kS, DS = AS, SS = CS;
function TS(e, t) {
  var n = SS(e, t);
  return DS(n) ? n : void 0;
}
var Ai = TS, OS = Ai, MS = OS(Object, "create"), ru = MS, ug = ru;
function FS() {
  this.__data__ = ug ? ug(null) : {}, this.size = 0;
}
var PS = FS;
function IS(e) {
  var t = this.has(e) && delete this.__data__[e];
  return this.size -= t ? 1 : 0, t;
}
var RS = IS, BS = ru, NS = "__lodash_hash_undefined__", LS = Object.prototype, jS = LS.hasOwnProperty;
function zS(e) {
  var t = this.__data__;
  if (BS) {
    var n = t[e];
    return n === NS ? void 0 : n;
  }
  return jS.call(t, e) ? t[e] : void 0;
}
var VS = zS, HS = ru, WS = Object.prototype, US = WS.hasOwnProperty;
function YS(e) {
  var t = this.__data__;
  return HS ? t[e] !== void 0 : US.call(t, e);
}
var qS = YS, GS = ru, XS = "__lodash_hash_undefined__";
function ZS(e, t) {
  var n = this.__data__;
  return this.size += this.has(e) ? 0 : 1, n[e] = GS && t === void 0 ? XS : t, this;
}
var KS = ZS, JS = PS, QS = RS, eT = VS, tT = qS, nT = KS;
function Is(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
Is.prototype.clear = JS;
Is.prototype.delete = QS;
Is.prototype.get = eT;
Is.prototype.has = tT;
Is.prototype.set = nT;
var rT = Is;
function iT() {
  this.__data__ = [], this.size = 0;
}
var sT = iT;
function aT(e, t) {
  return e === t || e !== e && t !== t;
}
var Rs = aT, oT = Rs;
function lT(e, t) {
  for (var n = e.length; n--; )
    if (oT(e[n][0], t))
      return n;
  return -1;
}
var iu = lT, cT = iu, uT = Array.prototype, fT = uT.splice;
function dT(e) {
  var t = this.__data__, n = cT(t, e);
  if (n < 0)
    return !1;
  var r = t.length - 1;
  return n == r ? t.pop() : fT.call(t, n, 1), --this.size, !0;
}
var hT = dT, pT = iu;
function gT(e) {
  var t = this.__data__, n = pT(t, e);
  return n < 0 ? void 0 : t[n][1];
}
var vT = gT, mT = iu;
function yT(e) {
  return mT(this.__data__, e) > -1;
}
var xT = yT, bT = iu;
function _T(e, t) {
  var n = this.__data__, r = bT(n, e);
  return r < 0 ? (++this.size, n.push([e, t])) : n[r][1] = t, this;
}
var wT = _T, $T = sT, ET = hT, AT = vT, kT = xT, CT = wT;
function Bs(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
Bs.prototype.clear = $T;
Bs.prototype.delete = ET;
Bs.prototype.get = AT;
Bs.prototype.has = kT;
Bs.prototype.set = CT;
var su = Bs, DT = Ai, ST = Vn, TT = DT(ST, "Map"), th = TT, fg = rT, OT = su, MT = th;
function FT() {
  this.size = 0, this.__data__ = {
    hash: new fg(),
    map: new (MT || OT)(),
    string: new fg()
  };
}
var PT = FT;
function IT(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
var RT = IT, BT = RT;
function NT(e, t) {
  var n = e.__data__;
  return BT(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map;
}
var au = NT, LT = au;
function jT(e) {
  var t = LT(this, e).delete(e);
  return this.size -= t ? 1 : 0, t;
}
var zT = jT, VT = au;
function HT(e) {
  return VT(this, e).get(e);
}
var WT = HT, UT = au;
function YT(e) {
  return UT(this, e).has(e);
}
var qT = YT, GT = au;
function XT(e, t) {
  var n = GT(this, e), r = n.size;
  return n.set(e, t), this.size += n.size == r ? 0 : 1, this;
}
var ZT = XT, KT = PT, JT = zT, QT = WT, eO = qT, tO = ZT;
function Ns(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
Ns.prototype.clear = KT;
Ns.prototype.delete = JT;
Ns.prototype.get = QT;
Ns.prototype.has = eO;
Ns.prototype.set = tO;
var nh = Ns, Nb = nh, nO = "Expected a function";
function rh(e, t) {
  if (typeof e != "function" || t != null && typeof t != "function")
    throw new TypeError(nO);
  var n = function() {
    var r = arguments, i = t ? t.apply(this, r) : r[0], s = n.cache;
    if (s.has(i))
      return s.get(i);
    var a = e.apply(this, r);
    return n.cache = s.set(i, a) || s, a;
  };
  return n.cache = new (rh.Cache || Nb)(), n;
}
rh.Cache = Nb;
var rO = rh, iO = rO, sO = 500;
function aO(e) {
  var t = iO(e, function(r) {
    return n.size === sO && n.clear(), r;
  }), n = t.cache;
  return t;
}
var oO = aO, lO = oO, cO = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, uO = /\\(\\)?/g, fO = lO(function(e) {
  var t = [];
  return e.charCodeAt(0) === 46 && t.push(""), e.replace(cO, function(n, r, i, s) {
    t.push(i ? s.replace(uO, "$1") : r || n);
  }), t;
}), dO = fO;
function hO(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length, i = Array(r); ++n < r; )
    i[n] = t(e[n], n, e);
  return i;
}
var pO = hO, dg = nu, gO = pO, vO = Cn, mO = Q0, yO = 1 / 0, hg = dg ? dg.prototype : void 0, pg = hg ? hg.toString : void 0;
function Lb(e) {
  if (typeof e == "string")
    return e;
  if (vO(e))
    return gO(e, Lb) + "";
  if (mO(e))
    return pg ? pg.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -yO ? "-0" : t;
}
var xO = Lb, bO = xO;
function _O(e) {
  return e == null ? "" : bO(e);
}
var wO = _O, $O = Cn, EO = eh, AO = dO, kO = wO;
function CO(e, t) {
  return $O(e) ? e : EO(e, t) ? [e] : AO(kO(e));
}
var jb = CO, DO = Q0, SO = 1 / 0;
function TO(e) {
  if (typeof e == "string" || DO(e))
    return e;
  var t = e + "";
  return t == "0" && 1 / e == -SO ? "-0" : t;
}
var ou = TO, OO = jb, MO = ou;
function FO(e, t) {
  t = OO(t, e);
  for (var n = 0, r = t.length; e != null && n < r; )
    e = e[MO(t[n++])];
  return n && n == r ? e : void 0;
}
var zb = FO, PO = zb;
function IO(e, t, n) {
  var r = e == null ? void 0 : PO(e, t);
  return r === void 0 ? n : r;
}
var ai = IO, RO = Ai, BO = function() {
  try {
    var e = RO(Object, "defineProperty");
    return e({}, "", {}), e;
  } catch {
  }
}(), Vb = BO, gg = Vb;
function NO(e, t, n) {
  t == "__proto__" && gg ? gg(e, t, {
    configurable: !0,
    enumerable: !0,
    value: n,
    writable: !0
  }) : e[t] = n;
}
var lu = NO, LO = lu, jO = Rs, zO = Object.prototype, VO = zO.hasOwnProperty;
function HO(e, t, n) {
  var r = e[t];
  (!(VO.call(e, t) && jO(r, n)) || n === void 0 && !(t in e)) && LO(e, t, n);
}
var WO = HO, UO = 9007199254740991, YO = /^(?:0|[1-9]\d*)$/;
function qO(e, t) {
  var n = typeof e;
  return t = t ?? UO, !!t && (n == "number" || n != "symbol" && YO.test(e)) && e > -1 && e % 1 == 0 && e < t;
}
var ih = qO;
function GO(e) {
  return function(t, n, r) {
    for (var i = -1, s = Object(t), a = r(t), o = a.length; o--; ) {
      var l = a[e ? o : ++i];
      if (n(s[l], l, s) === !1)
        break;
    }
    return t;
  };
}
var XO = GO, ZO = XO, KO = ZO(), Hb = KO;
function JO(e, t) {
  for (var n = -1, r = Array(e); ++n < e; )
    r[n] = t(n);
  return r;
}
var QO = JO, eM = Hn, tM = Dn, nM = "[object Arguments]";
function rM(e) {
  return tM(e) && eM(e) == nM;
}
var iM = rM, vg = iM, sM = Dn, Wb = Object.prototype, aM = Wb.hasOwnProperty, oM = Wb.propertyIsEnumerable, lM = vg(/* @__PURE__ */ function() {
  return arguments;
}()) ? vg : function(e) {
  return sM(e) && aM.call(e, "callee") && !oM.call(e, "callee");
}, sh = lM, ys = {}, cM = {
  get exports() {
    return ys;
  },
  set exports(e) {
    ys = e;
  }
};
function uM() {
  return !1;
}
var fM = uM;
(function(e, t) {
  var n = Vn, r = fM, i = t && !t.nodeType && t, s = i && !0 && e && !e.nodeType && e, a = s && s.exports === i, o = a ? n.Buffer : void 0, l = o ? o.isBuffer : void 0, c = l || r;
  e.exports = c;
})(cM, ys);
var dM = 9007199254740991;
function hM(e) {
  return typeof e == "number" && e > -1 && e % 1 == 0 && e <= dM;
}
var ah = hM, pM = Hn, gM = ah, vM = Dn, mM = "[object Arguments]", yM = "[object Array]", xM = "[object Boolean]", bM = "[object Date]", _M = "[object Error]", wM = "[object Function]", $M = "[object Map]", EM = "[object Number]", AM = "[object Object]", kM = "[object RegExp]", CM = "[object Set]", DM = "[object String]", SM = "[object WeakMap]", TM = "[object ArrayBuffer]", OM = "[object DataView]", MM = "[object Float32Array]", FM = "[object Float64Array]", PM = "[object Int8Array]", IM = "[object Int16Array]", RM = "[object Int32Array]", BM = "[object Uint8Array]", NM = "[object Uint8ClampedArray]", LM = "[object Uint16Array]", jM = "[object Uint32Array]", qe = {};
qe[MM] = qe[FM] = qe[PM] = qe[IM] = qe[RM] = qe[BM] = qe[NM] = qe[LM] = qe[jM] = !0;
qe[mM] = qe[yM] = qe[TM] = qe[xM] = qe[OM] = qe[bM] = qe[_M] = qe[wM] = qe[$M] = qe[EM] = qe[AM] = qe[kM] = qe[CM] = qe[DM] = qe[SM] = !1;
function zM(e) {
  return vM(e) && gM(e.length) && !!qe[pM(e)];
}
var VM = zM, HM = VM, WM = Rb, mg = Ya, yg = mg && mg.isTypedArray, UM = yg ? WM(yg) : HM, oh = UM, YM = QO, qM = sh, GM = Cn, XM = ys, ZM = ih, KM = oh, JM = Object.prototype, QM = JM.hasOwnProperty;
function eF(e, t) {
  var n = GM(e), r = !n && qM(e), i = !n && !r && XM(e), s = !n && !r && !i && KM(e), a = n || r || i || s, o = a ? YM(e.length, String) : [], l = o.length;
  for (var c in e)
    (t || QM.call(e, c)) && !(a && // Safari 9 has enumerable `arguments.length` in strict mode.
    (c == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    i && (c == "offset" || c == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    s && (c == "buffer" || c == "byteLength" || c == "byteOffset") || // Skip index properties.
    ZM(c, l))) && o.push(c);
  return o;
}
var Ub = eF, tF = Object.prototype;
function nF(e) {
  var t = e && e.constructor, n = typeof t == "function" && t.prototype || tF;
  return e === n;
}
var lh = nF;
function rF(e, t) {
  return function(n) {
    return e(t(n));
  };
}
var Yb = rF, iF = Yb, sF = iF(Object.keys, Object), aF = sF, oF = lh, lF = aF, cF = Object.prototype, uF = cF.hasOwnProperty;
function fF(e) {
  if (!oF(e))
    return lF(e);
  var t = [];
  for (var n in Object(e))
    uF.call(e, n) && n != "constructor" && t.push(n);
  return t;
}
var dF = fF, hF = Ei, pF = ah;
function gF(e) {
  return e != null && pF(e.length) && !hF(e);
}
var bo = gF, vF = Ub, mF = dF, yF = bo;
function xF(e) {
  return yF(e) ? vF(e) : mF(e);
}
var ch = xF, bF = Hb, _F = ch;
function wF(e, t) {
  return e && bF(e, t, _F);
}
var qb = wF, $F = su;
function EF() {
  this.__data__ = new $F(), this.size = 0;
}
var AF = EF;
function kF(e) {
  var t = this.__data__, n = t.delete(e);
  return this.size = t.size, n;
}
var CF = kF;
function DF(e) {
  return this.__data__.get(e);
}
var SF = DF;
function TF(e) {
  return this.__data__.has(e);
}
var OF = TF, MF = su, FF = th, PF = nh, IF = 200;
function RF(e, t) {
  var n = this.__data__;
  if (n instanceof MF) {
    var r = n.__data__;
    if (!FF || r.length < IF - 1)
      return r.push([e, t]), this.size = ++n.size, this;
    n = this.__data__ = new PF(r);
  }
  return n.set(e, t), this.size = n.size, this;
}
var BF = RF, NF = su, LF = AF, jF = CF, zF = SF, VF = OF, HF = BF;
function Ls(e) {
  var t = this.__data__ = new NF(e);
  this.size = t.size;
}
Ls.prototype.clear = LF;
Ls.prototype.delete = jF;
Ls.prototype.get = zF;
Ls.prototype.has = VF;
Ls.prototype.set = HF;
var uh = Ls, WF = "__lodash_hash_undefined__";
function UF(e) {
  return this.__data__.set(e, WF), this;
}
var YF = UF;
function qF(e) {
  return this.__data__.has(e);
}
var GF = qF, XF = nh, ZF = YF, KF = GF;
function Ql(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.__data__ = new XF(); ++t < n; )
    this.add(e[t]);
}
Ql.prototype.add = Ql.prototype.push = ZF;
Ql.prototype.has = KF;
var JF = Ql;
function QF(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length; ++n < r; )
    if (t(e[n], n, e))
      return !0;
  return !1;
}
var Gb = QF;
function e4(e, t) {
  return e.has(t);
}
var t4 = e4, n4 = JF, r4 = Gb, i4 = t4, s4 = 1, a4 = 2;
function o4(e, t, n, r, i, s) {
  var a = n & s4, o = e.length, l = t.length;
  if (o != l && !(a && l > o))
    return !1;
  var c = s.get(e), u = s.get(t);
  if (c && u)
    return c == t && u == e;
  var f = -1, d = !0, h = n & a4 ? new n4() : void 0;
  for (s.set(e, t), s.set(t, e); ++f < o; ) {
    var p = e[f], g = t[f];
    if (r)
      var v = a ? r(g, p, f, t, e, s) : r(p, g, f, e, t, s);
    if (v !== void 0) {
      if (v)
        continue;
      d = !1;
      break;
    }
    if (h) {
      if (!r4(t, function(m, x) {
        if (!i4(h, x) && (p === m || i(p, m, n, r, s)))
          return h.push(x);
      })) {
        d = !1;
        break;
      }
    } else if (!(p === g || i(p, g, n, r, s))) {
      d = !1;
      break;
    }
  }
  return s.delete(e), s.delete(t), d;
}
var Xb = o4, l4 = Vn, c4 = l4.Uint8Array, Zb = c4;
function u4(e) {
  var t = -1, n = Array(e.size);
  return e.forEach(function(r, i) {
    n[++t] = [i, r];
  }), n;
}
var f4 = u4;
function d4(e) {
  var t = -1, n = Array(e.size);
  return e.forEach(function(r) {
    n[++t] = r;
  }), n;
}
var h4 = d4, xg = nu, bg = Zb, p4 = Rs, g4 = Xb, v4 = f4, m4 = h4, y4 = 1, x4 = 2, b4 = "[object Boolean]", _4 = "[object Date]", w4 = "[object Error]", $4 = "[object Map]", E4 = "[object Number]", A4 = "[object RegExp]", k4 = "[object Set]", C4 = "[object String]", D4 = "[object Symbol]", S4 = "[object ArrayBuffer]", T4 = "[object DataView]", _g = xg ? xg.prototype : void 0, Uu = _g ? _g.valueOf : void 0;
function O4(e, t, n, r, i, s, a) {
  switch (n) {
    case T4:
      if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
        return !1;
      e = e.buffer, t = t.buffer;
    case S4:
      return !(e.byteLength != t.byteLength || !s(new bg(e), new bg(t)));
    case b4:
    case _4:
    case E4:
      return p4(+e, +t);
    case w4:
      return e.name == t.name && e.message == t.message;
    case A4:
    case C4:
      return e == t + "";
    case $4:
      var o = v4;
    case k4:
      var l = r & y4;
      if (o || (o = m4), e.size != t.size && !l)
        return !1;
      var c = a.get(e);
      if (c)
        return c == t;
      r |= x4, a.set(e, t);
      var u = g4(o(e), o(t), r, i, s, a);
      return a.delete(e), u;
    case D4:
      if (Uu)
        return Uu.call(e) == Uu.call(t);
  }
  return !1;
}
var M4 = O4;
function F4(e, t) {
  for (var n = -1, r = t.length, i = e.length; ++n < r; )
    e[i + n] = t[n];
  return e;
}
var P4 = F4, I4 = P4, R4 = Cn;
function B4(e, t, n) {
  var r = t(e);
  return R4(e) ? r : I4(r, n(e));
}
var N4 = B4;
function L4(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length, i = 0, s = []; ++n < r; ) {
    var a = e[n];
    t(a, n, e) && (s[i++] = a);
  }
  return s;
}
var j4 = L4;
function z4() {
  return [];
}
var V4 = z4, H4 = j4, W4 = V4, U4 = Object.prototype, Y4 = U4.propertyIsEnumerable, wg = Object.getOwnPropertySymbols, q4 = wg ? function(e) {
  return e == null ? [] : (e = Object(e), H4(wg(e), function(t) {
    return Y4.call(e, t);
  }));
} : W4, G4 = q4, X4 = N4, Z4 = G4, K4 = ch;
function J4(e) {
  return X4(e, K4, Z4);
}
var Q4 = J4, $g = Q4, e3 = 1, t3 = Object.prototype, n3 = t3.hasOwnProperty;
function r3(e, t, n, r, i, s) {
  var a = n & e3, o = $g(e), l = o.length, c = $g(t), u = c.length;
  if (l != u && !a)
    return !1;
  for (var f = l; f--; ) {
    var d = o[f];
    if (!(a ? d in t : n3.call(t, d)))
      return !1;
  }
  var h = s.get(e), p = s.get(t);
  if (h && p)
    return h == t && p == e;
  var g = !0;
  s.set(e, t), s.set(t, e);
  for (var v = a; ++f < l; ) {
    d = o[f];
    var m = e[d], x = t[d];
    if (r)
      var _ = a ? r(x, m, d, t, e, s) : r(m, x, d, e, t, s);
    if (!(_ === void 0 ? m === x || i(m, x, n, r, s) : _)) {
      g = !1;
      break;
    }
    v || (v = d == "constructor");
  }
  if (g && !v) {
    var y = e.constructor, b = t.constructor;
    y != b && "constructor" in e && "constructor" in t && !(typeof y == "function" && y instanceof y && typeof b == "function" && b instanceof b) && (g = !1);
  }
  return s.delete(e), s.delete(t), g;
}
var i3 = r3, s3 = Ai, a3 = Vn, o3 = s3(a3, "DataView"), l3 = o3, c3 = Ai, u3 = Vn, f3 = c3(u3, "Promise"), d3 = f3, h3 = Ai, p3 = Vn, g3 = h3(p3, "Set"), v3 = g3, m3 = Ai, y3 = Vn, x3 = m3(y3, "WeakMap"), b3 = x3, kd = l3, Cd = th, Dd = d3, Sd = v3, Td = b3, Kb = Hn, js = Bb, Eg = "[object Map]", _3 = "[object Object]", Ag = "[object Promise]", kg = "[object Set]", Cg = "[object WeakMap]", Dg = "[object DataView]", w3 = js(kd), $3 = js(Cd), E3 = js(Dd), A3 = js(Sd), k3 = js(Td), Qr = Kb;
(kd && Qr(new kd(new ArrayBuffer(1))) != Dg || Cd && Qr(new Cd()) != Eg || Dd && Qr(Dd.resolve()) != Ag || Sd && Qr(new Sd()) != kg || Td && Qr(new Td()) != Cg) && (Qr = function(e) {
  var t = Kb(e), n = t == _3 ? e.constructor : void 0, r = n ? js(n) : "";
  if (r)
    switch (r) {
      case w3:
        return Dg;
      case $3:
        return Eg;
      case E3:
        return Ag;
      case A3:
        return kg;
      case k3:
        return Cg;
    }
  return t;
});
var C3 = Qr, Yu = uh, D3 = Xb, S3 = M4, T3 = i3, Sg = C3, Tg = Cn, Og = ys, O3 = oh, M3 = 1, Mg = "[object Arguments]", Fg = "[object Array]", Vo = "[object Object]", F3 = Object.prototype, Pg = F3.hasOwnProperty;
function P3(e, t, n, r, i, s) {
  var a = Tg(e), o = Tg(t), l = a ? Fg : Sg(e), c = o ? Fg : Sg(t);
  l = l == Mg ? Vo : l, c = c == Mg ? Vo : c;
  var u = l == Vo, f = c == Vo, d = l == c;
  if (d && Og(e)) {
    if (!Og(t))
      return !1;
    a = !0, u = !1;
  }
  if (d && !u)
    return s || (s = new Yu()), a || O3(e) ? D3(e, t, n, r, i, s) : S3(e, t, l, n, r, i, s);
  if (!(n & M3)) {
    var h = u && Pg.call(e, "__wrapped__"), p = f && Pg.call(t, "__wrapped__");
    if (h || p) {
      var g = h ? e.value() : e, v = p ? t.value() : t;
      return s || (s = new Yu()), i(g, v, n, r, s);
    }
  }
  return d ? (s || (s = new Yu()), T3(e, t, n, r, i, s)) : !1;
}
var I3 = P3, R3 = I3, Ig = Dn;
function Jb(e, t, n, r, i) {
  return e === t ? !0 : e == null || t == null || !Ig(e) && !Ig(t) ? e !== e && t !== t : R3(e, t, n, r, Jb, i);
}
var Qb = Jb, B3 = uh, N3 = Qb, L3 = 1, j3 = 2;
function z3(e, t, n, r) {
  var i = n.length, s = i, a = !r;
  if (e == null)
    return !s;
  for (e = Object(e); i--; ) {
    var o = n[i];
    if (a && o[2] ? o[1] !== e[o[0]] : !(o[0] in e))
      return !1;
  }
  for (; ++i < s; ) {
    o = n[i];
    var l = o[0], c = e[l], u = o[1];
    if (a && o[2]) {
      if (c === void 0 && !(l in e))
        return !1;
    } else {
      var f = new B3();
      if (r)
        var d = r(c, u, l, e, t, f);
      if (!(d === void 0 ? N3(u, c, L3 | j3, r, f) : d))
        return !1;
    }
  }
  return !0;
}
var V3 = z3, H3 = dr;
function W3(e) {
  return e === e && !H3(e);
}
var e_ = W3, U3 = e_, Y3 = ch;
function q3(e) {
  for (var t = Y3(e), n = t.length; n--; ) {
    var r = t[n], i = e[r];
    t[n] = [r, i, U3(i)];
  }
  return t;
}
var G3 = q3;
function X3(e, t) {
  return function(n) {
    return n == null ? !1 : n[e] === t && (t !== void 0 || e in Object(n));
  };
}
var t_ = X3, Z3 = V3, K3 = G3, J3 = t_;
function Q3(e) {
  var t = K3(e);
  return t.length == 1 && t[0][2] ? J3(t[0][0], t[0][1]) : function(n) {
    return n === e || Z3(n, e, t);
  };
}
var e8 = Q3;
function t8(e, t) {
  return e != null && t in Object(e);
}
var n8 = t8, r8 = jb, i8 = sh, s8 = Cn, a8 = ih, o8 = ah, l8 = ou;
function c8(e, t, n) {
  t = r8(t, e);
  for (var r = -1, i = t.length, s = !1; ++r < i; ) {
    var a = l8(t[r]);
    if (!(s = e != null && n(e, a)))
      break;
    e = e[a];
  }
  return s || ++r != i ? s : (i = e == null ? 0 : e.length, !!i && o8(i) && a8(a, i) && (s8(e) || i8(e)));
}
var n_ = c8, u8 = n8, f8 = n_;
function d8(e, t) {
  return e != null && f8(e, t, u8);
}
var h8 = d8, p8 = Qb, g8 = ai, v8 = h8, m8 = eh, y8 = e_, x8 = t_, b8 = ou, _8 = 1, w8 = 2;
function $8(e, t) {
  return m8(e) && y8(t) ? x8(b8(e), t) : function(n) {
    var r = g8(n, e);
    return r === void 0 && r === t ? v8(n, e) : p8(t, r, _8 | w8);
  };
}
var E8 = $8;
function A8(e) {
  return e;
}
var fh = A8;
function k8(e) {
  return function(t) {
    return t == null ? void 0 : t[e];
  };
}
var C8 = k8, D8 = zb;
function S8(e) {
  return function(t) {
    return D8(t, e);
  };
}
var T8 = S8, O8 = C8, M8 = T8, F8 = eh, P8 = ou;
function I8(e) {
  return F8(e) ? O8(P8(e)) : M8(e);
}
var R8 = I8, B8 = e8, N8 = E8, L8 = fh, j8 = Cn, z8 = R8;
function V8(e) {
  return typeof e == "function" ? e : e == null ? L8 : typeof e == "object" ? j8(e) ? N8(e[0], e[1]) : B8(e) : z8(e);
}
var r_ = V8, H8 = lu, W8 = qb, U8 = r_;
function Y8(e, t) {
  var n = {};
  return t = U8(t), W8(e, function(r, i, s) {
    H8(n, i, t(r, i, s));
  }), n;
}
var q8 = Y8;
function G8(e, t, n) {
  switch (n.length) {
    case 0:
      return e.call(t);
    case 1:
      return e.call(t, n[0]);
    case 2:
      return e.call(t, n[0], n[1]);
    case 3:
      return e.call(t, n[0], n[1], n[2]);
  }
  return e.apply(t, n);
}
var i_ = G8, X8 = i_, Rg = Math.max;
function Z8(e, t, n) {
  return t = Rg(t === void 0 ? e.length - 1 : t, 0), function() {
    for (var r = arguments, i = -1, s = Rg(r.length - t, 0), a = Array(s); ++i < s; )
      a[i] = r[t + i];
    i = -1;
    for (var o = Array(t + 1); ++i < t; )
      o[i] = r[i];
    return o[t] = n(a), X8(e, this, o);
  };
}
var K8 = Z8;
function J8(e) {
  return function() {
    return e;
  };
}
var Q8 = J8, eP = Q8, Bg = Vb, tP = fh, nP = Bg ? function(e, t) {
  return Bg(e, "toString", {
    configurable: !0,
    enumerable: !1,
    value: eP(t),
    writable: !0
  });
} : tP, rP = nP, iP = 800, sP = 16, aP = Date.now;
function oP(e) {
  var t = 0, n = 0;
  return function() {
    var r = aP(), i = sP - (r - n);
    if (n = r, i > 0) {
      if (++t >= iP)
        return arguments[0];
    } else
      t = 0;
    return e.apply(void 0, arguments);
  };
}
var lP = oP, cP = rP, uP = lP, fP = uP(cP), dP = fP, hP = fh, pP = K8, gP = dP;
function vP(e, t) {
  return gP(pP(e, t, hP), e + "");
}
var dh = vP, mP = Rs, yP = bo, xP = ih, bP = dr;
function _P(e, t, n) {
  if (!bP(n))
    return !1;
  var r = typeof t;
  return (r == "number" ? yP(n) && xP(t, n.length) : r == "string" && t in n) ? mP(n[t], e) : !1;
}
var hh = _P;
function wP(e) {
  var t = [];
  if (e != null)
    for (var n in Object(e))
      t.push(n);
  return t;
}
var $P = wP, EP = dr, AP = lh, kP = $P, CP = Object.prototype, DP = CP.hasOwnProperty;
function SP(e) {
  if (!EP(e))
    return kP(e);
  var t = AP(e), n = [];
  for (var r in e)
    r == "constructor" && (t || !DP.call(e, r)) || n.push(r);
  return n;
}
var TP = SP, OP = Ub, MP = TP, FP = bo;
function PP(e) {
  return FP(e) ? OP(e, !0) : MP(e);
}
var ph = PP, IP = dh, RP = Rs, BP = hh, NP = ph, s_ = Object.prototype, LP = s_.hasOwnProperty, jP = IP(function(e, t) {
  e = Object(e);
  var n = -1, r = t.length, i = r > 2 ? t[2] : void 0;
  for (i && BP(t[0], t[1], i) && (r = 1); ++n < r; )
    for (var s = t[n], a = NP(s), o = -1, l = a.length; ++o < l; ) {
      var c = a[o], u = e[c];
      (u === void 0 || RP(u, s_[c]) && !LP.call(e, c)) && (e[c] = s[c]);
    }
  return e;
}), Ng = jP, zP = lu, VP = Rs;
function HP(e, t, n) {
  (n !== void 0 && !VP(e[t], n) || n === void 0 && !(t in e)) && zP(e, t, n);
}
var a_ = HP, ec = {}, WP = {
  get exports() {
    return ec;
  },
  set exports(e) {
    ec = e;
  }
};
(function(e, t) {
  var n = Vn, r = t && !t.nodeType && t, i = r && !0 && e && !e.nodeType && e, s = i && i.exports === r, a = s ? n.Buffer : void 0, o = a ? a.allocUnsafe : void 0;
  function l(c, u) {
    if (u)
      return c.slice();
    var f = c.length, d = o ? o(f) : new c.constructor(f);
    return c.copy(d), d;
  }
  e.exports = l;
})(WP, ec);
var Lg = Zb;
function UP(e) {
  var t = new e.constructor(e.byteLength);
  return new Lg(t).set(new Lg(e)), t;
}
var YP = UP, qP = YP;
function GP(e, t) {
  var n = t ? qP(e.buffer) : e.buffer;
  return new e.constructor(n, e.byteOffset, e.length);
}
var XP = GP;
function ZP(e, t) {
  var n = -1, r = e.length;
  for (t || (t = Array(r)); ++n < r; )
    t[n] = e[n];
  return t;
}
var KP = ZP, JP = dr, jg = Object.create, QP = /* @__PURE__ */ function() {
  function e() {
  }
  return function(t) {
    if (!JP(t))
      return {};
    if (jg)
      return jg(t);
    e.prototype = t;
    var n = new e();
    return e.prototype = void 0, n;
  };
}(), eI = QP, tI = Yb, nI = tI(Object.getPrototypeOf, Object), o_ = nI, rI = eI, iI = o_, sI = lh;
function aI(e) {
  return typeof e.constructor == "function" && !sI(e) ? rI(iI(e)) : {};
}
var oI = aI, lI = bo, cI = Dn;
function uI(e) {
  return cI(e) && lI(e);
}
var fI = uI, dI = Hn, hI = o_, pI = Dn, gI = "[object Object]", vI = Function.prototype, mI = Object.prototype, l_ = vI.toString, yI = mI.hasOwnProperty, xI = l_.call(Object);
function bI(e) {
  if (!pI(e) || dI(e) != gI)
    return !1;
  var t = hI(e);
  if (t === null)
    return !0;
  var n = yI.call(t, "constructor") && t.constructor;
  return typeof n == "function" && n instanceof n && l_.call(n) == xI;
}
var _I = bI;
function wI(e, t) {
  if (!(t === "constructor" && typeof e[t] == "function") && t != "__proto__")
    return e[t];
}
var c_ = wI, $I = WO, EI = lu;
function AI(e, t, n, r) {
  var i = !n;
  n || (n = {});
  for (var s = -1, a = t.length; ++s < a; ) {
    var o = t[s], l = r ? r(n[o], e[o], o, n, e) : void 0;
    l === void 0 && (l = e[o]), i ? EI(n, o, l) : $I(n, o, l);
  }
  return n;
}
var kI = AI, CI = kI, DI = ph;
function SI(e) {
  return CI(e, DI(e));
}
var TI = SI, zg = a_, OI = ec, MI = XP, FI = KP, PI = oI, Vg = sh, Hg = Cn, II = fI, RI = ys, BI = Ei, NI = dr, LI = _I, jI = oh, Wg = c_, zI = TI;
function VI(e, t, n, r, i, s, a) {
  var o = Wg(e, n), l = Wg(t, n), c = a.get(l);
  if (c) {
    zg(e, n, c);
    return;
  }
  var u = s ? s(o, l, n + "", e, t, a) : void 0, f = u === void 0;
  if (f) {
    var d = Hg(l), h = !d && RI(l), p = !d && !h && jI(l);
    u = l, d || h || p ? Hg(o) ? u = o : II(o) ? u = FI(o) : h ? (f = !1, u = OI(l, !0)) : p ? (f = !1, u = MI(l, !0)) : u = [] : LI(l) || Vg(l) ? (u = o, Vg(o) ? u = zI(o) : (!NI(o) || BI(o)) && (u = PI(l))) : f = !1;
  }
  f && (a.set(l, u), i(u, l, r, s, a), a.delete(l)), zg(e, n, u);
}
var HI = VI, WI = uh, UI = a_, YI = Hb, qI = HI, GI = dr, XI = ph, ZI = c_;
function u_(e, t, n, r, i) {
  e !== t && YI(t, function(s, a) {
    if (i || (i = new WI()), GI(s))
      qI(e, t, a, n, u_, r, i);
    else {
      var o = r ? r(ZI(e, a), s, a + "", e, t, i) : void 0;
      o === void 0 && (o = s), UI(e, a, o);
    }
  }, XI);
}
var f_ = u_, KI = f_, Ug = dr;
function d_(e, t, n, r, i, s) {
  return Ug(e) && Ug(t) && (s.set(t, e), KI(e, t, void 0, d_, s), s.delete(t)), e;
}
var JI = d_, QI = dh, eR = hh;
function tR(e) {
  return QI(function(t, n) {
    var r = -1, i = n.length, s = i > 1 ? n[i - 1] : void 0, a = i > 2 ? n[2] : void 0;
    for (s = e.length > 3 && typeof s == "function" ? (i--, s) : void 0, a && eR(n[0], n[1], a) && (s = i < 3 ? void 0 : s, i = 1), t = Object(t); ++r < i; ) {
      var o = n[r];
      o && e(t, o, r, s);
    }
    return t;
  });
}
var nR = tR, rR = f_, iR = nR, sR = iR(function(e, t, n, r) {
  rR(e, t, n, r);
}), aR = sR, oR = i_, lR = dh, cR = JI, uR = aR, fR = lR(function(e) {
  return e.push(void 0, cR), oR(uR, void 0, e);
}), qa = fR, dR = Object.prototype, hR = dR.hasOwnProperty;
function pR(e, t) {
  return e != null && hR.call(e, t);
}
var gR = pR, vR = gR, mR = n_;
function yR(e, t) {
  return e != null && mR(e, t, vR);
}
var h_ = yR, xR = bo;
function bR(e, t) {
  return function(n, r) {
    if (n == null)
      return n;
    if (!xR(n))
      return e(n, r);
    for (var i = n.length, s = t ? i : -1, a = Object(n); (t ? s-- : ++s < i) && r(a[s], s, a) !== !1; )
      ;
    return n;
  };
}
var _R = bR, wR = qb, $R = _R, ER = $R(wR), AR = ER;
function kR(e) {
  return e && e.length ? e[0] : void 0;
}
var p_ = kR;
function CR(e) {
  var t = e == null ? 0 : e.length;
  return t ? e[t - 1] : void 0;
}
var ts = CR, DR = AR;
function SR(e, t) {
  var n;
  return DR(e, function(r, i, s) {
    return n = t(r, i, s), !n;
  }), !!n;
}
var TR = SR, OR = Gb, MR = r_, FR = TR, PR = Cn, IR = hh;
function RR(e, t, n) {
  var r = PR(e) ? OR : FR;
  return n && IR(e, t, n) && (t = void 0), r(e, MR(t));
}
var BR = RR;
const NR = (e) => Object.prototype.toString.call(e).slice(8, -1), as = (e) => XD(e) && !isNaN(e.getTime()), or = (e) => NR(e) === "Object", gh = h_, Yg = (e, t) => BR(t, (n) => h_(e, n)), Le = (e, t, n = "0") => {
  for (e = e != null ? String(e) : "", t = t || 2; e.length < t; )
    e = `${n}${e}`;
  return e;
}, pn = (e) => Array.isArray(e), tr = (e) => pn(e) && e.length > 0, tc = (e) => e == null ? e ?? null : document && Pn(e) ? document.querySelector(e) : e.$el ?? e, Dr = (e, t, n, r = void 0) => {
  e.removeEventListener(t, n, r);
}, Sr = (e, t, n, r = void 0) => (e.addEventListener(t, n, r), () => Dr(e, t, n, r)), kl = (e, t) => !!e && !!t && (e === t || e.contains(t)), Ho = (e, t) => {
  (e.key === " " || e.key === "Enter") && (t(e), e.preventDefault());
}, g_ = (e, ...t) => {
  const n = {};
  let r;
  for (r in e)
    t.includes(r) || (n[r] = e[r]);
  return n;
}, v_ = (e, t) => {
  const n = {};
  return t.forEach((r) => {
    r in e && (n[r] = e[r]);
  }), n;
};
function LR(e, t, n) {
  return Math.min(Math.max(e, t), n);
}
const nc = () => {
  function e() {
    return ((1 + Math.random()) * 65536 | 0).toString(16).substring(1);
  }
  return `${e() + e()}-${e()}-${e()}-${e()}-${e()}${e()}${e()}`;
}, jR = ["base", "start", "end", "startEnd"], zR = [
  "class",
  "wrapperClass",
  "contentClass",
  "style",
  "contentStyle",
  "color",
  "fillMode"
], VR = { base: {}, start: {}, end: {} };
function vh(e, t, n = VR) {
  let r = e, i = {};
  t === !0 || Pn(t) ? (r = Pn(t) ? t : r, i = { ...n }) : or(t) && (Yg(t, jR) ? i = { ...t } : i = {
    base: { ...t },
    start: { ...t },
    end: { ...t }
  });
  const s = qa(
    i,
    { start: i.startEnd, end: i.startEnd },
    n
  );
  return Object.entries(s).forEach(([a, o]) => {
    let l = r;
    o === !0 || Pn(o) ? (l = Pn(o) ? o : l, s[a] = { color: l }) : or(o) && (Yg(o, zR) ? s[a] = { ...o } : s[a] = {}), qa(s[a], { color: l });
  }), s;
}
class HR {
  constructor() {
    se(this, "type", "highlight");
  }
  normalizeConfig(t, n) {
    return vh(t, n, {
      base: { fillMode: "light" },
      start: { fillMode: "solid" },
      end: { fillMode: "solid" }
    });
  }
  prepareRender(t) {
    t.highlights = [], t.content || (t.content = []);
  }
  render({ data: t, onStart: n, onEnd: r }, i) {
    const { key: s, highlight: a } = t;
    if (!a)
      return;
    const { highlights: o } = i, { base: l, start: c, end: u } = a;
    n && r ? o.push({
      ...c,
      key: s,
      wrapperClass: `vc-day-layer vc-day-box-center-center vc-attr vc-${c.color}`,
      class: [`vc-highlight vc-highlight-bg-${c.fillMode}`, c.class],
      contentClass: [
        `vc-attr vc-highlight-content-${c.fillMode} vc-${c.color}`,
        c.contentClass
      ]
    }) : n ? (o.push({
      ...l,
      key: `${s}-base`,
      wrapperClass: `vc-day-layer vc-day-box-right-center vc-attr vc-${l.color}`,
      class: [
        `vc-highlight vc-highlight-base-start vc-highlight-bg-${l.fillMode}`,
        l.class
      ]
    }), o.push({
      ...c,
      key: s,
      wrapperClass: `vc-day-layer vc-day-box-center-center vc-attr vc-${c.color}`,
      class: [`vc-highlight vc-highlight-bg-${c.fillMode}`, c.class],
      contentClass: [
        `vc-attr vc-highlight-content-${c.fillMode} vc-${c.color}`,
        c.contentClass
      ]
    })) : r ? (o.push({
      ...l,
      key: `${s}-base`,
      wrapperClass: `vc-day-layer vc-day-box-left-center vc-attr vc-${l.color}`,
      class: [
        `vc-highlight vc-highlight-base-end vc-highlight-bg-${l.fillMode}`,
        l.class
      ]
    }), o.push({
      ...u,
      key: s,
      wrapperClass: `vc-day-layer vc-day-box-center-center vc-attr vc-${u.color}`,
      class: [`vc-highlight vc-highlight-bg-${u.fillMode}`, u.class],
      contentClass: [
        `vc-attr vc-highlight-content-${u.fillMode} vc-${u.color}`,
        u.contentClass
      ]
    })) : o.push({
      ...l,
      key: `${s}-middle`,
      wrapperClass: `vc-day-layer vc-day-box-center-center vc-attr vc-${l.color}`,
      class: [
        `vc-highlight vc-highlight-base-middle vc-highlight-bg-${l.fillMode}`,
        l.class
      ],
      contentClass: [
        `vc-attr vc-highlight-content-${l.fillMode} vc-${l.color}`,
        l.contentClass
      ]
    });
  }
}
class mh {
  constructor(t, n) {
    se(this, "type", ""), se(this, "collectionType", ""), this.type = t, this.collectionType = n;
  }
  normalizeConfig(t, n) {
    return vh(t, n);
  }
  prepareRender(t) {
    t[this.collectionType] = [];
  }
  render({ data: t, onStart: n, onEnd: r }, i) {
    const { key: s } = t, a = t[this.type];
    if (!s || !a)
      return;
    const o = i[this.collectionType], { base: l, start: c, end: u } = a;
    n ? o.push({
      ...c,
      key: s,
      class: [
        `vc-${this.type} vc-${this.type}-start vc-${c.color} vc-attr`,
        c.class
      ]
    }) : r ? o.push({
      ...u,
      key: s,
      class: [
        `vc-${this.type} vc-${this.type}-end vc-${u.color} vc-attr`,
        u.class
      ]
    }) : o.push({
      ...l,
      key: s,
      class: [
        `vc-${this.type} vc-${this.type}-base vc-${l.color} vc-attr`,
        l.class
      ]
    });
  }
}
class WR extends mh {
  constructor() {
    super("content", "content");
  }
  normalizeConfig(t, n) {
    return vh("base", n);
  }
}
class UR extends mh {
  constructor() {
    super("dot", "dots");
  }
}
class YR extends mh {
  constructor() {
    super("bar", "bars");
  }
}
class qR {
  constructor(t) {
    se(this, "color"), se(this, "renderers", [
      new WR(),
      new HR(),
      new UR(),
      new YR()
    ]), this.color = t;
  }
  normalizeGlyphs(t) {
    this.renderers.forEach((n) => {
      const r = n.type;
      t[r] != null && (t[r] = n.normalizeConfig(this.color, t[r]));
    });
  }
  prepareRender(t = {}) {
    return this.renderers.forEach((n) => {
      n.prepareRender(t);
    }), t;
  }
  render(t, n) {
    this.renderers.forEach((r) => {
      r.render(t, n);
    });
  }
}
const GR = 300, XR = 60, ZR = 80, KR = {
  maxSwipeTime: GR,
  minHorizontalSwipeDistance: XR,
  maxVerticalSwipeDistance: ZR
}, JR = "MMMM YYYY", QR = "W", eB = "MMM", tB = "h A", nB = [
  "L",
  "YYYY-MM-DD",
  "YYYY/MM/DD"
], rB = [
  "L h:mm A",
  "YYYY-MM-DD h:mm A",
  "YYYY/MM/DD h:mm A"
], iB = [
  "L HH:mm",
  "YYYY-MM-DD HH:mm",
  "YYYY/MM/DD HH:mm"
], sB = [
  "h:mm A"
], aB = [
  "HH:mm"
], oB = "WWW, MMM D, YYYY", lB = [
  "L",
  "YYYY-MM-DD",
  "YYYY/MM/DD"
], cB = "iso", uB = "YYYY-MM-DDTHH:mm:ss.SSSZ", fB = {
  title: JR,
  weekdays: QR,
  navMonths: eB,
  hours: tB,
  input: nB,
  inputDateTime: rB,
  inputDateTime24hr: iB,
  inputTime: sB,
  inputTime24hr: aB,
  dayPopover: oB,
  data: lB,
  model: cB,
  iso: uB
}, lr = {
  // Arabic
  ar: { dow: 7, L: "D/‏M/‏YYYY" },
  // Bulgarian
  bg: { dow: 2, L: "D.MM.YYYY" },
  // Catalan
  ca: { dow: 2, L: "DD/MM/YYYY" },
  // Chinese (China)
  "zh-CN": { dow: 2, L: "YYYY/MM/DD" },
  // Chinese (Taiwan)
  "zh-TW": { dow: 1, L: "YYYY/MM/DD" },
  // Croatian
  hr: { dow: 2, L: "DD.MM.YYYY" },
  // Czech
  cs: { dow: 2, L: "DD.MM.YYYY" },
  // Danish
  da: { dow: 2, L: "DD.MM.YYYY" },
  // Dutch
  nl: { dow: 2, L: "DD-MM-YYYY" },
  // English (US)
  "en-US": { dow: 1, L: "MM/DD/YYYY" },
  // English (Australia)
  "en-AU": { dow: 2, L: "DD/MM/YYYY" },
  // English (Canada)
  "en-CA": { dow: 1, L: "YYYY-MM-DD" },
  // English (Great Britain)
  "en-GB": { dow: 2, L: "DD/MM/YYYY" },
  // English (Ireland)
  "en-IE": { dow: 2, L: "DD-MM-YYYY" },
  // English (New Zealand)
  "en-NZ": { dow: 2, L: "DD/MM/YYYY" },
  // English (South Africa)
  "en-ZA": { dow: 1, L: "YYYY/MM/DD" },
  // Esperanto
  eo: { dow: 2, L: "YYYY-MM-DD" },
  // Estonian
  et: { dow: 2, L: "DD.MM.YYYY" },
  // Finnish
  fi: { dow: 2, L: "DD.MM.YYYY" },
  // French
  fr: { dow: 2, L: "DD/MM/YYYY" },
  // French (Canada)
  "fr-CA": { dow: 1, L: "YYYY-MM-DD" },
  // French (Switzerland)
  "fr-CH": { dow: 2, L: "DD.MM.YYYY" },
  // German
  de: { dow: 2, L: "DD.MM.YYYY" },
  // Hebrew
  he: { dow: 1, L: "DD.MM.YYYY" },
  // Indonesian
  id: { dow: 2, L: "DD/MM/YYYY" },
  // Italian
  it: { dow: 2, L: "DD/MM/YYYY" },
  // Japanese
  ja: { dow: 1, L: "YYYY年M月D日" },
  // Korean
  ko: { dow: 1, L: "YYYY.MM.DD" },
  // Latvian
  lv: { dow: 2, L: "DD.MM.YYYY" },
  // Lithuanian
  lt: { dow: 2, L: "DD.MM.YYYY" },
  // Macedonian
  mk: { dow: 2, L: "D.MM.YYYY" },
  // Norwegian
  nb: { dow: 2, L: "D. MMMM YYYY" },
  nn: { dow: 2, L: "D. MMMM YYYY" },
  // Polish
  pl: { dow: 2, L: "DD.MM.YYYY" },
  // Portuguese
  pt: { dow: 2, L: "DD/MM/YYYY" },
  // Romanian
  ro: { dow: 2, L: "DD.MM.YYYY" },
  // Russian
  ru: { dow: 2, L: "DD.MM.YYYY" },
  // Slovak
  sk: { dow: 2, L: "DD.MM.YYYY" },
  // Spanish (Spain)
  "es-ES": { dow: 2, L: "DD/MM/YYYY" },
  // Spanish (Mexico)
  "es-MX": { dow: 2, L: "DD/MM/YYYY" },
  // Swedish
  sv: { dow: 2, L: "YYYY-MM-DD" },
  // Thai
  th: { dow: 1, L: "DD/MM/YYYY" },
  // Turkish
  tr: { dow: 2, L: "DD.MM.YYYY" },
  // Ukrainian
  uk: { dow: 2, L: "DD.MM.YYYY" },
  // Vietnam
  vi: { dow: 2, L: "DD/MM/YYYY" }
};
lr.en = lr["en-US"];
lr.es = lr["es-ES"];
lr.no = lr.nb;
lr.zh = lr["zh-CN"];
const dB = Object.entries(lr).reduce(
  (e, [t, { dow: n, L: r }]) => (e[t] = {
    id: t,
    firstDayOfWeek: n,
    masks: { L: r }
  }, e),
  {}
), hB = {
  componentPrefix: "V",
  color: "blue",
  isDark: !1,
  navVisibility: "click",
  titlePosition: "center",
  transition: "slide-h",
  touch: KR,
  masks: fB,
  locales: dB,
  datePicker: {
    updateOnInput: !0,
    inputDebounce: 1e3,
    popover: {
      visibility: "hover-focus",
      placement: "bottom-start",
      isInteractive: !0
    }
  }
}, Od = Oe(hB), pB = T(() => q8(Od.locales, (e) => (e.masks = qa(e.masks, Od.masks), e))), Rr = (e) => typeof window < "u" && gh(window.__vcalendar__, e) ? ai(window.__vcalendar__, e) : ai(Od, e);
var rc = {}, gB = {
  get exports() {
    return rc;
  },
  set exports(e) {
    rc = e;
  }
}, ic = {}, vB = {
  get exports() {
    return ic;
  },
  set exports(e) {
    ic = e;
  }
};
(function(e, t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.default = n;
  function n(r) {
    if (r === null || r === !0 || r === !1)
      return NaN;
    var i = Number(r);
    return isNaN(i) ? i : i < 0 ? Math.ceil(i) : Math.floor(i);
  }
  e.exports = t.default;
})(vB, ic);
var sc = {}, mB = {
  get exports() {
    return sc;
  },
  set exports(e) {
    sc = e;
  }
};
(function(e, t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.default = n;
  function n(r) {
    var i = new Date(Date.UTC(r.getFullYear(), r.getMonth(), r.getDate(), r.getHours(), r.getMinutes(), r.getSeconds(), r.getMilliseconds()));
    return i.setUTCFullYear(r.getFullYear()), r.getTime() - i.getTime();
  }
  e.exports = t.default;
})(mB, sc);
var ac = {}, yB = {
  get exports() {
    return ac;
  },
  set exports(e) {
    ac = e;
  }
}, oc = {}, xB = {
  get exports() {
    return oc;
  },
  set exports(e) {
    oc = e;
  }
};
(function(e, t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.default = n;
  function n(l, c) {
    var u = o(c);
    return u.formatToParts ? i(u, l) : s(u, l);
  }
  var r = {
    year: 0,
    month: 1,
    day: 2,
    hour: 3,
    minute: 4,
    second: 5
  };
  function i(l, c) {
    try {
      for (var u = l.formatToParts(c), f = [], d = 0; d < u.length; d++) {
        var h = r[u[d].type];
        h >= 0 && (f[h] = parseInt(u[d].value, 10));
      }
      return f;
    } catch (p) {
      if (p instanceof RangeError)
        return [NaN];
      throw p;
    }
  }
  function s(l, c) {
    var u = l.format(c).replace(/\u200E/g, ""), f = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(u);
    return [f[3], f[1], f[2], f[4], f[5], f[6]];
  }
  var a = {};
  function o(l) {
    if (!a[l]) {
      var c = new Intl.DateTimeFormat("en-US", {
        hour12: !1,
        timeZone: "America/New_York",
        year: "numeric",
        month: "numeric",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit"
      }).format(/* @__PURE__ */ new Date("2014-06-25T04:00:00.123Z")), u = c === "06/25/2014, 00:00:00" || c === "‎06‎/‎25‎/‎2014‎ ‎00‎:‎00‎:‎00";
      a[l] = u ? new Intl.DateTimeFormat("en-US", {
        hour12: !1,
        timeZone: l,
        year: "numeric",
        month: "numeric",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit"
      }) : new Intl.DateTimeFormat("en-US", {
        hourCycle: "h23",
        timeZone: l,
        year: "numeric",
        month: "numeric",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit"
      });
    }
    return a[l];
  }
  e.exports = t.default;
})(xB, oc);
var lc = {}, bB = {
  get exports() {
    return lc;
  },
  set exports(e) {
    lc = e;
  }
};
(function(e, t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.default = n;
  function n(r, i, s, a, o, l, c) {
    var u = /* @__PURE__ */ new Date(0);
    return u.setUTCFullYear(r, i, s), u.setUTCHours(a, o, l, c), u;
  }
  e.exports = t.default;
})(bB, lc);
(function(e, t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.default = l;
  var n = i(oc), r = i(lc);
  function i(g) {
    return g && g.__esModule ? g : { default: g };
  }
  var s = 36e5, a = 6e4, o = {
    timezone: /([Z+-].*)$/,
    timezoneZ: /^(Z)$/,
    timezoneHH: /^([+-]\d{2})$/,
    timezoneHHMM: /^([+-]\d{2}):?(\d{2})$/
  };
  function l(g, v, m) {
    var x, _;
    if (!g || (x = o.timezoneZ.exec(g), x))
      return 0;
    var y;
    if (x = o.timezoneHH.exec(g), x)
      return y = parseInt(x[1], 10), d(y) ? -(y * s) : NaN;
    if (x = o.timezoneHHMM.exec(g), x) {
      y = parseInt(x[1], 10);
      var b = parseInt(x[2], 10);
      return d(y, b) ? (_ = Math.abs(y) * s + b * a, y > 0 ? -_ : _) : NaN;
    }
    if (p(g)) {
      v = new Date(v || Date.now());
      var w = m ? v : c(v), E = u(w, g), $ = m ? E : f(v, E, g);
      return -$;
    }
    return NaN;
  }
  function c(g) {
    return (0, r.default)(g.getFullYear(), g.getMonth(), g.getDate(), g.getHours(), g.getMinutes(), g.getSeconds(), g.getMilliseconds());
  }
  function u(g, v) {
    var m = (0, n.default)(g, v), x = (0, r.default)(m[0], m[1] - 1, m[2], m[3] % 24, m[4], m[5], 0).getTime(), _ = g.getTime(), y = _ % 1e3;
    return _ -= y >= 0 ? y : 1e3 + y, x - _;
  }
  function f(g, v, m) {
    var x = g.getTime(), _ = x - v, y = u(new Date(_), m);
    if (v === y)
      return v;
    _ -= y - v;
    var b = u(new Date(_), m);
    return y === b ? y : Math.max(y, b);
  }
  function d(g, v) {
    return -23 <= g && g <= 23 && (v == null || 0 <= v && v <= 59);
  }
  var h = {};
  function p(g) {
    if (h[g])
      return !0;
    try {
      return new Intl.DateTimeFormat(void 0, {
        timeZone: g
      }), h[g] = !0, !0;
    } catch {
      return !1;
    }
  }
  e.exports = t.default;
})(yB, ac);
var cc = {}, _B = {
  get exports() {
    return cc;
  },
  set exports(e) {
    cc = e;
  }
};
(function(e, t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.default = void 0;
  var n = /(Z|[+-]\d{2}(?::?\d{2})?| UTC| [a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?)$/, r = n;
  t.default = r, e.exports = t.default;
})(_B, cc);
(function(e, t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.default = f;
  var n = a(ic), r = a(sc), i = a(ac), s = a(cc);
  function a($) {
    return $ && $.__esModule ? $ : { default: $ };
  }
  var o = 36e5, l = 6e4, c = 2, u = {
    dateTimePattern: /^([0-9W+-]+)(T| )(.*)/,
    datePattern: /^([0-9W+-]+)(.*)/,
    plainTime: /:/,
    // year tokens
    YY: /^(\d{2})$/,
    YYY: [
      /^([+-]\d{2})$/,
      // 0 additional digits
      /^([+-]\d{3})$/,
      // 1 additional digit
      /^([+-]\d{4})$/
      // 2 additional digits
    ],
    YYYY: /^(\d{4})/,
    YYYYY: [
      /^([+-]\d{4})/,
      // 0 additional digits
      /^([+-]\d{5})/,
      // 1 additional digit
      /^([+-]\d{6})/
      // 2 additional digits
    ],
    // date tokens
    MM: /^-(\d{2})$/,
    DDD: /^-?(\d{3})$/,
    MMDD: /^-?(\d{2})-?(\d{2})$/,
    Www: /^-?W(\d{2})$/,
    WwwD: /^-?W(\d{2})-?(\d{1})$/,
    HH: /^(\d{2}([.,]\d*)?)$/,
    HHMM: /^(\d{2}):?(\d{2}([.,]\d*)?)$/,
    HHMMSS: /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,
    // time zone tokens (to identify the presence of a tz)
    timeZone: s.default
  };
  function f($, C) {
    if (arguments.length < 1)
      throw new TypeError("1 argument required, but only " + arguments.length + " present");
    if ($ === null)
      return /* @__PURE__ */ new Date(NaN);
    var A = C || {}, k = A.additionalDigits == null ? c : (0, n.default)(A.additionalDigits);
    if (k !== 2 && k !== 1 && k !== 0)
      throw new RangeError("additionalDigits must be 0, 1 or 2");
    if ($ instanceof Date || typeof $ == "object" && Object.prototype.toString.call($) === "[object Date]")
      return new Date($.getTime());
    if (typeof $ == "number" || Object.prototype.toString.call($) === "[object Number]")
      return new Date($);
    if (!(typeof $ == "string" || Object.prototype.toString.call($) === "[object String]"))
      return /* @__PURE__ */ new Date(NaN);
    var D = d($), S = h(D.date, k), L = S.year, P = S.restDateString, H = p(P, L);
    if (isNaN(H))
      return /* @__PURE__ */ new Date(NaN);
    if (H) {
      var M = H.getTime(), B = 0, W;
      if (D.time && (B = g(D.time), isNaN(B)))
        return /* @__PURE__ */ new Date(NaN);
      if (D.timeZone || A.timeZone) {
        if (W = (0, i.default)(D.timeZone || A.timeZone, new Date(M + B)), isNaN(W))
          return /* @__PURE__ */ new Date(NaN);
      } else
        W = (0, r.default)(new Date(M + B)), W = (0, r.default)(new Date(M + B + W));
      return new Date(M + B + W);
    } else
      return /* @__PURE__ */ new Date(NaN);
  }
  function d($) {
    var C = {}, A = u.dateTimePattern.exec($), k;
    if (A ? (C.date = A[1], k = A[3]) : (A = u.datePattern.exec($), A ? (C.date = A[1], k = A[2]) : (C.date = null, k = $)), k) {
      var D = u.timeZone.exec(k);
      D ? (C.time = k.replace(D[1], ""), C.timeZone = D[1].trim()) : C.time = k;
    }
    return C;
  }
  function h($, C) {
    var A = u.YYY[C], k = u.YYYYY[C], D;
    if (D = u.YYYY.exec($) || k.exec($), D) {
      var S = D[1];
      return {
        year: parseInt(S, 10),
        restDateString: $.slice(S.length)
      };
    }
    if (D = u.YY.exec($) || A.exec($), D) {
      var L = D[1];
      return {
        year: parseInt(L, 10) * 100,
        restDateString: $.slice(L.length)
      };
    }
    return {
      year: null
    };
  }
  function p($, C) {
    if (C === null)
      return null;
    var A, k, D, S;
    if ($.length === 0)
      return k = /* @__PURE__ */ new Date(0), k.setUTCFullYear(C), k;
    if (A = u.MM.exec($), A)
      return k = /* @__PURE__ */ new Date(0), D = parseInt(A[1], 10) - 1, y(C, D) ? (k.setUTCFullYear(C, D), k) : /* @__PURE__ */ new Date(NaN);
    if (A = u.DDD.exec($), A) {
      k = /* @__PURE__ */ new Date(0);
      var L = parseInt(A[1], 10);
      return b(C, L) ? (k.setUTCFullYear(C, 0, L), k) : /* @__PURE__ */ new Date(NaN);
    }
    if (A = u.MMDD.exec($), A) {
      k = /* @__PURE__ */ new Date(0), D = parseInt(A[1], 10) - 1;
      var P = parseInt(A[2], 10);
      return y(C, D, P) ? (k.setUTCFullYear(C, D, P), k) : /* @__PURE__ */ new Date(NaN);
    }
    if (A = u.Www.exec($), A)
      return S = parseInt(A[1], 10) - 1, w(C, S) ? v(C, S) : /* @__PURE__ */ new Date(NaN);
    if (A = u.WwwD.exec($), A) {
      S = parseInt(A[1], 10) - 1;
      var H = parseInt(A[2], 10) - 1;
      return w(C, S, H) ? v(C, S, H) : /* @__PURE__ */ new Date(NaN);
    }
    return null;
  }
  function g($) {
    var C, A, k;
    if (C = u.HH.exec($), C)
      return A = parseFloat(C[1].replace(",", ".")), E(A) ? A % 24 * o : NaN;
    if (C = u.HHMM.exec($), C)
      return A = parseInt(C[1], 10), k = parseFloat(C[2].replace(",", ".")), E(A, k) ? A % 24 * o + k * l : NaN;
    if (C = u.HHMMSS.exec($), C) {
      A = parseInt(C[1], 10), k = parseInt(C[2], 10);
      var D = parseFloat(C[3].replace(",", "."));
      return E(A, k, D) ? A % 24 * o + k * l + D * 1e3 : NaN;
    }
    return null;
  }
  function v($, C, A) {
    C = C || 0, A = A || 0;
    var k = /* @__PURE__ */ new Date(0);
    k.setUTCFullYear($, 0, 4);
    var D = k.getUTCDay() || 7, S = C * 7 + A + 1 - D;
    return k.setUTCDate(k.getUTCDate() + S), k;
  }
  var m = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], x = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function _($) {
    return $ % 400 === 0 || $ % 4 === 0 && $ % 100 !== 0;
  }
  function y($, C, A) {
    if (C < 0 || C > 11)
      return !1;
    if (A != null) {
      if (A < 1)
        return !1;
      var k = _($);
      if (k && A > x[C] || !k && A > m[C])
        return !1;
    }
    return !0;
  }
  function b($, C) {
    if (C < 1)
      return !1;
    var A = _($);
    return !(A && C > 366 || !A && C > 365);
  }
  function w($, C, A) {
    return !(C < 0 || C > 52 || A != null && (A < 0 || A > 6));
  }
  function E($, C, A) {
    return !($ != null && ($ < 0 || $ >= 25) || C != null && (C < 0 || C >= 60) || A != null && (A < 0 || A >= 60));
  }
  e.exports = t.default;
})(gB, rc);
const wB = /* @__PURE__ */ XC(rc);
function Vt(e, t) {
  if (t.length < e)
    throw new TypeError(e + " argument" + (e > 1 ? "s" : "") + " required, but only " + t.length + " present");
}
function Cl(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Cl = function(n) {
    return typeof n;
  } : Cl = function(n) {
    return n && typeof Symbol == "function" && n.constructor === Symbol && n !== Symbol.prototype ? "symbol" : typeof n;
  }, Cl(e);
}
function hr(e) {
  Vt(1, arguments);
  var t = Object.prototype.toString.call(e);
  return e instanceof Date || Cl(e) === "object" && t === "[object Date]" ? new Date(e.getTime()) : typeof e == "number" || t === "[object Number]" ? new Date(e) : ((typeof e == "string" || t === "[object String]") && typeof console < "u" && (console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments"), console.warn(new Error().stack)), /* @__PURE__ */ new Date(NaN));
}
function zs(e) {
  if (e === null || e === !0 || e === !1)
    return NaN;
  var t = Number(e);
  return isNaN(t) ? t : t < 0 ? Math.ceil(t) : Math.floor(t);
}
var $B = {};
function yh() {
  return $B;
}
function mi(e, t) {
  var n, r, i, s, a, o, l, c;
  Vt(1, arguments);
  var u = yh(), f = zs((n = (r = (i = (s = t == null ? void 0 : t.weekStartsOn) !== null && s !== void 0 ? s : t == null || (a = t.locale) === null || a === void 0 || (o = a.options) === null || o === void 0 ? void 0 : o.weekStartsOn) !== null && i !== void 0 ? i : u.weekStartsOn) !== null && r !== void 0 ? r : (l = u.locale) === null || l === void 0 || (c = l.options) === null || c === void 0 ? void 0 : c.weekStartsOn) !== null && n !== void 0 ? n : 0);
  if (!(f >= 0 && f <= 6))
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  var d = hr(e), h = d.getDay(), p = (h < f ? 7 : 0) + h - f;
  return d.setDate(d.getDate() - p), d.setHours(0, 0, 0, 0), d;
}
function qg(e) {
  var t = new Date(Date.UTC(e.getFullYear(), e.getMonth(), e.getDate(), e.getHours(), e.getMinutes(), e.getSeconds(), e.getMilliseconds()));
  return t.setUTCFullYear(e.getFullYear()), e.getTime() - t.getTime();
}
var EB = 6048e5;
function AB(e, t, n) {
  Vt(2, arguments);
  var r = mi(e, n), i = mi(t, n), s = r.getTime() - qg(r), a = i.getTime() - qg(i);
  return Math.round((s - a) / EB);
}
function kB(e) {
  Vt(1, arguments);
  var t = hr(e), n = t.getMonth();
  return t.setFullYear(t.getFullYear(), n + 1, 0), t.setHours(0, 0, 0, 0), t;
}
function CB(e) {
  Vt(1, arguments);
  var t = hr(e);
  return t.setDate(1), t.setHours(0, 0, 0, 0), t;
}
function DB(e, t) {
  return Vt(1, arguments), AB(kB(e), CB(e), t) + 1;
}
function SB(e, t) {
  var n, r, i, s, a, o, l, c;
  Vt(1, arguments);
  var u = hr(e), f = u.getFullYear(), d = yh(), h = zs((n = (r = (i = (s = t == null ? void 0 : t.firstWeekContainsDate) !== null && s !== void 0 ? s : t == null || (a = t.locale) === null || a === void 0 || (o = a.options) === null || o === void 0 ? void 0 : o.firstWeekContainsDate) !== null && i !== void 0 ? i : d.firstWeekContainsDate) !== null && r !== void 0 ? r : (l = d.locale) === null || l === void 0 || (c = l.options) === null || c === void 0 ? void 0 : c.firstWeekContainsDate) !== null && n !== void 0 ? n : 1);
  if (!(h >= 1 && h <= 7))
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  var p = /* @__PURE__ */ new Date(0);
  p.setFullYear(f + 1, 0, h), p.setHours(0, 0, 0, 0);
  var g = mi(p, t), v = /* @__PURE__ */ new Date(0);
  v.setFullYear(f, 0, h), v.setHours(0, 0, 0, 0);
  var m = mi(v, t);
  return u.getTime() >= g.getTime() ? f + 1 : u.getTime() >= m.getTime() ? f : f - 1;
}
function TB(e, t) {
  var n, r, i, s, a, o, l, c;
  Vt(1, arguments);
  var u = yh(), f = zs((n = (r = (i = (s = t == null ? void 0 : t.firstWeekContainsDate) !== null && s !== void 0 ? s : t == null || (a = t.locale) === null || a === void 0 || (o = a.options) === null || o === void 0 ? void 0 : o.firstWeekContainsDate) !== null && i !== void 0 ? i : u.firstWeekContainsDate) !== null && r !== void 0 ? r : (l = u.locale) === null || l === void 0 || (c = l.options) === null || c === void 0 ? void 0 : c.firstWeekContainsDate) !== null && n !== void 0 ? n : 1), d = SB(e, t), h = /* @__PURE__ */ new Date(0);
  h.setFullYear(d, 0, f), h.setHours(0, 0, 0, 0);
  var p = mi(h, t);
  return p;
}
var OB = 6048e5;
function MB(e, t) {
  Vt(1, arguments);
  var n = hr(e), r = mi(n, t).getTime() - TB(n, t).getTime();
  return Math.round(r / OB) + 1;
}
function uc(e) {
  return Vt(1, arguments), mi(e, {
    weekStartsOn: 1
  });
}
function PB(e) {
  Vt(1, arguments);
  var t = hr(e), n = t.getFullYear(), r = /* @__PURE__ */ new Date(0);
  r.setFullYear(n + 1, 0, 4), r.setHours(0, 0, 0, 0);
  var i = uc(r), s = /* @__PURE__ */ new Date(0);
  s.setFullYear(n, 0, 4), s.setHours(0, 0, 0, 0);
  var a = uc(s);
  return t.getTime() >= i.getTime() ? n + 1 : t.getTime() >= a.getTime() ? n : n - 1;
}
function IB(e) {
  Vt(1, arguments);
  var t = PB(e), n = /* @__PURE__ */ new Date(0);
  n.setFullYear(t, 0, 4), n.setHours(0, 0, 0, 0);
  var r = uc(n);
  return r;
}
var RB = 6048e5;
function BB(e) {
  Vt(1, arguments);
  var t = hr(e), n = uc(t).getTime() - IB(t).getTime();
  return Math.round(n / RB) + 1;
}
function Yt(e, t) {
  Vt(2, arguments);
  var n = hr(e), r = zs(t);
  return isNaN(r) ? /* @__PURE__ */ new Date(NaN) : (r && n.setDate(n.getDate() + r), n);
}
function fc(e, t) {
  Vt(2, arguments);
  var n = hr(e), r = zs(t);
  if (isNaN(r))
    return /* @__PURE__ */ new Date(NaN);
  if (!r)
    return n;
  var i = n.getDate(), s = new Date(n.getTime());
  s.setMonth(n.getMonth() + r + 1, 0);
  var a = s.getDate();
  return i >= a ? s : (n.setFullYear(s.getFullYear(), s.getMonth(), i), n);
}
function Gg(e, t) {
  Vt(2, arguments);
  var n = zs(t);
  return fc(e, n * 12);
}
var Ji = /* @__PURE__ */ ((e) => (e.Any = "any", e.All = "all", e))(Ji || {}), m_ = /* @__PURE__ */ ((e) => (e.Days = "days", e.Weeks = "weeks", e.Months = "months", e.Years = "years", e))(m_ || {}), y_ = /* @__PURE__ */ ((e) => (e.Days = "days", e.Weekdays = "weekdays", e.Weeks = "weeks", e.Months = "months", e.Years = "years", e))(y_ || {}), x_ = /* @__PURE__ */ ((e) => (e.OrdinalWeekdays = "ordinalWeekdays", e))(x_ || {});
class NB {
  constructor(t, n, r) {
    se(this, "validated", !0), this.type = t, this.interval = n, this.from = r, this.from || (console.error(
      'A valid "from" date is required for date interval rule. This rule will be skipped.'
    ), this.validated = !1);
  }
  passes(t) {
    if (!this.validated)
      return !0;
    const { date: n } = t;
    switch (this.type) {
      case "days":
        return xh(this.from.date, n) % this.interval === 0;
      case "weeks":
        return n5(this.from.date, n) % this.interval === 0;
      case "months":
        return r5(this.from.date, n) % this.interval === 0;
      case "years":
        return C_(this.from.date, n) % this.interval === 0;
      default:
        return !1;
    }
  }
}
class Vs {
  constructor(t, n, r, i) {
    se(this, "components", []), this.type = t, this.validator = r, this.getter = i, this.components = this.normalizeComponents(n);
  }
  static create(t, n) {
    switch (t) {
      case "days":
        return new LB(n);
      case "weekdays":
        return new jB(n);
      case "weeks":
        return new zB(n);
      case "months":
        return new VB(n);
      case "years":
        return new HB(n);
    }
  }
  normalizeComponents(t) {
    if (this.validator(t))
      return [t];
    if (!pn(t))
      return [];
    const n = [];
    return t.forEach((r) => {
      if (!this.validator(r)) {
        console.error(
          `Component value ${r} in invalid for "${this.type}" rule. This rule will be skipped.`
        );
        return;
      }
      n.push(r);
    }), n;
  }
  passes(t) {
    return this.getter(t).some((i) => this.components.includes(i));
  }
}
class LB extends Vs {
  constructor(t) {
    super(
      "days",
      t,
      YB,
      ({ day: n, dayFromEnd: r }) => [n, -r]
    );
  }
}
class jB extends Vs {
  constructor(t) {
    super(
      "weekdays",
      t,
      Md,
      ({ weekday: n }) => [n]
    );
  }
}
class zB extends Vs {
  constructor(t) {
    super(
      "weeks",
      t,
      qB,
      ({ week: n, weekFromEnd: r }) => [n, -r]
    );
  }
}
class VB extends Vs {
  constructor(t) {
    super("months", t, GB, ({ month: n }) => [
      n
    ]);
  }
}
class HB extends Vs {
  constructor(t) {
    super("years", t, kn, ({ year: n }) => [n]);
  }
}
class WB {
  constructor(t, n) {
    se(this, "components"), this.type = t, this.components = this.normalizeComponents(n);
  }
  normalizeArrayConfig(t) {
    const n = [];
    return t.forEach((r, i) => {
      if (kn(r)) {
        if (i === 0)
          return;
        if (!Xg(t[0])) {
          console.error(
            `Ordinal range for "${this.type}" rule is from -5 to -1 or 1 to 5. This rule will be skipped.`
          );
          return;
        }
        if (!Md(r)) {
          console.error(
            `Acceptable range for "${this.type}" rule is from 1 to 5. This rule will be skipped`
          );
          return;
        }
        n.push([t[0], r]);
      } else
        pn(r) && n.push(...this.normalizeArrayConfig(r));
    }), n;
  }
  normalizeComponents(t) {
    const n = [];
    return t.forEach((r, i) => {
      if (kn(r)) {
        if (i === 0)
          return;
        if (!Xg(t[0])) {
          console.error(
            `Ordinal range for "${this.type}" rule is from -5 to -1 or 1 to 5. This rule will be skipped.`
          );
          return;
        }
        if (!Md(r)) {
          console.error(
            `Acceptable range for "${this.type}" rule is from 1 to 5. This rule will be skipped`
          );
          return;
        }
        n.push([t[0], r]);
      } else
        pn(r) && n.push(...this.normalizeArrayConfig(r));
    }), n;
  }
  passes(t) {
    const { weekday: n, weekdayOrdinal: r, weekdayOrdinalFromEnd: i } = t;
    return this.components.some(
      ([s, a]) => (s === r || s === -i) && n === a
    );
  }
}
class UB {
  constructor(t) {
    se(this, "type", "function"), se(this, "validated", !0), this.fn = t, Ei(t) || (console.error(
      "The function rule requires a valid function. This rule will be skipped."
    ), this.validated = !1);
  }
  passes(t) {
    return this.validated ? this.fn(t) : !0;
  }
}
class dc {
  constructor(t, n = {}, r) {
    se(this, "validated", !0), se(this, "config"), se(this, "type", Ji.Any), se(this, "from"), se(this, "until"), se(this, "rules", []), se(this, "locale", new pc()), this.parent = r, n.locale && (this.locale = n.locale), this.config = t, Ei(t) ? (this.type = Ji.All, this.rules = [new UB(t)]) : pn(t) ? (this.type = Ji.Any, this.rules = t.map((i) => new dc(i, n, this))) : or(t) ? (this.type = Ji.All, this.from = t.from ? this.locale.getDateParts(t.from) : r == null ? void 0 : r.from, this.until = t.until ? this.locale.getDateParts(t.until) : r == null ? void 0 : r.until, this.rules = this.getObjectRules(t)) : (console.error("Rule group configuration must be an object or an array."), this.validated = !1);
  }
  getObjectRules(t) {
    const n = [];
    if (t.every && (Pn(t.every) && (t.every = [1, `${t.every}s`]), pn(t.every))) {
      const [r = 1, i = m_.Days] = t.every;
      n.push(new NB(i, r, this.from));
    }
    return Object.values(y_).forEach((r) => {
      r in t && n.push(Vs.create(r, t[r]));
    }), Object.values(x_).forEach((r) => {
      r in t && n.push(new WB(r, t[r]));
    }), t.on != null && (pn(t.on) || (t.on = [t.on]), n.push(
      new dc(t.on, { locale: this.locale }, this.parent)
    )), n;
  }
  passes(t) {
    return this.validated ? this.from && t.dayIndex <= this.from.dayIndex || this.until && t.dayIndex >= this.until.dayIndex ? !1 : this.type === Ji.Any ? this.rules.some((n) => n.passes(t)) : this.rules.every((n) => n.passes(t)) : !0;
  }
}
function YB(e) {
  return kn(e) ? e >= 1 && e <= 31 : !1;
}
function Md(e) {
  return kn(e) ? e >= 1 && e <= 7 : !1;
}
function qB(e) {
  return kn(e) ? e >= -6 && e <= -1 || e >= 1 && e <= 6 : !1;
}
function GB(e) {
  return kn(e) ? e >= 1 && e <= 12 : !1;
}
function Xg(e) {
  return !(!kn(e) || e < -5 || e > 5 || e === 0);
}
const XB = {
  dateTime: [
    "year",
    "month",
    "day",
    "hours",
    "minutes",
    "seconds",
    "milliseconds"
  ],
  date: ["year", "month", "day"],
  time: ["hours", "minutes", "seconds", "milliseconds"]
}, Rt = 7, ZB = 6, b_ = 1e3, __ = b_ * 60, w_ = __ * 60, Dl = w_ * 24, KB = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], JB = ["L", "iso"], va = {
  milliseconds: [0, 999, 3],
  seconds: [0, 59, 2],
  minutes: [0, 59, 2],
  hours: [0, 23, 2]
}, $_ = /d{1,2}|W{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|Z{1,4}|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g, QB = /\[([^]*?)\]/gm, Zg = {
  D(e) {
    return e.day;
  },
  DD(e) {
    return Le(e.day, 2);
  },
  // Do(d: DateParts, l: Locale) {
  //   return l.DoFn(d.day);
  // },
  d(e) {
    return e.weekday - 1;
  },
  dd(e) {
    return Le(e.weekday - 1, 2);
  },
  W(e, t) {
    return t.dayNamesNarrow[e.weekday - 1];
  },
  WW(e, t) {
    return t.dayNamesShorter[e.weekday - 1];
  },
  WWW(e, t) {
    return t.dayNamesShort[e.weekday - 1];
  },
  WWWW(e, t) {
    return t.dayNames[e.weekday - 1];
  },
  M(e) {
    return e.month;
  },
  MM(e) {
    return Le(e.month, 2);
  },
  MMM(e, t) {
    return t.monthNamesShort[e.month - 1];
  },
  MMMM(e, t) {
    return t.monthNames[e.month - 1];
  },
  YY(e) {
    return String(e.year).substr(2);
  },
  YYYY(e) {
    return Le(e.year, 4);
  },
  h(e) {
    return e.hours % 12 || 12;
  },
  hh(e) {
    return Le(e.hours % 12 || 12, 2);
  },
  H(e) {
    return e.hours;
  },
  HH(e) {
    return Le(e.hours, 2);
  },
  m(e) {
    return e.minutes;
  },
  mm(e) {
    return Le(e.minutes, 2);
  },
  s(e) {
    return e.seconds;
  },
  ss(e) {
    return Le(e.seconds, 2);
  },
  S(e) {
    return Math.round(e.milliseconds / 100);
  },
  SS(e) {
    return Le(Math.round(e.milliseconds / 10), 2);
  },
  SSS(e) {
    return Le(e.milliseconds, 3);
  },
  a(e, t) {
    return e.hours < 12 ? t.amPm[0] : t.amPm[1];
  },
  A(e, t) {
    return e.hours < 12 ? t.amPm[0].toUpperCase() : t.amPm[1].toUpperCase();
  },
  Z() {
    return "Z";
  },
  ZZ(e) {
    const t = e.timezoneOffset;
    return `${t > 0 ? "-" : "+"}${Le(Math.floor(Math.abs(t) / 60), 2)}`;
  },
  ZZZ(e) {
    const t = e.timezoneOffset;
    return `${t > 0 ? "-" : "+"}${Le(
      Math.floor(Math.abs(t) / 60) * 100 + Math.abs(t) % 60,
      4
    )}`;
  },
  ZZZZ(e) {
    const t = e.timezoneOffset;
    return `${t > 0 ? "-" : "+"}${Le(Math.floor(Math.abs(t) / 60), 2)}:${Le(
      Math.abs(t) % 60,
      2
    )}`;
  }
}, _r = /\d\d?/, e5 = /\d{3}/, t5 = /\d{4}/, ta = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF/]+(\s*?[\u0600-\u06FF]+){1,2}/i, Kg = () => {
}, Jg = (e) => (t, n, r) => {
  const i = r[e].indexOf(
    n.charAt(0).toUpperCase() + n.substr(1).toLowerCase()
  );
  ~i && (t.month = i);
}, Ve = {
  D: [
    _r,
    (e, t) => {
      e.day = t;
    }
  ],
  Do: [
    new RegExp(_r.source + ta.source),
    (e, t) => {
      e.day = parseInt(t, 10);
    }
  ],
  d: [_r, Kg],
  W: [ta, Kg],
  M: [
    _r,
    (e, t) => {
      e.month = t - 1;
    }
  ],
  MMM: [ta, Jg("monthNamesShort")],
  MMMM: [ta, Jg("monthNames")],
  YY: [
    _r,
    (e, t) => {
      const r = +(/* @__PURE__ */ new Date()).getFullYear().toString().substr(0, 2);
      e.year = +`${t > 68 ? r - 1 : r}${t}`;
    }
  ],
  YYYY: [
    t5,
    (e, t) => {
      e.year = t;
    }
  ],
  S: [
    /\d/,
    (e, t) => {
      e.milliseconds = t * 100;
    }
  ],
  SS: [
    /\d{2}/,
    (e, t) => {
      e.milliseconds = t * 10;
    }
  ],
  SSS: [
    e5,
    (e, t) => {
      e.milliseconds = t;
    }
  ],
  h: [
    _r,
    (e, t) => {
      e.hours = t;
    }
  ],
  m: [
    _r,
    (e, t) => {
      e.minutes = t;
    }
  ],
  s: [
    _r,
    (e, t) => {
      e.seconds = t;
    }
  ],
  a: [
    ta,
    (e, t, n) => {
      const r = t.toLowerCase();
      r === n.amPm[0] ? e.isPm = !1 : r === n.amPm[1] && (e.isPm = !0);
    }
  ],
  Z: [
    /[^\s]*?[+-]\d\d:?\d\d|[^\s]*?Z?/,
    (e, t) => {
      t === "Z" && (t = "+00:00");
      const n = `${t}`.match(/([+-]|\d\d)/gi);
      if (n) {
        const r = +n[1] * 60 + parseInt(n[2], 10);
        e.timezoneOffset = n[0] === "+" ? r : -r;
      }
    }
  ]
};
Ve.DD = Ve.D;
Ve.dd = Ve.d;
Ve.WWWW = Ve.WWW = Ve.WW = Ve.W;
Ve.MM = Ve.M;
Ve.mm = Ve.m;
Ve.hh = Ve.H = Ve.HH = Ve.h;
Ve.ss = Ve.s;
Ve.A = Ve.a;
Ve.ZZZZ = Ve.ZZZ = Ve.ZZ = Ve.Z;
function E_(e, t) {
  return (tr(e) && e || [
    Pn(e) && e || "YYYY-MM-DD"
  ]).map(
    (n) => JB.reduce(
      (r, i) => r.replace(i, t.masks[i] || ""),
      n
    )
  );
}
function A_(e) {
  return or(e) && "year" in e && "month" in e && "day" in e;
}
function Qg(e, t = 1) {
  const n = e.getDay() + 1, r = n >= t ? t - n : -(7 - (t - n));
  return Yt(e, r);
}
function k_(e, t, n) {
  const r = Date.UTC(e, t - 1, n);
  return xh(/* @__PURE__ */ new Date(0), new Date(r));
}
function xh(e, t) {
  return Math.round((t.getTime() - e.getTime()) / Dl);
}
function n5(e, t) {
  return Math.ceil(xh(Qg(e), Qg(t)) / 7);
}
function C_(e, t) {
  return t.getUTCFullYear() - e.getUTCFullYear();
}
function r5(e, t) {
  return C_(e, t) * 12 + (t.getMonth() - e.getMonth());
}
function D_(e, t = "") {
  const n = /* @__PURE__ */ new Date(), {
    year: r = n.getFullYear(),
    month: i = n.getMonth() + 1,
    day: s = n.getDate(),
    hours: a = 0,
    minutes: o = 0,
    seconds: l = 0,
    milliseconds: c = 0
  } = e;
  if (t) {
    const u = `${Le(r, 4)}-${Le(i, 2)}-${Le(s, 2)}T${Le(
      a,
      2
    )}:${Le(o, 2)}:${Le(l, 2)}.${Le(c, 3)}`;
    return wB(u, { timeZone: t });
  }
  return new Date(r, i - 1, s, a, o, l, c);
}
function i5(e, t) {
  let n = new Date(e.getTime());
  t.timezone && (n = new Date(
    e.toLocaleString("en-US", { timeZone: t.timezone })
  ), n.setMilliseconds(e.getMilliseconds()));
  const r = n.getMilliseconds(), i = n.getSeconds(), s = n.getMinutes(), a = n.getHours(), o = r + i * b_ + s * __ + a * w_, l = n.getMonth() + 1, c = n.getFullYear(), u = t.getMonthParts(l, c), f = n.getDate(), d = u.numDays - f + 1, h = n.getDay() + 1, p = Math.floor((f - 1) / 7 + 1), g = Math.floor((u.numDays - f) / 7 + 1), v = Math.ceil(
    (f + Math.abs(u.firstWeekday - u.firstDayOfWeek)) / 7
  ), m = u.numWeeks - v + 1, x = u.weeknumbers[v], _ = k_(c, l, f);
  return {
    milliseconds: r,
    seconds: i,
    minutes: s,
    hours: a,
    time: o,
    day: f,
    dayFromEnd: d,
    weekday: h,
    weekdayOrdinal: p,
    weekdayOrdinalFromEnd: g,
    week: v,
    weekFromEnd: m,
    weeknumber: x,
    month: l,
    year: c,
    date: n,
    dateTime: n.getTime(),
    dayIndex: _,
    timezoneOffset: 0,
    isValid: !0
  };
}
function s5(e, t, n) {
  return `${t}-${e}-${n}`;
}
function a5(e, t, n) {
  const r = t % 4 === 0 && t % 100 !== 0 || t % 400 === 0, i = new Date(t, e - 1, 1), s = i.getDay() + 1, a = e === 2 && r ? 29 : KB[e - 1], o = n - 1, l = DB(i, {
    weekStartsOn: o
  }), c = [], u = [];
  for (let f = 0; f < l; f++) {
    const d = Yt(i, f * 7);
    c.push(MB(d, { weekStartsOn: o })), u.push(BB(d));
  }
  return {
    firstDayOfWeek: n,
    firstDayOfMonth: i,
    inLeapYear: r,
    firstWeekday: s,
    numDays: a,
    numWeeks: l,
    month: e,
    year: t,
    weeknumbers: c,
    isoWeeknumbers: u
  };
}
function o5() {
  const e = [];
  for (let i = 0; i < Rt; i++)
    e.push(
      D_({
        year: 2020,
        month: 1,
        day: 5 + i,
        hours: 12
      })
    );
  return e;
}
function qu(e, t = void 0) {
  const n = new Intl.DateTimeFormat(t, {
    weekday: e
  });
  return o5().map((r) => n.format(r));
}
function l5() {
  const e = [];
  for (let t = 0; t <= 24; t++)
    e.push(new Date(2e3, 0, 1, t));
  return e;
}
function c5(e = void 0) {
  const t = [
    "second",
    "minute",
    "hour",
    "day",
    "week",
    "month",
    "quarter",
    "year"
  ], n = new Intl.RelativeTimeFormat(e);
  return t.reduce((r, i) => {
    const s = n.formatToParts(100, i);
    return r[i] = s[1].unit, r;
  }, {});
}
function S_() {
  const e = [];
  for (let t = 0; t < 12; t++)
    e.push(new Date(2e3, t, 15));
  return e;
}
function ev(e, t = void 0) {
  const n = new Intl.DateTimeFormat(t, {
    month: e,
    timeZone: "UTC"
  });
  return S_().map((r) => n.format(r));
}
function u5(e, t, n) {
  return kn(t) ? t === e : pn(t) ? t.includes(e) : Ei(t) ? t(e, n) : !(t.min != null && t.min > e || t.max != null && t.max < e || t.interval != null && e % t.interval !== 0);
}
function ma(e, t, n) {
  const r = [], [i, s, a] = t;
  for (let o = i; o <= s; o++)
    (n == null || u5(o, n, e)) && r.push({
      value: o,
      label: Le(o, a)
    });
  return r;
}
function f5(e, t) {
  return {
    milliseconds: ma(
      e,
      va.milliseconds,
      t.milliseconds
    ),
    seconds: ma(e, va.seconds, t.seconds),
    minutes: ma(e, va.minutes, t.minutes),
    hours: ma(e, va.hours, t.hours)
  };
}
function d5(e, t, n, r) {
  const s = ma(e, t, r).reduce((a, o) => {
    if (o.disabled)
      return a;
    if (isNaN(a))
      return o.value;
    const l = Math.abs(a - n);
    return Math.abs(o.value - n) < l ? o.value : a;
  }, NaN);
  return isNaN(s) ? n : s;
}
function h5(e, t) {
  const n = { ...e };
  return Object.entries(t).forEach(([r, i]) => {
    const s = va[r], a = e[r];
    n[r] = d5(
      e,
      s,
      a,
      i
    );
  }), n;
}
function tv(e, t, n) {
  return E_(t, n).map((i) => {
    if (typeof i != "string")
      throw new Error("Invalid mask");
    let s = e;
    if (s.length > 1e3)
      return !1;
    let a = !0;
    const o = {};
    if (i.replace($_, (u) => {
      if (Ve[u]) {
        const f = Ve[u], d = s.search(f[0]);
        ~d ? s.replace(f[0], (h) => (f[1](o, h, n), s = s.substr(d + h.length), h)) : a = !1;
      }
      return Ve[u] ? "" : u.slice(1, u.length - 1);
    }), !a)
      return !1;
    const l = /* @__PURE__ */ new Date();
    o.hours != null && (o.isPm === !0 && +o.hours != 12 ? o.hours = +o.hours + 12 : o.isPm === !1 && +o.hours == 12 && (o.hours = 0));
    let c;
    return o.timezoneOffset != null ? (o.minutes = +(o.minutes || 0) - +o.timezoneOffset, c = new Date(
      Date.UTC(
        o.year || l.getFullYear(),
        o.month || 0,
        o.day || 1,
        o.hours || 0,
        o.minutes || 0,
        o.seconds || 0,
        o.milliseconds || 0
      )
    )) : c = n.getDateFromParts({
      year: o.year || l.getFullYear(),
      month: (o.month || 0) + 1,
      day: o.day || 1,
      hours: o.hours || 0,
      minutes: o.minutes || 0,
      seconds: o.seconds || 0,
      milliseconds: o.milliseconds || 0
    }), c;
  }).find((i) => i) || new Date(e);
}
function p5(e, t, n) {
  if (e == null)
    return "";
  let r = E_(t, n)[0];
  /Z$/.test(r) && (n.timezone = "utc");
  const i = [];
  r = r.replace(QB, (a, o) => (i.push(o), "??"));
  const s = n.getDateParts(e);
  return r = r.replace(
    $_,
    (a) => a in Zg ? Zg[a](s, n) : a.slice(1, a.length - 1)
  ), r.replace(/\?\?/g, () => i.shift());
}
const g5 = {
  daily: ["year", "month", "day"],
  weekly: ["year", "month", "week"],
  monthly: ["year", "month"]
};
function v5({
  monthComps: e,
  prevMonthComps: t,
  nextMonthComps: n
}, r) {
  const i = [], {
    firstDayOfWeek: s,
    firstWeekday: a,
    isoWeeknumbers: o,
    weeknumbers: l,
    numDays: c,
    numWeeks: u
  } = e, f = a + (a < s ? Rt : 0) - s;
  let d = !0, h = !1, p = !1, g = 0;
  const v = new Intl.DateTimeFormat(r.id, {
    weekday: "long",
    year: "numeric",
    month: "short",
    day: "numeric"
  });
  let m = t.numDays - f + 1, x = t.numDays - m + 1, _ = Math.floor((m - 1) / Rt + 1), y = 1, b = t.numWeeks, w = 1, E = t.month, $ = t.year;
  const C = /* @__PURE__ */ new Date(), A = C.getDate(), k = C.getMonth() + 1, D = C.getFullYear();
  for (let S = 1; S <= ZB; S++) {
    for (let L = 1, P = s; L <= Rt; L++, P += P === Rt ? 1 - Rt : 1) {
      d && P === a && (m = 1, x = e.numDays, _ = Math.floor((m - 1) / Rt + 1), y = Math.floor((c - m) / Rt + 1), b = 1, w = u, E = e.month, $ = e.year, d = !1, h = !0);
      const H = r.getDateFromParams($, E, m, 0, 0, 0, 0), M = r.getDateFromParams($, E, m, 12, 0, 0, 0), B = r.getDateFromParams(
        $,
        E,
        m,
        23,
        59,
        59,
        999
      ), W = H, R = `${Le($, 4)}-${Le(E, 2)}-${Le(m, 2)}`, O = L, N = Rt - L, z = l[S - 1], I = o[S - 1], te = m === A && E === k && $ === D, ee = h && m === 1, _e = h && m === c, re = S === 1, Ae = S === u, st = L === 1, ut = L === Rt, yt = k_($, E, m);
      i.push({
        locale: r,
        id: R,
        position: ++g,
        label: m.toString(),
        ariaLabel: v.format(new Date($, E - 1, m)),
        day: m,
        dayFromEnd: x,
        weekday: P,
        weekdayPosition: O,
        weekdayPositionFromEnd: N,
        weekdayOrdinal: _,
        weekdayOrdinalFromEnd: y,
        week: b,
        weekFromEnd: w,
        weekPosition: S,
        weeknumber: z,
        isoWeeknumber: I,
        month: E,
        year: $,
        date: W,
        startDate: H,
        endDate: B,
        noonDate: M,
        dayIndex: yt,
        isToday: te,
        isFirstDay: ee,
        isLastDay: _e,
        isDisabled: !h,
        isFocusable: !h,
        isFocused: !1,
        inMonth: h,
        inPrevMonth: d,
        inNextMonth: p,
        onTop: re,
        onBottom: Ae,
        onLeft: st,
        onRight: ut,
        classes: [
          `id-${R}`,
          `day-${m}`,
          `day-from-end-${x}`,
          `weekday-${P}`,
          `weekday-position-${O}`,
          `weekday-ordinal-${_}`,
          `weekday-ordinal-from-end-${y}`,
          `week-${b}`,
          `week-from-end-${w}`,
          {
            "is-today": te,
            "is-first-day": ee,
            "is-last-day": _e,
            "in-month": h,
            "in-prev-month": d,
            "in-next-month": p,
            "on-top": re,
            "on-bottom": Ae,
            "on-left": st,
            "on-right": ut
          }
        ]
      }), h && _e ? (h = !1, p = !0, m = 1, x = c, _ = 1, y = Math.floor((c - m) / Rt + 1), b = 1, w = n.numWeeks, E = n.month, $ = n.year) : (m++, x--, _ = Math.floor((m - 1) / Rt + 1), y = Math.floor((c - m) / Rt + 1));
    }
    b++, w--;
  }
  return i;
}
function m5(e, t, n, r) {
  const i = e.reduce((s, a, o) => {
    const l = Math.floor(o / 7);
    let c = s[l];
    return c || (c = {
      id: `week-${l + 1}`,
      title: "",
      week: a.week,
      weekPosition: a.weekPosition,
      weeknumber: a.weeknumber,
      isoWeeknumber: a.isoWeeknumber,
      weeknumberDisplay: t ? a.weeknumber : n ? a.isoWeeknumber : void 0,
      days: []
    }, s[l] = c), c.days.push(a), s;
  }, Array(e.length / Rt));
  return i.forEach((s) => {
    const a = s.days[0], o = s.days[s.days.length - 1];
    a.month === o.month ? s.title = `${r.formatDate(a.date, "MMMM YYYY")}` : a.year === o.year ? s.title = `${r.formatDate(
      a.date,
      "MMM"
    )} - ${r.formatDate(o.date, "MMM YYYY")}` : s.title = `${r.formatDate(
      a.date,
      "MMM YYYY"
    )} - ${r.formatDate(o.date, "MMM YYYY")}`;
  }), i;
}
function y5(e, t) {
  return e.days.map((n) => ({
    label: t.formatDate(n.date, t.masks.weekdays),
    weekday: n.weekday
  }));
}
function T_(e, t, n) {
  return v_(
    n.getDateParts(n.toDate(e)),
    g5[t]
  );
}
function O_({ day: e, week: t, month: n, year: r }, i, s, a) {
  if (s === "daily" && e) {
    const o = new Date(r, n - 1, e), l = Yt(o, i);
    return {
      day: l.getDate(),
      month: l.getMonth() + 1,
      year: l.getFullYear()
    };
  } else if (s === "weekly" && t) {
    const l = a.getMonthParts(n, r).firstDayOfMonth, c = Yt(l, (t - 1 + i) * 7), u = a.getDateParts(c);
    return {
      week: u.week,
      month: u.month,
      year: u.year
    };
  } else {
    const o = new Date(r, n - 1, 1), l = fc(o, i);
    return {
      month: l.getMonth() + 1,
      year: l.getFullYear()
    };
  }
}
function In(e) {
  return e != null && e.month != null && e.year != null;
}
function Fd(e, t) {
  return !In(e) || !In(t) ? !1 : (e = e, t = t, e.year !== t.year ? e.year < t.year : e.month && t.month && e.month !== t.month ? e.month < t.month : e.week && t.week && e.week !== t.week ? e.week < t.week : e.day && t.day && e.day !== t.day ? e.day < t.day : !1);
}
function hc(e, t) {
  return !In(e) || !In(t) ? !1 : (e = e, t = t, e.year !== t.year ? e.year > t.year : e.month && t.month && e.month !== t.month ? e.month > t.month : e.week && t.week && e.week !== t.week ? e.week > t.week : e.day && t.day && e.day !== t.day ? e.day > t.day : !1);
}
function M_(e, t, n) {
  return (e || !1) && !Fd(e, t) && !hc(e, n);
}
function x5(e, t) {
  return !e && t || e && !t ? !1 : !e && !t ? !0 : (e = e, t = t, e.year === t.year && e.month === t.month && e.week === t.week && e.day === t.day);
}
function b5(e, t, n, r) {
  if (!In(e) || !In(t))
    return [];
  const i = [];
  for (; !hc(e, t); )
    i.push(e), e = O_(e, 1, n, r);
  return i;
}
function F_(e) {
  const { day: t, week: n, month: r, year: i } = e;
  let s = `${i}-${Le(r, 2)}`;
  return n && (s = `${s}-w${n}`), t && (s = `${s}-${Le(t, 2)}`), s;
}
function _5(e, t) {
  const { month: n, year: r, showWeeknumbers: i, showIsoWeeknumbers: s } = e, a = new Date(r, n - 1, 15), o = t.getMonthParts(n, r), l = t.getPrevMonthParts(n, r), c = t.getNextMonthParts(n, r), u = v5({ monthComps: o, prevMonthComps: l, nextMonthComps: c }, t), f = m5(u, i, s, t), d = y5(f[0], t);
  return {
    id: F_(e),
    month: n,
    year: r,
    monthTitle: t.formatDate(a, t.masks.title),
    shortMonthLabel: t.formatDate(a, "MMM"),
    monthLabel: t.formatDate(a, "MMMM"),
    shortYearLabel: r.toString().substring(2),
    yearLabel: r.toString(),
    monthComps: o,
    prevMonthComps: l,
    nextMonthComps: c,
    days: u,
    weeks: f,
    weekdays: d
  };
}
function w5(e, t) {
  const { day: n, week: r, view: i, trimWeeks: s } = e, a = {
    ...t,
    ...e,
    title: "",
    viewDays: [],
    viewWeeks: []
  };
  switch (i) {
    case "daily": {
      let o = a.days.find((c) => c.inMonth);
      n ? o = a.days.find((c) => c.day === n && c.inMonth) || o : r && (o = a.days.find((c) => c.week === r && c.inMonth));
      const l = a.weeks[o.week - 1];
      a.viewWeeks = [l], a.viewDays = [o], a.week = o.week, a.weekTitle = l.title, a.day = o.day, a.dayTitle = o.ariaLabel, a.title = a.dayTitle;
      break;
    }
    case "weekly": {
      a.week = r || 1;
      const o = a.weeks[a.week - 1];
      a.viewWeeks = [o], a.viewDays = o.days, a.weekTitle = o.title, a.title = a.weekTitle;
      break;
    }
    default: {
      a.title = a.monthTitle, a.viewWeeks = a.weeks.slice(
        0,
        s ? a.monthComps.numWeeks : void 0
      ), a.viewDays = a.days;
      break;
    }
  }
  return a;
}
let nv = class {
  constructor(t, n, r) {
    se(this, "keys", []), se(this, "store", {}), this.size = t, this.createKey = n, this.createItem = r;
  }
  get(...t) {
    const n = this.createKey(...t);
    return this.store[n];
  }
  getOrSet(...t) {
    const n = this.createKey(...t);
    if (this.store[n])
      return this.store[n];
    const r = this.createItem(...t);
    if (this.keys.length >= this.size) {
      const i = this.keys.shift();
      i != null && delete this.store[i];
    }
    return this.keys.push(n), this.store[n] = r, r;
  }
};
class os {
  constructor(t, n = new pc()) {
    se(this, "order"), se(this, "locale"), se(this, "start", null), se(this, "end", null), se(this, "repeat", null);
    var r;
    this.locale = n;
    const { start: i, end: s, span: a, order: o, repeat: l } = t;
    as(i) && (this.start = n.getDateParts(i)), as(s) ? this.end = n.getDateParts(s) : this.start != null && a && (this.end = n.getDateParts(Yt(this.start.date, a - 1))), this.order = o ?? 0, l && (this.repeat = new dc(
      {
        from: (r = this.start) == null ? void 0 : r.date,
        ...l
      },
      {
        locale: this.locale
      }
    ));
  }
  static fromMany(t, n) {
    return (pn(t) ? t : [t]).filter((r) => r).map((r) => os.from(r, n));
  }
  static from(t, n) {
    if (t instanceof os)
      return t;
    const r = {
      start: null,
      end: null
    };
    return t != null && (pn(t) ? (r.start = t[0] ?? null, r.end = t[1] ?? null) : or(t) ? Object.assign(r, t) : (r.start = t, r.end = t)), r.start != null && (r.start = new Date(r.start)), r.end != null && (r.end = new Date(r.end)), new os(r, n);
  }
  get opts() {
    const { order: t, locale: n } = this;
    return { order: t, locale: n };
  }
  get hasRepeat() {
    return !!this.repeat;
  }
  get isSingleDay() {
    const { start: t, end: n } = this;
    return t && n && t.year === n.year && t.month === n.month && t.day === n.day;
  }
  get isMultiDay() {
    return !this.isSingleDay;
  }
  get daySpan() {
    return this.start == null || this.end == null ? this.hasRepeat ? 1 : 1 / 0 : this.end.dayIndex - this.start.dayIndex;
  }
  startsOnDay(t) {
    var n, r;
    return ((n = this.start) == null ? void 0 : n.dayIndex) === t.dayIndex || !!((r = this.repeat) != null && r.passes(t));
  }
  intersectsDay(t) {
    return this.intersectsDayRange(t, t);
  }
  intersectsRange(t) {
    var n, r;
    return this.intersectsDayRange(
      ((n = t.start) == null ? void 0 : n.dayIndex) ?? -1 / 0,
      ((r = t.end) == null ? void 0 : r.dayIndex) ?? 1 / 0
    );
  }
  intersectsDayRange(t, n) {
    return !(this.start && this.start.dayIndex > n || this.end && this.end.dayIndex < t);
  }
}
class $5 {
  constructor() {
    se(this, "records", {});
  }
  render(t, n, r) {
    var i, s, a, o;
    let l = null;
    const c = r[0].dayIndex, u = r[r.length - 1].dayIndex;
    return n.hasRepeat ? r.forEach((f) => {
      var d, h;
      if (n.startsOnDay(f)) {
        const p = n.daySpan < 1 / 0 ? n.daySpan : 1;
        l = {
          startDay: f.dayIndex,
          startTime: ((d = n.start) == null ? void 0 : d.time) ?? 0,
          endDay: f.dayIndex + p - 1,
          endTime: ((h = n.end) == null ? void 0 : h.time) ?? Dl
        }, this.getRangeRecords(t).push(l);
      }
    }) : n.intersectsDayRange(c, u) && (l = {
      startDay: ((i = n.start) == null ? void 0 : i.dayIndex) ?? -1 / 0,
      startTime: ((s = n.start) == null ? void 0 : s.time) ?? -1 / 0,
      endDay: ((a = n.end) == null ? void 0 : a.dayIndex) ?? 1 / 0,
      endTime: ((o = n.end) == null ? void 0 : o.time) ?? 1 / 0
    }, this.getRangeRecords(t).push(l)), l;
  }
  getRangeRecords(t) {
    let n = this.records[t.key];
    return n || (n = {
      ranges: [],
      data: t
    }, this.records[t.key] = n), n.ranges;
  }
  getCell(t, n) {
    return this.getCells(n).find((s) => s.data.key === t);
  }
  cellExists(t, n) {
    const r = this.records[t];
    return r == null ? !1 : r.ranges.some(
      (i) => i.startDay <= n && i.endDay >= n
    );
  }
  getCells(t) {
    const n = Object.values(this.records), r = [], { dayIndex: i } = t;
    return n.forEach(({ data: s, ranges: a }) => {
      a.filter((o) => o.startDay <= i && o.endDay >= i).forEach((o) => {
        const l = i === o.startDay, c = i === o.endDay, u = l ? o.startTime : 0, f = new Date(t.startDate.getTime() + u), d = c ? o.endTime : Dl, h = new Date(t.endDate.getTime() + d), p = u === 0 && d === Dl, g = s.order || 0;
        r.push({
          ...o,
          data: s,
          onStart: l,
          onEnd: c,
          startTime: u,
          startDate: f,
          endTime: d,
          endDate: h,
          allDay: p,
          order: g
        });
      });
    }), r.sort((s, a) => s.order - a.order), r;
  }
}
const E5 = 12, A5 = 5;
function k5(e, t) {
  const n = new Intl.DateTimeFormat().resolvedOptions().locale;
  let r;
  Pn(e) ? r = e : gh(e, "id") && (r = e.id), r = (r || n).toLowerCase();
  const i = Object.keys(t), s = (l) => i.find((c) => c.toLowerCase() === l);
  r = s(r) || s(r.substring(0, 2)) || n;
  const a = {
    ...t["en-IE"],
    ...t[r],
    id: r,
    monthCacheSize: E5,
    pageCacheSize: A5
  };
  return or(e) ? qa(e, a) : a;
}
class pc {
  constructor(t = void 0, n) {
    se(this, "id"), se(this, "daysInWeek"), se(this, "firstDayOfWeek"), se(this, "masks"), se(this, "timezone"), se(this, "hourLabels"), se(this, "dayNames"), se(this, "dayNamesShort"), se(this, "dayNamesShorter"), se(this, "dayNamesNarrow"), se(this, "monthNames"), se(this, "monthNamesShort"), se(this, "relativeTimeNames"), se(this, "amPm", ["am", "pm"]), se(this, "monthCache"), se(this, "pageCache");
    const { id: r, firstDayOfWeek: i, masks: s, monthCacheSize: a, pageCacheSize: o } = k5(t, pB.value);
    this.monthCache = new nv(
      a,
      s5,
      a5
    ), this.pageCache = new nv(o, F_, _5), this.id = r, this.daysInWeek = Rt, this.firstDayOfWeek = LR(i, 1, Rt), this.masks = s, this.timezone = n || void 0, this.hourLabels = this.getHourLabels(), this.dayNames = qu("long", this.id), this.dayNamesShort = qu("short", this.id), this.dayNamesShorter = this.dayNamesShort.map((l) => l.substring(0, 2)), this.dayNamesNarrow = qu("narrow", this.id), this.monthNames = ev("long", this.id), this.monthNamesShort = ev("short", this.id), this.relativeTimeNames = c5(this.id);
  }
  formatDate(t, n) {
    return p5(t, n, this);
  }
  parseDate(t, n) {
    return tv(t, n, this);
  }
  toDate(t, n = {}) {
    const r = /* @__PURE__ */ new Date(NaN);
    let i = r;
    const { fillDate: s, mask: a, patch: o, rules: l } = n;
    if (kn(t) ? (n.type = "number", i = /* @__PURE__ */ new Date(+t)) : Pn(t) ? (n.type = "string", i = t ? tv(t, a || "iso", this) : r) : as(t) ? (n.type = "date", i = new Date(t.getTime())) : A_(t) && (n.type = "object", i = this.getDateFromParts(t)), i && (o || l)) {
      let c = this.getDateParts(i);
      if (o && s != null) {
        const u = this.getDateParts(this.toDate(s));
        c = this.getDateParts(
          this.toDate({ ...u, ...v_(c, XB[o]) })
        );
      }
      l && (c = h5(c, l)), i = this.getDateFromParts(c);
    }
    return i || r;
  }
  toDateOrNull(t, n = {}) {
    const r = this.toDate(t, n);
    return isNaN(r.getTime()) ? null : r;
  }
  fromDate(t, { type: n, mask: r } = {}) {
    switch (n) {
      case "number":
        return t ? t.getTime() : NaN;
      case "string":
        return t ? this.formatDate(t, r || "iso") : "";
      case "object":
        return t ? this.getDateParts(t) : null;
      default:
        return t ? new Date(t) : null;
    }
  }
  range(t) {
    return os.from(t, this);
  }
  ranges(t) {
    return os.fromMany(t, this);
  }
  getDateParts(t) {
    return i5(t, this);
  }
  getDateFromParts(t) {
    return D_(t, this.timezone);
  }
  getDateFromParams(t, n, r, i, s, a, o) {
    return this.getDateFromParts({
      year: t,
      month: n,
      day: r,
      hours: i,
      minutes: s,
      seconds: a,
      milliseconds: o
    });
  }
  getPage(t) {
    const n = this.pageCache.getOrSet(t, this);
    return w5(t, n);
  }
  getMonthParts(t, n) {
    const { firstDayOfWeek: r } = this;
    return this.monthCache.getOrSet(t, n, r);
  }
  getThisMonthParts() {
    const t = /* @__PURE__ */ new Date();
    return this.getMonthParts(
      t.getMonth() + 1,
      t.getFullYear()
    );
  }
  getPrevMonthParts(t, n) {
    return t === 1 ? this.getMonthParts(12, n - 1) : this.getMonthParts(t - 1, n);
  }
  getNextMonthParts(t, n) {
    return t === 12 ? this.getMonthParts(1, n + 1) : this.getMonthParts(t + 1, n);
  }
  getHourLabels() {
    return l5().map((t) => this.formatDate(t, this.masks.hours));
  }
  getDayId(t) {
    return this.formatDate(t, "YYYY-MM-DD");
  }
}
class P_ {
  constructor(t, n, r) {
    se(this, "key", ""), se(this, "hashcode", ""), se(this, "highlight", null), se(this, "content", null), se(this, "dot", null), se(this, "bar", null), se(this, "event", null), se(this, "popover", null), se(this, "customData", null), se(this, "ranges"), se(this, "hasRanges", !1), se(this, "order", 0), se(this, "pinPage", !1), se(this, "maxRepeatSpan", 0), se(this, "locale");
    const { dates: i } = Object.assign(
      this,
      { hashcode: "", order: 0, pinPage: !1 },
      t
    );
    this.key || (this.key = nc()), this.locale = r, n.normalizeGlyphs(this), this.ranges = r.ranges(i ?? []), this.hasRanges = !!tr(this.ranges), this.maxRepeatSpan = this.ranges.filter((s) => s.hasRepeat).map((s) => s.daySpan).reduce((s, a) => Math.max(s, a), 0);
  }
  intersectsRange({ start: t, end: n }) {
    if (t == null || n == null)
      return !1;
    const r = this.ranges.filter((a) => !a.hasRepeat);
    for (const a of r)
      if (a.intersectsDayRange(t.dayIndex, n.dayIndex))
        return !0;
    const i = this.ranges.filter((a) => a.hasRepeat);
    if (!i.length)
      return !1;
    let s = t;
    for (this.maxRepeatSpan > 1 && (s = this.locale.getDateParts(Yt(s.date, -this.maxRepeatSpan))); s.dayIndex <= n.dayIndex; ) {
      for (const a of i)
        if (a.startsOnDay(s))
          return !0;
      s = this.locale.getDateParts(Yt(s.date, 1));
    }
    return !1;
  }
}
const I_ = "__vc_base_context__", R_ = {
  color: {
    type: String,
    default: () => Rr("color")
  },
  isDark: {
    type: [Boolean, String, Object],
    default: () => Rr("isDark")
  },
  firstDayOfWeek: Number,
  masks: Object,
  locale: [String, Object],
  timezone: String,
  minDate: null,
  maxDate: null,
  disabledDates: null
};
function B_(e) {
  const t = T(() => e.color ?? ""), n = T(() => e.isDark ?? !1), { displayMode: r } = GC(n), i = T(() => new qR(t.value)), s = T(() => {
    if (e.locale instanceof pc)
      return e.locale;
    const u = or(e.locale) ? e.locale : {
      id: e.locale,
      firstDayOfWeek: e.firstDayOfWeek,
      masks: e.masks
    };
    return new pc(u, e.timezone);
  }), a = T(() => s.value.masks), o = T(() => {
    const u = e.disabledDates ?? [];
    return e.minDate != null && u.push({
      start: null,
      end: Yt(s.value.toDate(e.minDate), -1)
    }), e.maxDate != null && u.push({
      start: Yt(s.value.toDate(e.maxDate), 1),
      end: null
    }), s.value.ranges(u);
  }), l = T(() => new P_(
    {
      key: "disabled",
      dates: o.value,
      order: 100
    },
    i.value,
    s.value
  )), c = {
    color: t,
    isDark: n,
    displayMode: r,
    theme: i,
    locale: s,
    masks: a,
    disabledDates: o,
    disabledAttribute: l
  };
  return $i(I_, c), c;
}
function C5(e) {
  return ur(I_, B_(e));
}
const D5 = (e, t, {
  maxSwipeTime: n,
  minHorizontalSwipeDistance: r,
  maxVerticalSwipeDistance: i
}) => {
  if (!e || !e.addEventListener || !Ei(t))
    return null;
  let s = 0, a = 0, o = null, l = !1;
  function c(f) {
    const d = f.changedTouches[0];
    s = d.screenX, a = d.screenY, o = (/* @__PURE__ */ new Date()).getTime(), l = !0;
  }
  function u(f) {
    if (!l || !o)
      return;
    l = !1;
    const d = f.changedTouches[0], h = d.screenX - s, p = d.screenY - a;
    if ((/* @__PURE__ */ new Date()).getTime() - o < n && Math.abs(h) >= r && Math.abs(p) <= i) {
      const v = { toLeft: !1, toRight: !1 };
      h < 0 ? v.toLeft = !0 : v.toRight = !0, t(v);
    }
  }
  return Sr(e, "touchstart", c, { passive: !0 }), Sr(e, "touchend", u, { passive: !0 }), () => {
    Dr(e, "touchstart", c), Dr(e, "touchend", u);
  };
}, Sl = {}, S5 = (e, t = 10) => {
  Sl[e] = Date.now() + t;
}, T5 = (e, t) => {
  if (e in Sl) {
    const n = Sl[e];
    if (Date.now() < n)
      return;
    delete Sl[e];
  }
  t();
}, O5 = {
  ...R_,
  view: {
    type: String,
    default: "monthly",
    validator(e) {
      return ["daily", "weekly", "monthly"].includes(e);
    }
  },
  rows: {
    type: Number,
    default: 1
  },
  columns: {
    type: Number,
    default: 1
  },
  step: Number,
  titlePosition: {
    type: String,
    default: () => Rr("titlePosition")
  },
  navVisibility: {
    type: String,
    default: () => Rr("navVisibility")
  },
  showWeeknumbers: [Boolean, String],
  showIsoWeeknumbers: [Boolean, String],
  expanded: Boolean,
  borderless: Boolean,
  transparent: Boolean,
  initialPage: Object,
  initialPagePosition: { type: Number, default: 1 },
  minPage: Object,
  maxPage: Object,
  transition: String,
  attributes: Array,
  trimWeeks: Boolean,
  disablePageSwipe: Boolean
}, M5 = [
  "dayclick",
  "daymouseenter",
  "daymouseleave",
  "dayfocusin",
  "dayfocusout",
  "daykeydown",
  "weeknumberclick",
  "transition-start",
  "transition-end",
  "did-move",
  "update:view",
  "update:pages"
], N_ = "__vc_calendar_context__";
function F5(e, { emit: t, slots: n }) {
  const r = oe(null), i = oe(null), s = oe(null), a = oe((/* @__PURE__ */ new Date()).getDate()), o = oe(!1), l = oe(nc()), c = oe(nc()), u = oe(e.view), f = oe([]), d = oe("");
  let h = null, p = null;
  const {
    theme: g,
    color: v,
    displayMode: m,
    locale: x,
    masks: _,
    disabledAttribute: y,
    disabledDates: b
  } = C5(e), w = T(() => e.rows * e.columns), E = T(() => e.step || w.value), $ = T(() => p_(f.value) ?? null), C = T(() => ts(f.value) ?? null), A = T(
    () => e.minPage || (e.minDate ? O(e.minDate) : null)
  ), k = T(
    () => e.maxPage || (e.maxDate ? O(e.maxDate) : null)
  ), D = T(() => e.navVisibility), S = T(() => !!e.showWeeknumbers), L = T(() => !!e.showIsoWeeknumbers), P = T(() => u.value === "monthly"), H = T(() => u.value === "weekly"), M = T(() => u.value === "daily"), B = () => {
    o.value = !0, t("transition-start");
  }, W = () => {
    o.value = !1, t("transition-end"), h && (h.resolve(!0), h = null);
  }, R = (Z, Q, ue = u.value) => O_(Z, Q, ue, x.value), O = (Z) => T_(Z, u.value, x.value), N = (Z) => {
    !y.value || !re.value || (Z.isDisabled = re.value.cellExists(
      y.value.key,
      Z.dayIndex
    ));
  }, z = (Z) => {
    Z.isFocusable = Z.inMonth && Z.day === a.value;
  }, I = (Z, Q) => {
    for (const ue of Z)
      for (const F of ue.days)
        if (Q(F) === !1)
          return;
  }, te = T(
    () => f.value.reduce((Z, Q) => (Z.push(...Q.viewDays), Z), [])
  ), ee = T(() => {
    const Z = [];
    return (e.attributes || []).forEach((Q, ue) => {
      if (!Q || !Q.dates)
        return;
      const F = gh(Q, "key") ? Q.key : ue, K = Q.order || 0;
      Z.push(
        new P_(
          {
            ...Q,
            key: F,
            order: K
          },
          g.value,
          x.value
        )
      );
    }), y.value && Z.push(y.value), Z;
  }), _e = T(() => tr(ee.value)), re = T(() => {
    const Z = new $5();
    return ee.value.forEach((Q) => {
      Q.ranges.forEach((ue) => {
        Z.render(Q, ue, te.value);
      });
    }), Z;
  }), Ae = T(() => te.value.reduce((Z, Q) => (Z[Q.dayIndex] = { day: Q, cells: [] }, Z[Q.dayIndex].cells.push(...re.value.getCells(Q)), Z), {})), st = (Z, Q) => {
    const ue = e.showWeeknumbers || e.showIsoWeeknumbers;
    return ue == null ? "" : PD(ue) ? ue ? "left" : "" : ue.startsWith("right") ? Q > 1 ? "right" : ue : Z > 1 ? "left" : ue;
  }, ut = () => {
    var Z, Q;
    if (!_e.value)
      return null;
    const ue = ee.value.find((ae) => ae.pinPage) || ee.value[0];
    if (!ue || !ue.hasRanges)
      return null;
    const [F] = ue.ranges, K = ((Z = F.start) == null ? void 0 : Z.date) || ((Q = F.end) == null ? void 0 : Q.date);
    return K ? O(K) : null;
  }, yt = () => {
    if (In($.value))
      return $.value;
    const Z = ut();
    return In(Z) ? Z : O(/* @__PURE__ */ new Date());
  }, He = (Z, Q = {}) => {
    const { view: ue = u.value, position: F = 1, force: K } = Q, ae = F > 0 ? 1 - F : -(w.value + F);
    let $e = R(Z, ae, ue), at = R($e, w.value - 1, ue);
    return K || (Fd($e, A.value) ? $e = A.value : hc(at, k.value) && ($e = R(k.value, 1 - w.value)), at = R($e, w.value - 1)), { fromPage: $e, toPage: at };
  }, We = (Z, Q, ue = "") => {
    if (ue === "none" || ue === "fade")
      return ue;
    if ((Z == null ? void 0 : Z.view) !== (Q == null ? void 0 : Q.view))
      return "fade";
    const F = hc(Q, Z), K = Fd(Q, Z);
    return !F && !K ? "fade" : ue === "slide-v" ? K ? "slide-down" : "slide-up" : K ? "slide-right" : "slide-left";
  }, wt = (Z = {}) => new Promise((Q, ue) => {
    const { position: F = 1, force: K = !1, transition: ae } = Z, $e = In(Z.page) ? Z.page : yt(), { fromPage: at } = He($e, {
      position: F,
      force: K
    }), Jt = [];
    for (let Pt = 0; Pt < w.value; Pt++) {
      const qn = R(at, Pt), Gr = Pt + 1, zi = Math.ceil(Gr / e.columns), Wt = e.rows - zi + 1, Vi = Gr % e.columns || e.columns, br = e.columns - Vi + 1, Ot = st(Vi, br);
      Jt.push(
        x.value.getPage({
          ...qn,
          view: u.value,
          titlePosition: e.titlePosition,
          trimWeeks: e.trimWeeks,
          position: Gr,
          row: zi,
          rowFromEnd: Wt,
          column: Vi,
          columnFromEnd: br,
          showWeeknumbers: S.value,
          showIsoWeeknumbers: L.value,
          weeknumberPosition: Ot
        })
      );
    }
    d.value = We(
      f.value[0],
      Jt[0],
      ae
    ), f.value = Jt, d.value && d.value !== "none" ? h = {
      resolve: Q,
      reject: ue
    } : Q(!0);
  }), Ke = (Z) => {
    const Q = $.value ?? O(/* @__PURE__ */ new Date());
    return R(Q, Z);
  }, Ht = (Z, Q = {}) => {
    const ue = In(Z) ? Z : O(Z);
    return Object.assign(
      Q,
      He(ue, {
        ...Q,
        force: !0
      })
    ), b5(
      Q.fromPage,
      Q.toPage,
      u.value,
      x.value
    ).map((K) => M_(K, A.value, k.value)).every((K) => K);
  }, Tt = (Z, Q = {}) => Ht(Ke(Z), Q), ce = T(() => Tt(-E.value)), xt = T(() => Tt(E.value)), xe = async (Z, Q = {}) => !Q.force && !Ht(Z, Q) ? !1 : (Q.fromPage && !x5(Q.fromPage, $.value) && (i.value && i.value.hide({ hideDelay: 0 }), Q.view && (S5("view", 10), u.value = Q.view), await wt({
    ...Q,
    page: Q.fromPage,
    position: 1,
    force: !0
  }), t("did-move", f.value)), !0), he = (Z, Q = {}) => xe(Ke(Z), Q), ft = () => he(-E.value), dt = () => he(E.value), Ft = (Z) => {
    const Q = P.value ? ".in-month" : "", ue = `.id-${x.value.getDayId(Z)}${Q}`, F = `${ue}.vc-focusable, ${ue} .vc-focusable`, K = r.value;
    if (K) {
      const ae = K.querySelector(F);
      if (ae)
        return ae.focus(), !0;
    }
    return !1;
  }, $t = async (Z, Q = {}) => Ft(Z) ? !0 : (await xe(Z, Q), Ft(Z)), J = (Z, Q) => {
    a.value = Z.day, t("dayclick", Z, Q);
  }, ne = (Z, Q) => {
    t("daymouseenter", Z, Q);
  }, me = (Z, Q) => {
    t("daymouseleave", Z, Q);
  }, we = (Z, Q) => {
    a.value = Z.day, s.value = Z, Z.isFocused = !0, t("dayfocusin", Z, Q);
  }, ze = (Z, Q) => {
    s.value = null, Z.isFocused = !1, t("dayfocusout", Z, Q);
  }, ht = (Z, Q) => {
    t("daykeydown", Z, Q);
    const ue = Z.noonDate;
    let F = null;
    switch (Q.key) {
      case "ArrowLeft": {
        F = Yt(ue, -1);
        break;
      }
      case "ArrowRight": {
        F = Yt(ue, 1);
        break;
      }
      case "ArrowUp": {
        F = Yt(ue, -7);
        break;
      }
      case "ArrowDown": {
        F = Yt(ue, 7);
        break;
      }
      case "Home": {
        F = Yt(ue, -Z.weekdayPosition + 1);
        break;
      }
      case "End": {
        F = Yt(ue, Z.weekdayPositionFromEnd);
        break;
      }
      case "PageUp": {
        Q.altKey ? F = Gg(ue, -1) : F = fc(ue, -1);
        break;
      }
      case "PageDown": {
        Q.altKey ? F = Gg(ue, 1) : F = fc(ue, 1);
        break;
      }
    }
    F && (Q.preventDefault(), $t(F).catch());
  }, Yr = (Z) => {
    const Q = s.value;
    Q != null && ht(Q, Z);
  }, xr = (Z, Q) => {
    t("weeknumberclick", Z, Q);
  };
  wt({
    page: e.initialPage,
    position: e.initialPagePosition
  }), ct(() => {
    !e.disablePageSwipe && r.value && (p = D5(
      r.value,
      ({ toLeft: Z = !1, toRight: Q = !1 }) => {
        Z ? dt() : Q && ft();
      },
      Rr("touch")
    ));
  }), zt(() => {
    f.value = [], p && p();
  }), fe(
    () => x.value,
    () => {
      wt();
    }
  ), fe(
    () => w.value,
    () => wt()
  ), fe(
    () => e.view,
    () => u.value = e.view
  ), fe(
    () => u.value,
    () => {
      T5("view", () => {
        wt();
      }), t("update:view", u.value);
    }
  ), fe(
    () => a.value,
    () => {
      I(f.value, (Z) => z(Z));
    }
  ), Zc(() => {
    t("update:pages", f.value), I(f.value, (Z) => {
      N(Z), z(Z);
    });
  });
  const qr = {
    emit: t,
    slots: n,
    containerRef: r,
    navPopoverRef: i,
    focusedDay: s,
    inTransition: o,
    navPopoverId: l,
    dayPopoverId: c,
    view: u,
    pages: f,
    transitionName: d,
    theme: g,
    color: v,
    displayMode: m,
    locale: x,
    masks: _,
    attributes: ee,
    disabledAttribute: y,
    disabledDates: b,
    attributeContext: re,
    days: te,
    dayCells: Ae,
    count: w,
    step: E,
    firstPage: $,
    lastPage: C,
    canMovePrev: ce,
    canMoveNext: xt,
    minPage: A,
    maxPage: k,
    isMonthly: P,
    isWeekly: H,
    isDaily: M,
    navVisibility: D,
    showWeeknumbers: S,
    showIsoWeeknumbers: L,
    getDateAddress: O,
    canMove: Ht,
    canMoveBy: Tt,
    move: xe,
    moveBy: he,
    movePrev: ft,
    moveNext: dt,
    onTransitionBeforeEnter: B,
    onTransitionAfterEnter: W,
    tryFocusDate: Ft,
    focusDate: $t,
    onKeydown: Yr,
    onDayKeydown: ht,
    onDayClick: J,
    onDayMouseenter: ne,
    onDayMouseleave: me,
    onDayFocusin: we,
    onDayFocusout: ze,
    onWeeknumberClick: xr
  };
  return $i(N_, qr), qr;
}
function ki() {
  const e = ur(N_);
  if (e)
    return e;
  throw new Error(
    "Calendar context missing. Please verify this component is nested within a valid context provider."
  );
}
const P5 = {
  inheritAttrs: !1
}, ls = /* @__PURE__ */ be({
  ...P5,
  __name: "CalendarSlot",
  props: {
    name: null
  },
  setup(e) {
    const { slots: t } = ki();
    return (n, r) => X(t)[e.name] ? (j(), ke(hb(X(t)[e.name]), Xl(Gt({ key: 0 }, n.$attrs)), null, 16)) : Ee(n.$slots, "default", { key: 1 });
  }
});
function Pd(e) {
  document && document.dispatchEvent(
    new CustomEvent("show-popover", {
      detail: e
    })
  );
}
function gc(e) {
  document && document.dispatchEvent(
    new CustomEvent("hide-popover", {
      detail: e
    })
  );
}
function L_(e) {
  document && document.dispatchEvent(
    new CustomEvent("toggle-popover", {
      detail: e
    })
  );
}
function j_(e) {
  const { visibility: t } = e, n = t === "click", r = t === "hover", i = t === "hover-focus", s = t === "focus";
  e.autoHide = !n;
  let a = !1, o = !1;
  const l = (p) => {
    n && (L_({
      ...e,
      target: e.target || p.currentTarget
    }), p.stopPropagation());
  }, c = (p) => {
    a || (a = !0, (r || i) && Pd({
      ...e,
      target: e.target || p.currentTarget
    }));
  }, u = () => {
    a && (a = !1, (r || i && !o) && gc(e));
  }, f = (p) => {
    o || (o = !0, (s || i) && Pd({
      ...e,
      target: e.target || p.currentTarget
    }));
  }, d = (p) => {
    o && !kl(p.currentTarget, p.relatedTarget) && (o = !1, (s || i && !a) && gc(e));
  }, h = {};
  switch (e.visibility) {
    case "click":
      h.click = l;
      break;
    case "hover":
      h.mousemove = c, h.mouseleave = u;
      break;
    case "focus":
      h.focusin = f, h.focusout = d;
      break;
    case "hover-focus":
      h.mousemove = c, h.mouseleave = u, h.focusin = f, h.focusout = d;
      break;
  }
  return h;
}
const rv = (e) => {
  const t = tc(e);
  if (t == null)
    return;
  const n = t.popoverHandlers;
  !n || !n.length || (n.forEach((r) => r()), delete t.popoverHandlers);
}, iv = (e, t) => {
  const n = tc(e);
  if (n == null)
    return;
  const r = [], i = j_(t);
  Object.entries(i).forEach(([s, a]) => {
    r.push(Sr(n, s, a));
  }), n.popoverHandlers = r;
}, z_ = {
  mounted(e, t) {
    const { value: n } = t;
    n && iv(e, n);
  },
  updated(e, t) {
    const { oldValue: n, value: r } = t, i = n == null ? void 0 : n.visibility, s = r == null ? void 0 : r.visibility;
    i !== s && (i && (rv(e), s || gc(n)), s && iv(e, r));
  },
  unmounted(e) {
    rv(e);
  }
}, I5 = ["disabled"], R5 = {
  key: 1,
  type: "button",
  class: "vc-title"
}, B5 = ["disabled"], V_ = /* @__PURE__ */ be({
  __name: "CalendarHeader",
  props: {
    page: { type: Object, required: !0 },
    layout: String,
    isLg: Boolean,
    isXl: Boolean,
    is2xl: Boolean,
    hideTitle: Boolean,
    hideArrows: Boolean
  },
  setup(e) {
    const t = e, {
      navPopoverId: n,
      navVisibility: r,
      canMovePrev: i,
      movePrev: s,
      canMoveNext: a,
      moveNext: o
    } = ki(), l = T(() => {
      switch (t.page.titlePosition) {
        case "left":
          return "bottom-start";
        case "right":
          return "bottom-end";
        default:
          return "bottom";
      }
    }), c = T(() => {
      const { page: g } = t;
      return {
        id: n.value,
        visibility: r.value,
        placement: l.value,
        modifiers: [{ name: "flip", options: { fallbackPlacements: ["bottom"] } }],
        data: { page: g },
        isInteractive: !0
      };
    }), u = T(() => t.page.titlePosition.includes("left")), f = T(() => t.page.titlePosition.includes("right")), d = T(() => t.layout ? t.layout : u.value ? "tu-pn" : f.value ? "pn-tu" : "p-tu-n;"), h = T(() => ({
      prev: d.value.includes("p") && !t.hideArrows,
      title: d.value.includes("t") && !t.hideTitle,
      next: d.value.includes("n") && !t.hideArrows
    })), p = T(() => ({ gridTemplateColumns: d.value.split("").map((v) => {
      switch (v) {
        case "p":
          return "[prev] auto";
        case "n":
          return "[next] auto";
        case "t":
          return "[title] auto";
        case "-":
          return "1fr";
        default:
          return "";
      }
    }).join(" ") }));
    return (g, v) => (j(), G("div", {
      class: Be(["vc-header", { "is-lg": e.isLg, "is-xl": e.isXl, "is-2xl": e.is2xl }]),
      style: et(X(p))
    }, [
      X(h).prev ? (j(), G("button", {
        key: 0,
        type: "button",
        class: "vc-arrow vc-prev vc-focus",
        disabled: !X(i),
        onClick: v[0] || (v[0] = //@ts-ignore
        (...m) => X(s) && X(s)(...m)),
        onKeydown: v[1] || (v[1] = Gp(
          //@ts-ignore
          (...m) => X(s) && X(s)(...m),
          ["space", "enter"]
        ))
      }, [
        U(ls, {
          name: "header-prev-button",
          disabled: !X(i)
        }, {
          default: pe(() => [
            U(ms, {
              name: "ChevronLeft",
              size: "24"
            })
          ]),
          _: 1
        }, 8, ["disabled"])
      ], 40, I5)) : ve("", !0),
      X(h).title ? ds((j(), G("button", R5, [
        U(ls, {
          name: "header-title",
          title: e.page.title
        }, {
          default: pe(() => [
            de("span", null, Fe(e.page.title), 1)
          ]),
          _: 1
        }, 8, ["title"])
      ])), [
        [X(z_), X(c)]
      ]) : ve("", !0),
      X(h).next ? (j(), G("button", {
        key: 2,
        type: "button",
        class: "vc-arrow vc-next vc-focus",
        disabled: !X(a),
        onClick: v[2] || (v[2] = //@ts-ignore
        (...m) => X(o) && X(o)(...m)),
        onKeydown: v[3] || (v[3] = Gp(
          //@ts-ignore
          (...m) => X(o) && X(o)(...m),
          ["space", "enter"]
        ))
      }, [
        U(ls, {
          name: "header-next-button",
          disabled: !X(a)
        }, {
          default: pe(() => [
            U(ms, {
              name: "ChevronRight",
              size: "24"
            })
          ]),
          _: 1
        }, 8, ["disabled"])
      ], 40, B5)) : ve("", !0)
    ], 6));
  }
}), N5 = be({
  directives: { popover: z_ },
  components: { CalendarSlot: ls },
  props: {
    day: { type: Object, required: !0 }
  },
  setup(e) {
    const {
      locale: t,
      theme: n,
      attributeContext: r,
      dayPopoverId: i,
      slots: s,
      onDayClick: a,
      onDayMouseenter: o,
      onDayMouseleave: l,
      onDayFocusin: c,
      onDayFocusout: u,
      onDayKeydown: f
    } = ki(), d = T(() => e.day), h = T(() => r.value.getCells(d.value)), p = T(
      () => h.value.map((P) => P.data)
    ), g = T(() => ({
      ...d.value,
      attributes: p.value,
      attributeCells: h.value
    }));
    function v({ data: P }, { popovers: H }) {
      const { key: M, customData: B, popover: W } = P;
      if (!W)
        return;
      const R = Ng(
        {
          key: M,
          customData: B,
          attribute: P
        },
        { ...W },
        {
          visibility: W.label ? "hover" : "click",
          placement: "bottom",
          isInteractive: !W.label
        }
      );
      H.splice(0, 0, R);
    }
    const m = T(() => {
      const P = {
        ...n.value.prepareRender({}),
        popovers: []
      };
      return h.value.forEach((H) => {
        n.value.render(H, P), v(H, P);
      }), P;
    }), x = T(() => m.value.highlights), _ = T(() => !!tr(x.value)), y = T(() => m.value.content), b = T(() => m.value.dots), w = T(() => !!tr(b.value)), E = T(() => m.value.bars), $ = T(() => !!tr(E.value)), C = T(() => m.value.popovers), A = T(
      () => C.value.map((P) => P.attribute)
    ), k = T(() => [
      "vc-day",
      ...d.value.classes,
      { "vc-day-box-center-center": !s["day-content"] },
      { "is-not-in-month": !e.day.inMonth }
    ]), D = T(() => {
      let P;
      d.value.isFocusable ? P = "0" : P = "-1";
      const H = [
        "vc-day-content vc-focusable vc-focus vc-attr",
        { "vc-disabled": d.value.isDisabled },
        ai(ts(x.value), "contentClass"),
        ai(ts(y.value), "class") || ""
      ], M = {
        ...ai(ts(x.value), "contentStyle"),
        ...ai(ts(y.value), "style")
      };
      return {
        class: H,
        style: M,
        tabindex: P,
        "aria-label": d.value.ariaLabel,
        "aria-disabled": !!d.value.isDisabled,
        role: "button"
      };
    }), S = T(() => ({
      click(P) {
        a(g.value, P);
      },
      mouseenter(P) {
        o(g.value, P);
      },
      mouseleave(P) {
        l(g.value, P);
      },
      focusin(P) {
        c(g.value, P);
      },
      focusout(P) {
        u(g.value, P);
      },
      keydown(P) {
        f(g.value, P);
      }
    })), L = T(() => tr(C.value) ? Ng(
      {
        id: i.value,
        data: { day: d, attributes: A.value }
      },
      ...C.value
    ) : null);
    return {
      attributes: p,
      attributeCells: h,
      bars: E,
      dayClasses: k,
      dayContentProps: D,
      dayContentEvents: S,
      dayPopover: L,
      glyphs: m,
      dots: b,
      hasDots: w,
      hasBars: $,
      highlights: x,
      hasHighlights: _,
      locale: t,
      popovers: C
    };
  }
}), L5 = {
  key: 0,
  class: "vc-highlights vc-day-layer"
}, j5 = {
  key: 1,
  class: "vc-day-layer vc-day-box-center-bottom"
}, z5 = { class: "vc-dots" }, V5 = {
  key: 2,
  class: "vc-day-layer vc-day-box-center-bottom"
}, H5 = { class: "vc-bars" };
function W5(e, t, n, r, i, s) {
  const a = ge("CalendarSlot"), o = pb("popover");
  return j(), G("div", {
    class: Be(e.dayClasses)
  }, [
    e.hasHighlights ? (j(), G("div", L5, [
      (j(!0), G(Ie, null, _t(e.highlights, ({ key: l, wrapperClass: c, class: u, style: f }) => (j(), G("div", {
        key: l,
        class: Be(c)
      }, [
        de("div", {
          class: Be(u),
          style: et(f)
        }, null, 6)
      ], 2))), 128))
    ])) : ve("", !0),
    U(a, {
      name: "day-content",
      day: e.day,
      attributes: e.attributes,
      "attribute-cells": e.attributeCells,
      dayProps: e.dayContentProps,
      dayEvents: e.dayContentEvents,
      locale: e.locale
    }, {
      default: pe(() => [
        ds((j(), G("div", Gt(e.dayContentProps, qA(e.dayContentEvents, !0)), [
          fn(Fe(e.day.label), 1)
        ], 16)), [
          [o, e.dayPopover]
        ])
      ]),
      _: 1
    }, 8, ["day", "attributes", "attribute-cells", "dayProps", "dayEvents", "locale"]),
    e.hasDots ? (j(), G("div", j5, [
      de("div", z5, [
        (j(!0), G(Ie, null, _t(e.dots, ({ key: l, class: c, style: u }) => (j(), G("span", {
          key: l,
          class: Be(c),
          style: et(u)
        }, null, 6))), 128))
      ])
    ])) : ve("", !0),
    e.hasBars ? (j(), G("div", V5, [
      de("div", H5, [
        (j(!0), G(Ie, null, _t(e.bars, ({ key: l, class: c, style: u }) => (j(), G("span", {
          key: l,
          class: Be(c),
          style: et(u)
        }, null, 6))), 128))
      ])
    ])) : ve("", !0)
  ], 2);
}
const U5 = /* @__PURE__ */ fr(N5, [["render", W5]]), Y5 = {
  name: "CalendarPane",
  inheritAttrs: !1,
  components: { CalendarHeader: V_, CalendarDay: U5 },
  props: {
    page: { type: Object, required: !0 }
  },
  setup() {
    const { onWeeknumberClick: e } = ki();
    return {
      onWeeknumberClick: e
    };
  }
}, q5 = { class: "vc-weekdays" }, G5 = ["onClick"];
function X5(e, t, n, r, i, s) {
  const a = ge("CalendarHeader"), o = ge("CalendarDay");
  return j(), G("div", {
    class: Be([
      "vc-pane",
      `row-${n.page.row}`,
      `row-from-end-${n.page.rowFromEnd}`,
      `column-${n.page.column}`,
      `column-from-end-${n.page.columnFromEnd}`
    ]),
    ref: "pane"
  }, [
    U(a, {
      page: n.page,
      "is-lg": "",
      "hide-arrows": ""
    }, null, 8, ["page"]),
    de("div", {
      class: Be(["vc-weeks", {
        [`vc-show-weeknumbers-${n.page.weeknumberPosition}`]: n.page.weeknumberPosition
      }])
    }, [
      de("div", q5, [
        (j(!0), G(Ie, null, _t(n.page.weekdays, ({ weekday: l, label: c }, u) => (j(), G("div", {
          key: u,
          class: Be(`vc-weekday vc-weekday-${l}`)
        }, Fe(c), 3))), 128))
      ]),
      (j(!0), G(Ie, null, _t(n.page.viewWeeks, (l) => (j(), G("div", {
        key: `weeknumber-${l.weeknumber}`,
        class: "vc-week"
      }, [
        n.page.weeknumberPosition ? (j(), G("div", {
          key: 0,
          class: Be(["vc-weeknumber", `is-${n.page.weeknumberPosition}`])
        }, [
          de("span", {
            class: Be(["vc-weeknumber-content"]),
            onClick: (c) => r.onWeeknumberClick(l, c)
          }, Fe(l.weeknumberDisplay), 9, G5)
        ], 2)) : ve("", !0),
        (j(!0), G(Ie, null, _t(l.days, (c) => (j(), ke(o, {
          key: c.id,
          day: c
        }, null, 8, ["day"]))), 128))
      ]))), 128))
    ], 2)
  ], 2);
}
const Z5 = /* @__PURE__ */ fr(Y5, [["render", X5]]), K5 = be({
  name: "Popover",
  inheritAttrs: !1,
  emits: ["before-show", "after-show", "before-hide", "after-hide"],
  props: {
    id: { type: String, required: !0 },
    showDelay: { type: Number, default: 0 },
    hideDelay: { type: Number, default: 110 },
    boundarySelector: { type: String }
  },
  setup(e, { emit: t }) {
    let n;
    const r = oe();
    let i = null, s = null;
    const a = Oe({
      isVisible: !1,
      target: null,
      data: null,
      transition: "slide-fade",
      placement: "bottom",
      direction: "",
      positionFixed: !1,
      modifiers: [],
      isInteractive: !0,
      visibility: "click",
      isHovered: !1,
      isFocused: !1,
      autoHide: !1,
      force: !1
    });
    function o(R) {
      R && (a.direction = R.split("-")[0]);
    }
    function l({ placement: R, options: O }) {
      o(R || (O == null ? void 0 : O.placement));
    }
    const c = T(() => ({
      placement: a.placement,
      strategy: a.positionFixed ? "fixed" : "absolute",
      boundary: "",
      modifiers: [
        {
          name: "onUpdate",
          enabled: !0,
          phase: "afterWrite",
          fn: l
        },
        ...a.modifiers || []
      ],
      onFirstUpdate: l
    })), u = T(() => {
      const R = a.direction === "left" || a.direction === "right";
      let O = "";
      if (a.placement) {
        const N = a.placement.split("-");
        N.length > 1 && (O = N[1]);
      }
      return ["start", "top", "left"].includes(O) ? R ? "top" : "left" : ["end", "bottom", "right"].includes(O) ? R ? "bottom" : "right" : R ? "middle" : "center";
    });
    function f() {
      s && (s.destroy(), s = null);
    }
    function d() {
      un(() => {
        const R = tc(a.target);
        !R || !r.value || (s && s.state.elements.reference !== R && f(), s ? s.update() : s = xC(
          R,
          r.value,
          c.value
        ));
      });
    }
    function h(R) {
      Object.assign(a, g_(R, "force"));
    }
    function p(R, O) {
      clearTimeout(n), R > 0 ? n = setTimeout(O, R) : O();
    }
    function g(R) {
      return !R || !s ? !1 : tc(R) === s.state.elements.reference;
    }
    async function v(R = {}) {
      a.force || (R.force && (a.force = !0), p(R.showDelay ?? e.showDelay, () => {
        a.isVisible && (a.force = !1, t("after-show")), h({
          ...R,
          isVisible: !0
        }), d();
      }));
    }
    function m(R = {}) {
      s && (R.target && !g(R.target) || a.force || (R.force && (a.force = !0), p(R.hideDelay ?? e.hideDelay, () => {
        a.isVisible || (a.force = !1), a.isVisible = !1;
      })));
    }
    function x(R = {}) {
      R.target != null && (a.isVisible && g(R.target) ? m(R) : v(R));
    }
    function _(R) {
      if (!s)
        return;
      const O = s.state.elements.reference;
      if (!r.value || !O)
        return;
      const N = R.target;
      kl(r.value, N) || kl(O, N) || m({ force: !0 });
    }
    function y(R) {
      (R.key === "Esc" || R.key === "Escape") && m();
    }
    function b({ detail: R }) {
      !R.id || R.id !== e.id || v(R);
    }
    function w({ detail: R }) {
      !R.id || R.id !== e.id || m(R);
    }
    function E({ detail: R }) {
      !R.id || R.id !== e.id || x(R);
    }
    function $() {
      Sr(document, "keydown", y), Sr(document, "click", _), Sr(document, "show-popover", b), Sr(document, "hide-popover", w), Sr(document, "toggle-popover", E);
    }
    function C() {
      Dr(document, "keydown", y), Dr(document, "click", _), Dr(document, "show-popover", b), Dr(document, "hide-popover", w), Dr(document, "toggle-popover", E);
    }
    function A(R) {
      t("before-show", R);
    }
    function k(R) {
      a.force = !1, t("after-show", R);
    }
    function D(R) {
      t("before-hide", R);
    }
    function S(R) {
      a.force = !1, f(), t("after-hide", R);
    }
    function L(R) {
      R.stopPropagation();
    }
    function P() {
      a.isHovered = !0, a.isInteractive && ["hover", "hover-focus"].includes(a.visibility) && v();
    }
    function H() {
      if (a.isHovered = !1, !s)
        return;
      const R = s.state.elements.reference;
      a.autoHide && !a.isFocused && (!R || R !== document.activeElement) && ["hover", "hover-focus"].includes(a.visibility) && m();
    }
    function M() {
      a.isFocused = !0, a.isInteractive && ["focus", "hover-focus"].includes(a.visibility) && v();
    }
    function B(R) {
      ["focus", "hover-focus"].includes(a.visibility) && (!R.relatedTarget || !kl(r.value, R.relatedTarget)) && (a.isFocused = !1, !a.isHovered && a.autoHide && m());
    }
    function W() {
      i != null && (i.disconnect(), i = null);
    }
    return fe(
      () => r.value,
      (R) => {
        W(), R && (i = new ResizeObserver(() => {
          s && s.update();
        }), i.observe(R));
      }
    ), fe(() => a.placement, o, {
      immediate: !0
    }), ct(() => {
      $();
    }), zt(() => {
      f(), W(), C();
    }), {
      ...db(a),
      popoverRef: r,
      alignment: u,
      hide: m,
      setupPopper: d,
      beforeEnter: A,
      afterEnter: k,
      beforeLeave: D,
      afterLeave: S,
      onClick: L,
      onMouseOver: P,
      onMouseLeave: H,
      onFocusIn: M,
      onFocusOut: B
    };
  }
});
function J5(e, t, n, r, i, s) {
  return j(), G("div", {
    class: Be(["vc-popover-content-wrapper", { "is-interactive": e.isInteractive }]),
    ref: "popoverRef",
    onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
    onMouseover: t[1] || (t[1] = (...a) => e.onMouseOver && e.onMouseOver(...a)),
    onMouseleave: t[2] || (t[2] = (...a) => e.onMouseLeave && e.onMouseLeave(...a)),
    onFocusin: t[3] || (t[3] = (...a) => e.onFocusIn && e.onFocusIn(...a)),
    onFocusout: t[4] || (t[4] = (...a) => e.onFocusOut && e.onFocusOut(...a))
  }, [
    U(Fs, {
      name: `vc-${e.transition}`,
      appear: "",
      onBeforeEnter: e.beforeEnter,
      onAfterEnter: e.afterEnter,
      onBeforeLeave: e.beforeLeave,
      onAfterLeave: e.afterLeave
    }, {
      default: pe(() => [
        e.isVisible ? (j(), G("div", Gt({
          key: 0,
          tabindex: "-1",
          class: `vc-popover-content direction-${e.direction}`
        }, e.$attrs), [
          Ee(e.$slots, "default", {
            direction: e.direction,
            alignment: e.alignment,
            data: e.data,
            hide: e.hide
          }, () => [
            fn(Fe(e.data), 1)
          ]),
          de("span", {
            class: Be([
              "vc-popover-caret",
              `direction-${e.direction}`,
              `align-${e.alignment}`
            ])
          }, null, 2)
        ], 16)) : ve("", !0)
      ]),
      _: 3
    }, 8, ["name", "onBeforeEnter", "onAfterEnter", "onBeforeLeave", "onAfterLeave"])
  ], 34);
}
const bh = /* @__PURE__ */ fr(K5, [["render", J5]]), Q5 = {
  value: { type: Object, required: !0 }
}, e6 = ["input"], t6 = "__vc_calendar_nav_context__";
function n6(e, { emit: t }) {
  const n = oe(!0), r = oe(0), i = oe(0), s = 12, a = oe(null), { locale: o, masks: l, canMove: c, getDateAddress: u } = ki();
  function f() {
    setTimeout(() => {
      if (a.value == null)
        return;
      const I = a.value.querySelector(
        ".vc-nav-item:not(:disabled)"
      );
      I && I.focus();
    }, 10);
  }
  function d(I, te) {
    t("input", { month: I, year: te }, { position: A.value });
  }
  function h(I) {
    r.value = I, n.value = !0, f();
  }
  function p(I) {
    const { year: te } = u(/* @__PURE__ */ new Date()), ee = I * s, _e = ee + s, re = [];
    for (let Ae = ee; Ae < _e; Ae += 1) {
      let st = !1;
      for (let ut = 1; ut < 12 && (st = c({ month: ut, year: Ae }, { position: A.value }), !st); ut++)
        ;
      re.push({
        year: Ae,
        id: Ae.toString(),
        label: Ae.toString(),
        ariaLabel: Ae.toString(),
        isActive: Ae === C.value,
        isCurrent: Ae === te,
        isDisabled: !st,
        click: () => h(Ae)
      });
    }
    return re;
  }
  function g(I) {
    const { month: te, year: ee } = u(/* @__PURE__ */ new Date());
    return S_().map((_e, re) => {
      const Ae = re + 1;
      return {
        month: Ae,
        year: I,
        id: `${I}.${Le(Ae, 2)}`,
        label: o.value.formatDate(_e, l.value.navMonths),
        ariaLabel: o.value.formatDate(_e, "MMMM YYYY"),
        isActive: Ae === $.value && I === C.value,
        isCurrent: Ae === te && I === ee,
        isDisabled: !c(
          { month: Ae, year: I },
          { position: A.value }
        ),
        click: () => d(Ae, I)
      };
    });
  }
  function v(I) {
    return Math.floor(I / s);
  }
  function m() {
    n.value = !n.value;
  }
  function x() {
    B.value && (n.value && y(), w());
  }
  function _() {
    O.value && (n.value && b(), E());
  }
  function y() {
    r.value--;
  }
  function b() {
    r.value++;
  }
  function w() {
    i.value--;
  }
  function E() {
    i.value++;
  }
  const $ = T(() => {
    var I;
    return ((I = e.value) == null ? void 0 : I.month) || 0;
  }), C = T(() => {
    var I;
    return ((I = e.value) == null ? void 0 : I.year) || 0;
  }), A = T(() => {
    var I;
    return ((I = e.value) == null ? void 0 : I.position) || 1;
  }), k = T(() => g(r.value)), D = T(() => p(i.value)), S = T(() => p_(D.value.map((I) => I.year))), L = T(() => ts(D.value.map((I) => I.year))), P = T(() => n.value ? r.value : `${S.value} - ${L.value}`), H = T(
    () => g(r.value - 1).some((I) => !I.isDisabled)
  ), M = T(
    () => p(i.value - 1).some((I) => !I.isDisabled)
  ), B = T(
    () => n.value ? H.value : M.value
  ), W = T(
    () => g(r.value + 1).some((I) => !I.isDisabled)
  ), R = T(
    () => p(i.value + 1).some((I) => !I.isDisabled)
  ), O = T(
    () => n.value ? W.value : R.value
  ), N = T(
    () => n.value ? k.value : D.value
  );
  fe(
    () => C.value,
    () => {
      r.value = C.value;
    }
  ), fe(
    () => r.value,
    (I) => {
      i.value = v(I);
    }
  ), r.value = C.value, ct(() => f());
  const z = {
    navContainer: a,
    title: P,
    monthMode: n,
    currentMonth: $,
    currentYear: C,
    activeItems: N,
    prevItemsEnabled: B,
    nextItemsEnabled: O,
    toggleMode: m,
    movePrev: x,
    moveNext: _,
    movePrevYear: y,
    moveNextYear: b,
    movePrevYearGroup: w,
    moveNextYearGroup: E
  };
  return $i(t6, z), z;
}
const r6 = { class: "vc-nav-header" }, i6 = ["disabled"], s6 = ["disabled"], a6 = { class: "vc-nav-items" }, o6 = ["data-id", "aria-label", "disabled", "onClick", "onKeydown"], l6 = /* @__PURE__ */ be({
  __name: "CalendarNav",
  props: Q5,
  emits: e6,
  setup(e, { emit: t }) {
    const n = e, {
      navContainer: r,
      title: i,
      prevItemsEnabled: s,
      nextItemsEnabled: a,
      activeItems: o,
      toggleMode: l,
      movePrev: c,
      moveNext: u
    } = n6(n, { emit: t });
    return (f, d) => (j(), G("div", {
      class: "vc-nav-container",
      ref_key: "navContainer",
      ref: r
    }, [
      de("div", r6, [
        de("button", {
          type: "button",
          class: "vc-nav-arrow is-left vc-focus",
          disabled: !X(s),
          onClick: d[0] || (d[0] = //@ts-ignore
          (...h) => X(c) && X(c)(...h)),
          onKeydown: d[1] || (d[1] = (h) => X(Ho)(h, X(c)))
        }, [
          U(ls, {
            name: "nav-prev-button",
            move: X(c),
            disabled: !X(s)
          }, {
            default: pe(() => [
              U(ms, {
                name: "ChevronLeft",
                width: "22px",
                height: "24px"
              })
            ]),
            _: 1
          }, 8, ["move", "disabled"])
        ], 40, i6),
        de("button", {
          type: "button",
          class: "vc-nav-title vc-focus",
          onClick: d[2] || (d[2] = //@ts-ignore
          (...h) => X(l) && X(l)(...h)),
          onKeydown: d[3] || (d[3] = (h) => X(Ho)(h, X(l)))
        }, Fe(X(i)), 33),
        de("button", {
          type: "button",
          class: "vc-nav-arrow is-right vc-focus",
          disabled: !X(a),
          onClick: d[4] || (d[4] = //@ts-ignore
          (...h) => X(u) && X(u)(...h)),
          onKeydown: d[5] || (d[5] = (h) => X(Ho)(h, X(u)))
        }, [
          U(ls, {
            name: "nav-next-button",
            move: X(u),
            disabled: !X(a)
          }, {
            default: pe(() => [
              U(ms, {
                name: "ChevronRight",
                width: "22px",
                height: "24px"
              })
            ]),
            _: 1
          }, 8, ["move", "disabled"])
        ], 40, s6)
      ]),
      de("div", a6, [
        (j(!0), G(Ie, null, _t(X(o), (h) => (j(), G("button", {
          key: h.label,
          type: "button",
          "data-id": h.id,
          "aria-label": h.ariaLabel,
          class: Be(["vc-nav-item vc-focus", [
            h.isActive ? "is-active" : h.isCurrent ? "is-current" : ""
          ]]),
          disabled: h.isDisabled,
          onClick: h.click,
          onKeydown: (p) => X(Ho)(p, h.click)
        }, Fe(h.label), 43, o6))), 128))
      ])
    ], 512));
  }
}), c6 = {
  __name: "CalendarNavPopover",
  setup(e) {
    const { navPopoverId: t, color: n, displayMode: r, navPopoverRef: i, move: s } = ki();
    return (a, o) => (j(), ke(bh, {
      id: X(t),
      class: Be(["vc-nav-popover-container", `vc-${X(n)}`, `vc-${X(r)}`]),
      ref_key: "navPopoverRef",
      ref: i
    }, {
      default: pe(({ data: l }) => [
        U(l6, {
          value: l.page,
          onInput: X(s)
        }, null, 8, ["value", "onInput"])
      ]),
      _: 1
    }, 8, ["id", "class"]));
  }
}, u6 = be({
  name: "PopoverRow",
  props: {
    attribute: { type: Object, required: !0 }
  },
  setup(e) {
    return {
      indicator: T(() => {
        const { content: n, highlight: r, dot: i, bar: s, popover: a } = e.attribute;
        return a && a.hideIndicator ? null : n ? {
          class: `vc-bar vc-day-popover-row-bar vc-attr vc-${n.base.color}`
        } : r ? {
          class: `vc-highlight-bg-solid vc-day-popover-row-highlight vc-attr vc-${r.base.color}`
        } : i ? {
          class: `vc-dot vc-attr vc-${i.base.color}`
        } : s ? {
          class: `vc-bar vc-day-popover-row-bar vc-attr vc-${s.base.color}`
        } : null;
      })
    };
  }
}), f6 = { class: "vc-day-popover-row" }, d6 = {
  key: 0,
  class: "vc-day-popover-row-indicator"
}, h6 = { class: "vc-day-popover-row-label" };
function p6(e, t, n, r, i, s) {
  return j(), G("div", f6, [
    e.indicator ? (j(), G("div", d6, [
      de("span", {
        class: Be(e.indicator.class)
      }, null, 2)
    ])) : ve("", !0),
    de("div", h6, [
      Ee(e.$slots, "default", {}, () => [
        fn(Fe(e.attribute.popover ? e.attribute.popover.label : "No content provided"), 1)
      ])
    ])
  ]);
}
const g6 = /* @__PURE__ */ fr(u6, [["render", p6]]), v6 = { class: "vc-day-popover-container" }, m6 = {
  key: 0,
  class: "vc-day-popover-header"
}, y6 = /* @__PURE__ */ be({
  __name: "CalendarDayPopover",
  setup(e) {
    const { dayPopoverId: t, displayMode: n, color: r, masks: i, locale: s } = ki();
    function a(l, c) {
      return s.value.formatDate(l, c);
    }
    function o(l) {
      return s.value.formatDate(l.date, i.value.dayPopover);
    }
    return (l, c) => (j(), ke(bh, {
      id: X(t),
      class: Be([`vc-${X(r)}`, `vc-${X(n)}`])
    }, {
      default: pe(({ data: { day: u, attributes: f }, hide: d }) => [
        Ee(l.$slots, "default", {
          day: u,
          dayTitle: o(u),
          attributes: f,
          format: a,
          masks: X(i),
          hide: d
        }, () => [
          de("div", v6, [
            X(i).dayPopover ? (j(), G("div", m6, Fe(o(u)), 1)) : ve("", !0),
            (j(!0), G(Ie, null, _t(f, (h) => (j(), ke(g6, {
              key: h.key,
              attribute: h
            }, null, 8, ["attribute"]))), 128))
          ])
        ])
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), x6 = be({
  name: "Calendar",
  components: {
    CalendarHeader: V_,
    CalendarPane: Z5,
    CalendarNavPopover: c6,
    CalendarDayPopover: y6
  },
  emits: M5,
  props: O5,
  setup(e, { emit: t, slots: n }) {
    return F5(e, { emit: t, slots: n });
  }
}), b6 = { class: "vc-pane-header-wrapper" };
function _6(e, t, n, r, i, s) {
  const a = ge("CalendarHeader"), o = ge("CalendarPane"), l = ge("CalendarDayPopover"), c = ge("CalendarNavPopover");
  return j(), G(Ie, null, [
    de("div", Gt({ "data-helptext": "Press the arrow keys to navigate by day, Home and End to navigate to week ends, PageUp and PageDown to navigate by month, Alt+PageUp and Alt+PageDown to navigate by year" }, e.$attrs, {
      class: [
        "vc-container",
        `vc-${e.view}`,
        `vc-${e.color}`,
        `vc-${e.displayMode}`,
        {
          "vc-expanded": e.expanded,
          "vc-bordered": !e.borderless,
          "vc-transparent": e.transparent
        }
      ],
      onMouseup: t[0] || (t[0] = U0(() => {
      }, ["prevent"])),
      ref: "containerRef"
    }), [
      de("div", {
        class: Be(["vc-pane-container", { "in-transition": e.inTransition }])
      }, [
        de("div", b6, [
          e.firstPage ? (j(), ke(a, {
            key: 0,
            page: e.firstPage,
            "is-lg": "",
            "hide-title": ""
          }, null, 8, ["page"])) : ve("", !0)
        ]),
        U(Fs, {
          name: `vc-${e.transitionName}`,
          onBeforeEnter: e.onTransitionBeforeEnter,
          onAfterEnter: e.onTransitionAfterEnter
        }, {
          default: pe(() => [
            (j(), G("div", {
              key: e.pages[0].id,
              class: "vc-pane-layout",
              style: et({
                gridTemplateColumns: `repeat(${e.columns}, 1fr)`
              })
            }, [
              (j(!0), G(Ie, null, _t(e.pages, (u) => (j(), ke(o, {
                key: u.id,
                page: u
              }, null, 8, ["page"]))), 128))
            ], 4))
          ]),
          _: 1
        }, 8, ["name", "onBeforeEnter", "onAfterEnter"]),
        Ee(e.$slots, "footer")
      ], 2)
    ], 16),
    U(l, null, {
      default: pe((u) => [
        Ee(e.$slots, "day-popover", Xl(YA(u)))
      ]),
      _: 3
    }),
    U(c)
  ], 64);
}
const w6 = /* @__PURE__ */ fr(x6, [["render", _6]]), $6 = { class: "vc-base-select" }, E6 = ["value"], A6 = ["value", "disabled"], k6 = {
  inheritAttrs: !1
}, na = /* @__PURE__ */ Object.assign(k6, {
  __name: "BaseSelect",
  props: {
    options: Array,
    modelValue: null,
    alignRight: Boolean,
    alignLeft: Boolean,
    showIcon: Boolean,
    small: Boolean
  },
  emits: ["update:modelValue"],
  setup(e) {
    return (t, n) => (j(), G("div", $6, [
      e.showIcon ? (j(), ke(ms, {
        key: 0,
        name: "ChevronDown",
        size: e.small ? "16" : "18"
      }, null, 8, ["size"])) : ve("", !0),
      de("select", Gt(t.$attrs, {
        value: e.modelValue,
        class: ["vc-focus", {
          "vc-has-icon": e.showIcon,
          "vc-align-right": e.alignRight,
          "vc-align-left": e.alignLeft,
          "vc-small": e.small
        }],
        onChange: n[0] || (n[0] = (r) => t.$emit("update:modelValue", r.target.value))
      }), [
        (j(!0), G(Ie, null, _t(e.options, (r) => (j(), G("option", {
          key: r.value,
          value: r.value,
          disabled: r.disabled
        }, Fe(r.label), 9, A6))), 128))
      ], 16, E6)
    ]));
  }
}), H_ = "__vc_date_picker_context__", C6 = {
  ...R_,
  mode: { type: String, default: "date" },
  modelValue: {
    type: [Number, String, Date, Object]
  },
  modelModifiers: {
    type: Object,
    default: () => ({})
  },
  rules: [String, Object],
  is24hr: Boolean,
  hideTimeHeader: Boolean,
  timeAccuracy: { type: Number, default: 2 },
  isRequired: Boolean,
  isRange: Boolean,
  updateOnInput: {
    type: Boolean,
    default: () => Rr("datePicker.updateOnInput")
  },
  inputDebounce: {
    type: Number,
    default: () => Rr("datePicker.inputDebounce")
  },
  popover: {
    type: [Boolean, Object],
    default: !0
  },
  dragAttribute: Object,
  selectAttribute: Object,
  attributes: [Object, Array]
}, D6 = [
  "update:modelValue",
  "drag",
  "dayclick",
  "daykeydown",
  "popover-will-show",
  "popover-did-show",
  "popover-will-hide",
  "popover-did-hide"
];
function S6(e, t) {
  const n = B_(e), { locale: r, masks: i, disabledAttribute: s } = n, { emit: a } = t, o = oe(!1), l = oe(nc()), c = oe(null), u = oe(null), f = oe(["", ""]), d = oe(null), h = oe(null);
  let p, g, v = !0;
  const m = T(() => e.isRange || e.modelModifiers.range === !0), x = T(
    () => m.value && c.value != null ? c.value.start : null
  ), _ = T(
    () => m.value && c.value != null ? c.value.end : null
  ), y = T(() => e.mode.toLowerCase() === "date"), b = T(
    () => e.mode.toLowerCase() === "datetime"
  ), w = T(() => e.mode.toLowerCase() === "time"), E = T(() => !!u.value), $ = T(() => {
    let F = "date";
    e.modelModifiers.number && (F = "number"), e.modelModifiers.string && (F = "string");
    const K = i.value.modelValue || "iso";
    return z({ type: F, mask: K });
  }), C = T(
    () => ce(u.value ?? c.value)
  ), A = T(() => w.value ? e.is24hr ? i.value.inputTime24hr : i.value.inputTime : b.value ? e.is24hr ? i.value.inputDateTime24hr : i.value.inputDateTime : i.value.input), k = T(() => /[Hh]/g.test(A.value)), D = T(
    () => /[dD]{1,2}|Do|W{1,4}|M{1,4}|YY(?:YY)?/g.test(A.value)
  ), S = T(() => {
    if (k.value && D.value)
      return "dateTime";
    if (D.value)
      return "date";
    if (k.value)
      return "time";
  }), L = T(() => {
    var F;
    const K = ((F = d.value) == null ? void 0 : F.$el.previousElementSibling) ?? void 0;
    return qa({}, e.popover, Rr("datePicker.popover"), {
      target: K
    });
  }), P = T(
    () => j_({
      ...L.value,
      id: l.value
    })
  ), H = T(() => m.value ? {
    start: f.value[0],
    end: f.value[1]
  } : f.value[0]), M = T(() => {
    const F = ["start", "end"].map((K) => ({
      input: Ke(K),
      change: Ht(K),
      keyup: Tt,
      ...e.popover && P.value
    }));
    return m.value ? {
      start: F[0],
      end: F[1]
    } : F[0];
  }), B = T(() => {
    if (!ee(c.value))
      return null;
    const F = {
      key: "select-drag",
      ...e.selectAttribute,
      dates: c.value,
      pinPage: !0
    }, { dot: K, bar: ae, highlight: $e, content: at } = F;
    return !K && !ae && !$e && !at && (F.highlight = !0), F;
  }), W = T(() => {
    if (!m.value || !ee(u.value))
      return null;
    const F = {
      key: "select-drag",
      ...e.dragAttribute,
      dates: u.value
    }, { dot: K, bar: ae, highlight: $e, content: at } = F;
    return !K && !ae && !$e && !at && (F.highlight = {
      startEnd: {
        fillMode: "outline"
      }
    }), F;
  }), R = T(() => {
    const F = pn(e.attributes) ? [...e.attributes] : [];
    return W.value ? F.unshift(W.value) : B.value && F.unshift(B.value), F;
  }), O = T(() => z(
    e.rules === "auto" ? N() : e.rules ?? {}
  ));
  function N() {
    const F = {
      ms: [0, 999],
      sec: [0, 59],
      min: [0, 59],
      hr: [0, 23]
    }, K = y.value ? 0 : e.timeAccuracy;
    return [0, 1].map((ae) => {
      switch (K) {
        case 0:
          return {
            hours: F.hr[ae],
            minutes: F.min[ae],
            seconds: F.sec[ae],
            milliseconds: F.ms[ae]
          };
        case 1:
          return {
            minutes: F.min[ae],
            seconds: F.sec[ae],
            milliseconds: F.ms[ae]
          };
        case 3:
          return { milliseconds: F.ms[ae] };
        case 4:
          return {};
        default:
          return { seconds: F.sec[ae], milliseconds: F.ms[ae] };
      }
    });
  }
  function z(F) {
    return pn(F) ? F.length === 1 ? [F[0], F[0]] : F : [F, F];
  }
  function I(F) {
    return z(F).map(
      (K, ae) => ({
        ...K,
        rules: O.value[ae]
      })
    );
  }
  function te(F) {
    return kn(F) ? !isNaN(F) : as(F) ? !isNaN(F.getTime()) : Pn(F) ? F !== "" : F != null;
  }
  function ee(F) {
    return m.value ? or(F) && te(F.start) && te(F.end) : te(F);
  }
  function _e(F, K) {
    const ae = as(F), $e = as(K);
    return !ae && !$e ? !0 : ae !== $e ? !1 : F.getTime() === K.getTime();
  }
  function re(F, K) {
    if (m.value) {
      const ae = ee(F), $e = ee(K);
      return !ae && !$e ? !0 : ae !== $e ? !1 : _e(F.start, K.start) && _e(F.end, K.end);
    }
    return _e(F, K);
  }
  function Ae(F) {
    return !ee(F) || !s.value ? !1 : s.value.intersectsRange(r.value.range(F));
  }
  function st(F, K, ae, $e) {
    if (!ee(F))
      return null;
    if (m.value) {
      const at = r.value.toDate(F.start, {
        ...K[0],
        fillDate: x.value ?? void 0,
        patch: ae
      }), Jt = r.value.toDate(F.end, {
        ...K[1],
        fillDate: _.value ?? void 0,
        patch: ae
      });
      return ht({ start: at, end: Jt }, $e);
    }
    return r.value.toDateOrNull(F, {
      ...K[0],
      fillDate: c.value,
      patch: ae
    });
  }
  function ut(F, K) {
    return m.value ? ee(F) ? {
      start: r.value.fromDate(F.start, K[0]),
      end: r.value.fromDate(F.end, K[1])
    } : null : r.value.fromDate(F, K[0]);
  }
  function yt(F, K = {}) {
    return clearTimeout(p), new Promise((ae) => {
      const { debounce: $e = 0, ...at } = K;
      $e > 0 ? p = window.setTimeout(() => {
        ae(He(F, at));
      }, $e) : ae(He(F, at));
    });
  }
  function He(F, {
    config: K = $.value,
    patch: ae = "dateTime",
    clearIfEqual: $e = !1,
    formatInput: at = !0,
    hidePopover: Jt = !1,
    dragging: Pt = E.value,
    targetPriority: qn,
    moveToValue: Gr = !1
  } = {}) {
    const zi = I(K);
    let Wt = st(
      F,
      zi,
      ae,
      qn
    );
    if (Ae(Wt)) {
      if (Pt)
        return null;
      Wt = c.value, Jt = !1;
    } else
      Wt == null && e.isRequired ? Wt = c.value : (
        // Clear value if same value was passed
        Wt != null && re(c.value, Wt) && $e && (Wt = null)
      );
    const br = Pt ? u : c, Ot = !re(br.value, Wt);
    br.value = Wt, Pt || (u.value = null);
    const xn = ut(
      Wt,
      $.value
    );
    return Ot && (v = !1, a(Pt ? "drag" : "update:modelValue", xn), un(() => v = !0)), Jt && !Pt && we(), at && We(), Gr && un(() => Z(qn ?? "start")), xn;
  }
  function We() {
    un(() => {
      const F = I({
        type: "string",
        mask: A.value
      }), K = ut(
        u.value || c.value,
        F
      );
      m.value ? f.value = [K && K.start, K && K.end] : f.value = [K, ""];
    });
  }
  function wt(F, K, ae) {
    f.value.splice(K === "start" ? 0 : 1, 1, F);
    const $e = m.value ? {
      start: f.value[0],
      end: f.value[1] || f.value[0]
    } : F, at = {
      type: "string",
      mask: A.value
    };
    yt($e, {
      ...ae,
      config: at,
      patch: S.value,
      targetPriority: K,
      moveToValue: !0
    });
  }
  function Ke(F) {
    return (K) => {
      e.updateOnInput && wt(K.currentTarget.value, F, {
        formatInput: !1,
        hidePopover: !1,
        debounce: e.inputDebounce
      });
    };
  }
  function Ht(F) {
    return (K) => {
      wt(K.currentTarget.value, F, {
        formatInput: !0,
        hidePopover: !1
      });
    };
  }
  function Tt(F) {
    F.key === "Escape" && yt(c.value, {
      formatInput: !0,
      hidePopover: !0
    });
  }
  function ce(F) {
    return m.value ? [
      F && F.start ? r.value.getDateParts(F.start) : null,
      F && F.end ? r.value.getDateParts(F.end) : null
    ] : [F ? r.value.getDateParts(F) : null];
  }
  function xt() {
    u.value = null, We();
  }
  function xe(F) {
    a("popover-will-show", F);
  }
  function he(F) {
    a("popover-did-show", F);
  }
  function ft(F) {
    xt(), a("popover-will-hide", F);
  }
  function dt(F) {
    a("popover-did-hide", F);
  }
  function Ft(F) {
    const K = {
      patch: "date",
      formatInput: !0,
      hidePopover: !0
    };
    if (m.value) {
      const ae = !E.value;
      ae ? g = { start: F.startDate, end: F.endDate } : g != null && (g.end = F.date), yt(g, {
        ...K,
        dragging: ae
      });
    } else
      yt(F.date, {
        ...K,
        clearIfEqual: !e.isRequired
      });
  }
  function $t(F, K) {
    Ft(F), a("dayclick", F, K);
  }
  function J(F, K) {
    switch (K.key) {
      case " ":
      case "Enter": {
        Ft(F), K.preventDefault();
        break;
      }
      case "Escape":
        we();
    }
    a("daykeydown", F, K);
  }
  function ne(F, K) {
    !E.value || g == null || (g.end = F.date, yt(ht(g), {
      patch: "date",
      formatInput: !0
    }));
  }
  function me(F = {}) {
    Pd({
      ...L.value,
      ...F,
      isInteractive: !0,
      id: l.value
    });
  }
  function we(F = {}) {
    gc({
      hideDelay: 10,
      force: !0,
      ...L.value,
      ...F,
      id: l.value
    });
  }
  function ze(F) {
    L_({
      ...L.value,
      ...F,
      isInteractive: !0,
      id: l.value
    });
  }
  function ht(F, K) {
    const { start: ae, end: $e } = F;
    if (ae > $e)
      switch (K) {
        case "start":
          return { start: ae, end: ae };
        case "end":
          return { start: $e, end: $e };
        default:
          return { start: $e, end: ae };
      }
    return { start: ae, end: $e };
  }
  function Yr(F) {
    if (ee(c.value)) {
      const K = m.value ? F ? x.value : _.value : c.value;
      return T_(K, "monthly", r.value);
    }
    return null;
  }
  async function xr(F, K = {}) {
    return h.value == null ? !1 : h.value.move(F, K);
  }
  async function qr(F, K = {}) {
    return h.value == null ? !1 : h.value.moveBy(F, K);
  }
  async function Z(F, K = {}) {
    if (h.value == null)
      return !1;
    const { firstPage: ae, lastPage: $e, move: at } = h.value, Jt = F !== "end", Pt = Yr(Jt), qn = Jt ? 1 : -1;
    return !Pt || M_(Pt, ae, $e) ? !1 : at(Pt, {
      position: qn,
      ...K
    });
  }
  fe(
    () => e.isRange,
    (F) => {
      F && console.warn(
        "The `is-range` prop will be deprecated in future releases. Please use the `range` modifier."
      );
    },
    { immediate: !0 }
  ), fe(
    () => A.value,
    () => We()
  ), fe(
    () => e.modelValue,
    (F) => {
      v && He(F, {
        formatInput: !0,
        hidePopover: !1
      });
    }
  ), fe(
    () => O.value,
    () => {
      or(e.rules) && He(e.modelValue, {
        formatInput: !0,
        hidePopover: !1
      });
    }
  ), fe(
    () => e.timezone,
    () => {
      He(c.value, { formatInput: !0 });
    }
  );
  const Q = z($.value);
  c.value = st(e.modelValue, Q, "dateTime"), ct(() => {
    He(e.modelValue, {
      formatInput: !0,
      hidePopover: !1
    });
  }), un(() => o.value = !0);
  const ue = {
    ...n,
    showCalendar: o,
    datePickerPopoverId: l,
    popoverRef: d,
    popoverEvents: P,
    calendarRef: h,
    isRange: m,
    isTimeMode: w,
    isDateTimeMode: b,
    is24hr: ss(e, "is24hr"),
    hideTimeHeader: ss(e, "hideTimeHeader"),
    timeAccuracy: ss(e, "timeAccuracy"),
    isDragging: E,
    inputValue: H,
    inputEvents: M,
    dateParts: C,
    attributes: R,
    rules: O,
    move: xr,
    moveBy: qr,
    moveToValue: Z,
    updateValue: yt,
    showPopover: me,
    hidePopover: we,
    togglePopover: ze,
    onDayClick: $t,
    onDayKeydown: J,
    onDayMouseEnter: ne,
    onPopoverBeforeShow: xe,
    onPopoverAfterShow: he,
    onPopoverBeforeHide: ft,
    onPopoverAfterHide: dt
  };
  return $i(H_, ue), ue;
}
function T6() {
  const e = ur(H_);
  if (e)
    return e;
  throw new Error(
    "DatePicker context missing. Please verify this component is nested within a valid context provider."
  );
}
const O6 = [
  { value: 0, label: "12" },
  { value: 1, label: "1" },
  { value: 2, label: "2" },
  { value: 3, label: "3" },
  { value: 4, label: "4" },
  { value: 5, label: "5" },
  { value: 6, label: "6" },
  { value: 7, label: "7" },
  { value: 8, label: "8" },
  { value: 9, label: "9" },
  { value: 10, label: "10" },
  { value: 11, label: "11" }
], M6 = [
  { value: 12, label: "12" },
  { value: 13, label: "1" },
  { value: 14, label: "2" },
  { value: 15, label: "3" },
  { value: 16, label: "4" },
  { value: 17, label: "5" },
  { value: 18, label: "6" },
  { value: 19, label: "7" },
  { value: 20, label: "8" },
  { value: 21, label: "9" },
  { value: 22, label: "10" },
  { value: 23, label: "11" }
];
function F6(e) {
  const t = T6(), {
    locale: n,
    isRange: r,
    isTimeMode: i,
    dateParts: s,
    rules: a,
    is24hr: o,
    hideTimeHeader: l,
    timeAccuracy: c,
    updateValue: u
  } = t;
  function f(D) {
    D = Object.assign(h.value, D);
    let S = null;
    if (r.value) {
      const L = d.value ? D : s.value[0], P = d.value ? s.value[1] : D;
      S = { start: L, end: P };
    } else
      S = D;
    u(S, {
      patch: "time",
      targetPriority: d.value ? "start" : "end",
      moveToValue: !0
    });
  }
  const d = T(() => e.position === 0), h = T(
    () => s.value[e.position] || { isValid: !1 }
  ), p = T(() => A_(h.value)), g = T(() => !!h.value.isValid), v = T(() => !l.value && g.value), m = T(() => {
    if (!p.value)
      return null;
    let D = n.value.toDate(h.value);
    return h.value.hours === 24 && (D = new Date(D.getTime() - 1)), D;
  }), x = T({
    get() {
      return h.value.hours;
    },
    set(D) {
      f({ hours: D });
    }
  }), _ = T({
    get() {
      return h.value.minutes;
    },
    set(D) {
      f({ minutes: D });
    }
  }), y = T({
    get() {
      return h.value.seconds;
    },
    set(D) {
      f({ seconds: D });
    }
  }), b = T({
    get() {
      return h.value.milliseconds;
    },
    set(D) {
      f({ milliseconds: D });
    }
  }), w = T({
    get() {
      return h.value.hours < 12;
    },
    set(D) {
      D = String(D).toLowerCase() == "true";
      let S = x.value;
      D && S >= 12 ? S -= 12 : !D && S < 12 && (S += 12), f({ hours: S });
    }
  }), E = T(
    () => f5(h.value, a.value[e.position])
  ), $ = T(() => O6.filter(
    (D) => E.value.hours.some((S) => S.value === D.value)
  )), C = T(() => M6.filter(
    (D) => E.value.hours.some((S) => S.value === D.value)
  )), A = T(() => o.value ? E.value.hours : w.value ? $.value : C.value), k = T(() => {
    const D = [];
    return tr($.value) && D.push({ value: !0, label: "AM" }), tr(C.value) && D.push({ value: !1, label: "PM" }), D;
  });
  return {
    ...t,
    showHeader: v,
    timeAccuracy: c,
    parts: h,
    isValid: g,
    date: m,
    hours: x,
    minutes: _,
    seconds: y,
    milliseconds: b,
    options: E,
    hourOptions: A,
    isAM: w,
    isAMOptions: k,
    is24hr: o
  };
}
const P6 = {
  key: 0,
  class: "vc-time-header"
}, I6 = { class: "vc-time-weekday" }, R6 = { class: "vc-time-month" }, B6 = { class: "vc-time-day" }, N6 = { class: "vc-time-year" }, L6 = { class: "vc-time-select-group" }, j6 = /* @__PURE__ */ de("span", { class: "vc-time-colon" }, ":", -1), z6 = /* @__PURE__ */ de("span", { class: "vc-time-colon" }, ":", -1), V6 = /* @__PURE__ */ de("span", { class: "vc-time-decimal" }, ".", -1), H6 = /* @__PURE__ */ be({
  __name: "TimePicker",
  props: {
    position: null
  },
  setup(e, { expose: t }) {
    const r = F6(e);
    t(r);
    const {
      locale: i,
      isValid: s,
      date: a,
      hours: o,
      minutes: l,
      seconds: c,
      milliseconds: u,
      options: f,
      hourOptions: d,
      isTimeMode: h,
      isAM: p,
      isAMOptions: g,
      is24hr: v,
      showHeader: m,
      timeAccuracy: x
    } = r;
    return (_, y) => (j(), G("div", {
      class: Be(["vc-time-picker", [{ "vc-invalid": !X(s), "vc-attached": !X(h) }]])
    }, [
      Ee(_.$slots, "time-header", {}, () => [
        X(m) && X(a) ? (j(), G("div", P6, [
          de("span", I6, Fe(X(i).formatDate(X(a), "WWW")), 1),
          de("span", R6, Fe(X(i).formatDate(X(a), "MMM")), 1),
          de("span", B6, Fe(X(i).formatDate(X(a), "D")), 1),
          de("span", N6, Fe(X(i).formatDate(X(a), "YYYY")), 1)
        ])) : ve("", !0)
      ]),
      de("div", L6, [
        U(ms, {
          name: "Clock",
          size: "17"
        }),
        U(na, {
          modelValue: X(o),
          "onUpdate:modelValue": y[0] || (y[0] = (b) => Cr(o) ? o.value = b : null),
          modelModifiers: { number: !0 },
          options: X(d),
          "align-right": ""
        }, null, 8, ["modelValue", "options"]),
        X(x) > 1 ? (j(), G(Ie, { key: 0 }, [
          j6,
          U(na, {
            modelValue: X(l),
            "onUpdate:modelValue": y[1] || (y[1] = (b) => Cr(l) ? l.value = b : null),
            modelModifiers: { number: !0 },
            options: X(f).minutes,
            "align-left": X(x) === 2
          }, null, 8, ["modelValue", "options", "align-left"])
        ], 64)) : ve("", !0),
        X(x) > 2 ? (j(), G(Ie, { key: 1 }, [
          z6,
          U(na, {
            modelValue: X(c),
            "onUpdate:modelValue": y[2] || (y[2] = (b) => Cr(c) ? c.value = b : null),
            modelModifiers: { number: !0 },
            options: X(f).seconds,
            "align-left": X(x) === 3
          }, null, 8, ["modelValue", "options", "align-left"])
        ], 64)) : ve("", !0),
        X(x) > 3 ? (j(), G(Ie, { key: 2 }, [
          V6,
          U(na, {
            modelValue: X(u),
            "onUpdate:modelValue": y[3] || (y[3] = (b) => Cr(u) ? u.value = b : null),
            modelModifiers: { number: !0 },
            options: X(f).milliseconds,
            "align-left": ""
          }, null, 8, ["modelValue", "options"])
        ], 64)) : ve("", !0),
        X(v) ? ve("", !0) : (j(), ke(na, {
          key: 3,
          modelValue: X(p),
          "onUpdate:modelValue": y[4] || (y[4] = (b) => Cr(p) ? p.value = b : null),
          options: X(g)
        }, null, 8, ["modelValue", "options"]))
      ])
    ], 2));
  }
}), W_ = be({
  name: "DatePicker",
  inheritAttrs: !1,
  emits: D6,
  props: C6,
  setup(e, t) {
    const n = S6(e, t), { slots: r, attrs: i } = t, {
      isTimeMode: s,
      isRange: a,
      isDateTimeMode: o,
      color: l,
      displayMode: c,
      dateParts: u,
      datePickerPopoverId: f,
      attributes: d,
      calendarRef: h,
      popoverRef: p,
      showCalendar: g,
      onDayClick: v,
      onDayMouseEnter: m,
      onDayKeydown: x,
      onPopoverBeforeShow: _,
      onPopoverAfterShow: y,
      onPopoverBeforeHide: b,
      onPopoverAfterHide: w
    } = n;
    t.expose(n);
    const E = Oe(g_(n, "calendarRef", "popoverRef")), $ = () => (a.value ? [0, 1] : [0]).map((D) => er(H6, { position: D })), C = () => {
      if (!u.value)
        return null;
      const k = o.value ? { ...r, footer: $ } : r;
      return er(
        w6,
        {
          ...i,
          attributes: d.value,
          ref: h,
          onDayclick: v,
          onDaymouseenter: m,
          onDaykeydown: x
        },
        k
      );
    }, A = () => {
      if (s.value)
        return er(
          "div",
          {
            class: `vc-container vc-bordered vc-${l.value} vc-${c.value}`
          },
          [$()]
        );
      if (g.value)
        return C();
    };
    return r.default ? () => [
      // Popover trigger
      r.default(E),
      // Popover content
      er(
        bh,
        {
          id: f.value,
          placement: "bottom-start",
          class: `vc-date-picker-content vc-${l.value} vc-${c.value}`,
          ref: p,
          "onBefore-show": _,
          "onAfter-show": y,
          "onBefore-hide": b,
          "onAfter-hide": w
        },
        {
          default: A
        }
      )
    ] : A;
  }
}), W6 = /* @__PURE__ */ be({
  __name: "date-picker",
  props: {
    modelValue: {
      type: Number,
      required: !1,
      default: () => Date.now()
    }
  },
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, { emit: t }) {
    const n = e, r = t, i = oe();
    ct(() => {
      un(() => {
        i.value.refreshDateParts();
      });
    });
    const s = T({
      get: () => n.modelValue,
      set: (a) => r("update:modelValue", a)
    });
    return (a, o) => (j(), ke(X(W_), {
      ref_key: "picker",
      ref: i,
      modelValue: s.value,
      "onUpdate:modelValue": o[0] || (o[0] = (l) => s.value = l),
      modelModifiers: { number: !0 },
      mode: "dateTime",
      is24hr: "",
      "is-required": ""
    }, null, 8, ["modelValue"]));
  }
}), U6 = /* @__PURE__ */ be({
  __name: "date-range-picker",
  props: {
    mode: {
      type: String,
      required: !1,
      default: () => "date"
    },
    modelValue: {
      type: Array,
      required: !1,
      default: () => [Date.now(), Date.now()]
    }
  },
  emits: {
    "update:modelValue": (e) => !0,
    selected: () => !0
  },
  setup(e, { emit: t }) {
    const n = e, r = t, i = oe();
    ct(() => {
      un(() => {
        i.value.refreshDateParts();
      });
    });
    const s = T({
      get: () => ({
        start: n.modelValue[0],
        end: n.modelValue[1]
      }),
      set: (a) => r("update:modelValue", [a.start, a.end])
    });
    return fe(() => s.value, () => {
      s.value.end && s.value.start && r("selected");
    }, { deep: !0 }), (a, o) => (j(), ke(X(W_), {
      ref_key: "picker",
      ref: i,
      modelValue: s.value,
      "onUpdate:modelValue": o[0] || (o[0] = (l) => s.value = l),
      modelModifiers: { number: !0 },
      "is-range": "",
      "is-required": "",
      mode: e.mode
    }, null, 8, ["modelValue", "mode"]));
  }
}), xs = /* @__PURE__ */ be({
  __name: "overlay-loading",
  props: {
    full: {
      type: Boolean,
      required: !1,
      default: () => !1
    },
    zIndex: {
      type: Number,
      required: !1,
      default: () => 100
    },
    modelValue: {
      type: Boolean,
      required: !1,
      default: () => !0
    }
  },
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, { emit: t }) {
    const n = e, r = t, i = T({
      get: () => n.modelValue,
      set: (s) => r("update:modelValue", s)
    });
    return (s, a) => {
      const o = ge("v-progress-circular"), l = ge("v-overlay");
      return j(), ke(l, {
        modelValue: i.value,
        "onUpdate:modelValue": a[0] || (a[0] = (c) => i.value = c),
        class: "align-center justify-center",
        persistent: "",
        contained: !e.full,
        style: et(`z-index: ${e.zIndex};`),
        opacity: 0.5,
        "close-on-back": !1
      }, {
        default: pe(() => [
          Ee(s.$slots, "default", {}, () => [
            U(o, {
              class: "mx-auto",
              color: "white",
              indeterminate: "",
              size: "32"
            })
          ])
        ]),
        _: 3
      }, 8, ["modelValue", "contained", "style"]);
    };
  }
}), U_ = (e) => {
  let t = e.replace(/-([a-z])/g, (n, r) => r.toUpperCase());
  return t.length >= 1 && (t = `${t[0].toUpperCase()}${t.slice(1)}`), t;
}, _o = () => {
  const e = GA(), t = XA(), n = $d ? $d() : null;
  return {
    hasSlot(r = "default") {
      return !!e[r];
    },
    forceUpdate() {
      var r;
      (r = n == null ? void 0 : n.proxy) == null || r.$forceUpdate();
    },
    hasListener(r) {
      return !!t[`on${U_(r)}`];
    },
    nextTick(r) {
      var i;
      (i = n == null ? void 0 : n.proxy) == null || i.$nextTick(r);
    }
  };
}, Y6 = { key: 0 }, q6 = { class: "pa-3" }, Y_ = /* @__PURE__ */ be({
  __name: "dialog",
  props: {
    fullscreen: {
      type: Boolean,
      required: !1,
      default: () => !1
    },
    persistent: {
      type: Boolean,
      required: !1,
      default: () => !1
    },
    maxWidth: {
      type: String,
      required: !1,
      default: () => "480px"
    },
    hideHeader: {
      type: Boolean,
      required: !1,
      default: () => !1
    },
    title: {
      type: String,
      required: !1,
      default: () => null
    },
    modelValue: {
      type: Boolean,
      required: !1,
      default: () => null
    },
    hideClose: {
      type: Boolean,
      required: !1,
      default: () => !1
    },
    loading: {
      type: Boolean,
      required: !1,
      default: () => !1
    }
  },
  emits: {
    open: () => !0,
    close: () => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, { emit: t }) {
    const n = _o(), r = e, i = t, s = Oe({
      show: !1
    });
    fe(() => s.show, () => {
      s.show !== r.modelValue && (i("update:modelValue", s.show), a());
    }), fe(() => r.modelValue, () => {
      s.show !== r.modelValue && (s.show = !!r.modelValue, a());
    }), ct(() => {
      s.show = !!r.modelValue;
    });
    const a = () => {
      s.show ? i("open") : i("close");
    }, o = () => {
      s.show = !s.show;
    };
    return (l, c) => {
      const u = ge("v-spacer"), f = ge("v-btn"), d = ge("v-row"), h = ge("v-divider"), p = ge("v-card"), g = ge("v-dialog");
      return j(), G("div", null, [
        Ee(l.$slots, "active", { switchShow: o }),
        U(g, {
          modelValue: s.show,
          "onUpdate:modelValue": c[1] || (c[1] = (v) => s.show = v),
          width: e.fullscreen ? void 0 : "90vw",
          "max-width": e.fullscreen ? void 0 : e.maxWidth,
          persistent: e.loading || e.persistent,
          fullscreen: e.fullscreen
        }, {
          default: pe(() => [
            s.show ? (j(), ke(p, {
              key: 0,
              rounded: "lg"
            }, {
              default: pe(() => [
                U(xs, {
                  "z-index": 502,
                  "model-value": e.loading
                }, null, 8, ["model-value"]),
                (j(), G(Ie, null, _t(2, (v) => de("div", {
                  key: v,
                  class: Be(["w-100", {
                    "rounded-t-lg": !0,
                    "ng-component-dialog": v === 1,
                    "ng-component-dialog-fake": v === 2
                  }]),
                  style: { background: "rgb(var(--v-theme-surface))" }
                }, [
                  e.hideHeader ? ve("", !0) : (j(), ke(d, {
                    key: 0,
                    class: "px-3 py-1",
                    style: { "min-height": "56px" },
                    "no-gutters": "",
                    align: "center"
                  }, {
                    default: pe(() => [
                      e.title ? (j(), G("h3", Y6, Fe(e.title), 1)) : ve("", !0),
                      U(u),
                      !e.hideClose && !X(n).hasSlot("actions") ? (j(), ke(f, {
                        key: 1,
                        variant: "plain",
                        icon: "mdi-close",
                        disabled: e.loading,
                        onClick: c[0] || (c[0] = (m) => s.show = !1)
                      }, null, 8, ["disabled"])) : ve("", !0),
                      Ee(l.$slots, "actions", { switchShow: o })
                    ]),
                    _: 3
                  })),
                  e.hideHeader ? ve("", !0) : (j(), ke(h, { key: 1 }))
                ], 2)), 64)),
                de("div", q6, [
                  Ee(l.$slots, "default", { switchShow: o })
                ]),
                Ee(l.$slots, "footer")
              ]),
              _: 3
            })) : ve("", !0)
          ]),
          _: 3
        }, 8, ["modelValue", "width", "max-width", "persistent", "fullscreen"])
      ]);
    };
  }
}), G6 = /* @__PURE__ */ be({
  __name: "fixed-bar",
  props: {
    app: {
      type: Boolean,
      required: !1,
      default: () => !1
    },
    dark: {
      type: Boolean,
      required: !1,
      default: () => !1
    },
    color: {
      type: String,
      required: !1,
      default: () => {
      }
    },
    elevation: {
      type: Number,
      required: !1,
      default: () => {
      }
    },
    hideSpace: {
      type: Boolean,
      required: !1,
      default: () => !1
    },
    position: {
      type: String,
      required: !1,
      default: () => "bottom"
    }
  },
  setup(e) {
    const t = oe(), n = new ResizeObserver(() => a()), r = e, i = Oe({
      style: "",
      contentHeight: 0
    }), s = T(() => {
      let o = [];
      return r.app && (o.push("lib-component-fixed-bar-app"), r.position === "top" ? o.push("lib-component-fixed-bar-app-top") : o.push("lib-component-fixed-bar-app-bottom")), o.join(" ");
    });
    ct(() => {
      t.value && n.observe(t.value.$el), a();
    }), zt(() => {
      n.disconnect();
    });
    const a = () => {
      t.value && (i.contentHeight = t.value.$el.clientHeight);
    };
    return (o, l) => {
      const c = ge("v-toolbar");
      return j(), G("div", null, [
        e.hideSpace ? ve("", !0) : (j(), G("div", {
          key: 0,
          style: et(`height: ${i.contentHeight}px`)
        }, null, 4)),
        U(c, {
          ref_key: "content",
          ref: t,
          class: Be(["lib-component-fixed-bar", s.value]),
          height: "auto",
          elevation: e.elevation,
          dark: e.dark,
          color: e.color
        }, {
          default: pe(() => [
            Ee(o.$slots, "default", {}, void 0, !0)
          ]),
          _: 3
        }, 8, ["elevation", "dark", "color", "class"])
      ]);
    };
  }
}), Sn = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [r, i] of t)
    n[r] = i;
  return n;
}, X6 = /* @__PURE__ */ Sn(G6, [["__scopeId", "data-v-ae397624"]]);
function Ze(e, t) {
  return (n) => Object.keys(e).reduce((r, i) => {
    const a = typeof e[i] == "object" && e[i] != null && !Array.isArray(e[i]) ? e[i] : {
      type: e[i]
    };
    return n && i in n ? r[i] = {
      ...a,
      default: n[i]
    } : r[i] = a, t && !r[i].source && (r[i].source = t), r;
  }, {});
}
const pr = Ze({
  class: [String, Array],
  style: {
    type: [String, Array, Object],
    default: null
  }
}, "component"), Z6 = typeof window < "u", q_ = Z6 && "IntersectionObserver" in window;
function Nt(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "px";
  if (!(e == null || e === ""))
    return isNaN(+e) ? String(e) : isFinite(+e) ? `${Number(e)}${t}` : void 0;
}
function sv(e) {
  return e !== null && typeof e == "object" && !Array.isArray(e);
}
function Gu(e, t) {
  return t.every((n) => e.hasOwnProperty(n));
}
function G_(e, t) {
  const n = {}, r = new Set(Object.keys(e));
  for (const i of t)
    r.has(i) && (n[i] = e[i]);
  return n;
}
function av(e, t, n) {
  const r = /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null);
  for (const s in e)
    t.some((a) => a instanceof RegExp ? a.test(s) : a === s) && !(n != null && n.some((a) => a === s)) ? r[s] = e[s] : i[s] = e[s];
  return [r, i];
}
function K6(e, t) {
  const n = {
    ...e
  };
  return t.forEach((r) => delete n[r]), n;
}
const X_ = /^on[^a-z]/, J6 = (e) => X_.test(e), Q6 = ["onAfterscriptexecute", "onAnimationcancel", "onAnimationend", "onAnimationiteration", "onAnimationstart", "onAuxclick", "onBeforeinput", "onBeforescriptexecute", "onChange", "onClick", "onCompositionend", "onCompositionstart", "onCompositionupdate", "onContextmenu", "onCopy", "onCut", "onDblclick", "onFocusin", "onFocusout", "onFullscreenchange", "onFullscreenerror", "onGesturechange", "onGestureend", "onGesturestart", "onGotpointercapture", "onInput", "onKeydown", "onKeypress", "onKeyup", "onLostpointercapture", "onMousedown", "onMousemove", "onMouseout", "onMouseover", "onMouseup", "onMousewheel", "onPaste", "onPointercancel", "onPointerdown", "onPointerenter", "onPointerleave", "onPointermove", "onPointerout", "onPointerover", "onPointerup", "onReset", "onSelect", "onSubmit", "onTouchcancel", "onTouchend", "onTouchmove", "onTouchstart", "onTransitioncancel", "onTransitionend", "onTransitionrun", "onTransitionstart", "onWheel"];
function eN(e) {
  const [t, n] = av(e, [X_]), r = K6(t, Q6), [i, s] = av(n, ["class", "style", "id", /^data-/]);
  return Object.assign(i, t), Object.assign(s, r), [i, s];
}
function Tl(e) {
  return e == null ? [] : Array.isArray(e) ? e : [e];
}
function tN(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  return Math.max(t, Math.min(n, e));
}
function ov(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0";
  return e + n.repeat(Math.max(0, t - e.length));
}
function nN(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  const n = [];
  let r = 0;
  for (; r < e.length; )
    n.push(e.substr(r, t)), r += t;
  return n;
}
function Z_() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 ? arguments[2] : void 0;
  const r = {};
  for (const i in e)
    r[i] = e[i];
  for (const i in t) {
    const s = e[i], a = t[i];
    if (sv(s) && sv(a)) {
      r[i] = Z_(s, a, n);
      continue;
    }
    if (Array.isArray(s) && Array.isArray(a) && n) {
      r[i] = n(s, a);
      continue;
    }
    r[i] = a;
  }
  return r;
}
function K_(e) {
  return e.map((t) => t.type === Ie ? K_(t.children) : t).flat();
}
function ci() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  if (ci.cache.has(e))
    return ci.cache.get(e);
  const t = e.replace(/[^a-z]/gi, "-").replace(/\B([A-Z])/g, "-$1").toLowerCase();
  return ci.cache.set(e, t), t;
}
ci.cache = /* @__PURE__ */ new Map();
function J_(e) {
  const t = Oe({}), n = T(e);
  return Zc(() => {
    for (const r in n.value)
      t[r] = n.value[r];
  }, {
    flush: "sync"
  }), db(t);
}
function Id(e, t) {
  return e.includes(t);
}
const cs = () => [Function, Array];
function rN(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  if (Array.isArray(e))
    for (const i of e)
      i(...n);
  else
    typeof e == "function" && e(...n);
}
const iN = ["top", "bottom"], sN = ["start", "end", "left", "right"];
function aN(e, t) {
  let [n, r] = e.split(" ");
  return r || (r = Id(iN, n) ? "start" : Id(sN, n) ? "top" : "center"), {
    side: lv(n, t),
    align: lv(r, t)
  };
}
function lv(e, t) {
  return e === "start" ? t ? "right" : "left" : e === "end" ? t ? "left" : "right" : e;
}
class Xu {
  constructor(t) {
    let {
      x: n,
      y: r,
      width: i,
      height: s
    } = t;
    this.x = n, this.y = r, this.width = i, this.height = s;
  }
  get top() {
    return this.y;
  }
  get bottom() {
    return this.y + this.height;
  }
  get left() {
    return this.x;
  }
  get right() {
    return this.x + this.width;
  }
}
function oN(e) {
  const t = e.getBoundingClientRect(), n = getComputedStyle(e), r = n.transform;
  if (r) {
    let i, s, a, o, l;
    if (r.startsWith("matrix3d("))
      i = r.slice(9, -1).split(/, /), s = +i[0], a = +i[5], o = +i[12], l = +i[13];
    else if (r.startsWith("matrix("))
      i = r.slice(7, -1).split(/, /), s = +i[0], a = +i[3], o = +i[4], l = +i[5];
    else
      return new Xu(t);
    const c = n.transformOrigin, u = t.x - o - (1 - s) * parseFloat(c), f = t.y - l - (1 - a) * parseFloat(c.slice(c.indexOf(" ") + 1)), d = s ? t.width / s : e.offsetWidth + 1, h = a ? t.height / a : e.offsetHeight + 1;
    return new Xu({
      x: u,
      y: f,
      width: d,
      height: h
    });
  } else
    return new Xu(t);
}
function lN(e, t, n) {
  if (typeof e.animate > "u")
    return {
      finished: Promise.resolve()
    };
  let r;
  try {
    r = e.animate(t, n);
  } catch {
    return {
      finished: Promise.resolve()
    };
  }
  return typeof r.finished > "u" && (r.finished = new Promise((i) => {
    r.onfinish = () => {
      i(r);
    };
  })), r;
}
const Hi = 2.4, cv = 0.2126729, uv = 0.7151522, fv = 0.072175, cN = 0.55, uN = 0.58, fN = 0.57, dN = 0.62, Wo = 0.03, dv = 1.45, hN = 5e-4, pN = 1.25, gN = 1.25, hv = 0.078, pv = 12.82051282051282, Uo = 0.06, gv = 1e-3;
function vv(e, t) {
  const n = (e.r / 255) ** Hi, r = (e.g / 255) ** Hi, i = (e.b / 255) ** Hi, s = (t.r / 255) ** Hi, a = (t.g / 255) ** Hi, o = (t.b / 255) ** Hi;
  let l = n * cv + r * uv + i * fv, c = s * cv + a * uv + o * fv;
  if (l <= Wo && (l += (Wo - l) ** dv), c <= Wo && (c += (Wo - c) ** dv), Math.abs(c - l) < hN)
    return 0;
  let u;
  if (c > l) {
    const f = (c ** cN - l ** uN) * pN;
    u = f < gv ? 0 : f < hv ? f - f * pv * Uo : f - Uo;
  } else {
    const f = (c ** dN - l ** fN) * gN;
    u = f > -gv ? 0 : f > -hv ? f - f * pv * Uo : f + Uo;
  }
  return u * 100;
}
function Ca(e) {
  ZA(`Vuetify: ${e}`);
}
function Rd(e) {
  return !!e && /^(#|var\(--|(rgb|hsl)a?\()/.test(e);
}
function vN(e) {
  return Rd(e) && !/^((rgb|hsl)a?\()?var\(--/.test(e);
}
const mv = /^(?<fn>(?:rgb|hsl)a?)\((?<values>.+)\)/, mN = {
  rgb: (e, t, n, r) => ({
    r: e,
    g: t,
    b: n,
    a: r
  }),
  rgba: (e, t, n, r) => ({
    r: e,
    g: t,
    b: n,
    a: r
  }),
  hsl: (e, t, n, r) => yv({
    h: e,
    s: t,
    l: n,
    a: r
  }),
  hsla: (e, t, n, r) => yv({
    h: e,
    s: t,
    l: n,
    a: r
  }),
  hsv: (e, t, n, r) => Ga({
    h: e,
    s: t,
    v: n,
    a: r
  }),
  hsva: (e, t, n, r) => Ga({
    h: e,
    s: t,
    v: n,
    a: r
  })
};
function ya(e) {
  if (typeof e == "number")
    return (isNaN(e) || e < 0 || e > 16777215) && Ca(`'${e}' is not a valid hex color`), {
      r: (e & 16711680) >> 16,
      g: (e & 65280) >> 8,
      b: e & 255
    };
  if (typeof e == "string" && mv.test(e)) {
    const {
      groups: t
    } = e.match(mv), {
      fn: n,
      values: r
    } = t, i = r.split(/,\s*/).map((s) => s.endsWith("%") && ["hsl", "hsla", "hsv", "hsva"].includes(n) ? parseFloat(s) / 100 : parseFloat(s));
    return mN[n](...i);
  } else if (typeof e == "string") {
    let t = e.startsWith("#") ? e.slice(1) : e;
    [3, 4].includes(t.length) ? t = t.split("").map((r) => r + r).join("") : [6, 8].includes(t.length) || Ca(`'${e}' is not a valid hex(a) color`);
    const n = parseInt(t, 16);
    return (isNaN(n) || n < 0 || n > 4294967295) && Ca(`'${e}' is not a valid hex(a) color`), yN(t);
  } else if (typeof e == "object") {
    if (Gu(e, ["r", "g", "b"]))
      return e;
    if (Gu(e, ["h", "s", "l"]))
      return Ga(Q_(e));
    if (Gu(e, ["h", "s", "v"]))
      return Ga(e);
  }
  throw new TypeError(`Invalid color: ${e == null ? e : String(e) || e.constructor.name}
Expected #hex, #hexa, rgb(), rgba(), hsl(), hsla(), object or number`);
}
function Ga(e) {
  const {
    h: t,
    s: n,
    v: r,
    a: i
  } = e, s = (o) => {
    const l = (o + t / 60) % 6;
    return r - r * n * Math.max(Math.min(l, 4 - l, 1), 0);
  }, a = [s(5), s(3), s(1)].map((o) => Math.round(o * 255));
  return {
    r: a[0],
    g: a[1],
    b: a[2],
    a: i
  };
}
function yv(e) {
  return Ga(Q_(e));
}
function Q_(e) {
  const {
    h: t,
    s: n,
    l: r,
    a: i
  } = e, s = r + n * Math.min(r, 1 - r), a = s === 0 ? 0 : 2 - 2 * r / s;
  return {
    h: t,
    s: a,
    v: s,
    a: i
  };
}
function yN(e) {
  e = xN(e);
  let [t, n, r, i] = nN(e, 2).map((s) => parseInt(s, 16));
  return i = i === void 0 ? i : i / 255, {
    r: t,
    g: n,
    b: r,
    a: i
  };
}
function xN(e) {
  return e.startsWith("#") && (e = e.slice(1)), e = e.replace(/([^0-9a-f])/gi, "F"), (e.length === 3 || e.length === 4) && (e = e.split("").map((t) => t + t).join("")), e.length !== 6 && (e = ov(ov(e, 6), 8, "F")), e;
}
function bN(e) {
  const t = Math.abs(vv(ya(0), ya(e)));
  return Math.abs(vv(ya(16777215), ya(e))) > Math.min(t, 50) ? "#fff" : "#000";
}
const Bd = Symbol.for("vuetify:defaults");
function ew() {
  const e = ur(Bd);
  if (!e)
    throw new Error("[Vuetify] Could not find defaults instance");
  return e;
}
function _N(e, t) {
  var n, r;
  return typeof ((n = e.props) == null ? void 0 : n[t]) < "u" || typeof ((r = e.props) == null ? void 0 : r[ci(t)]) < "u";
}
function wN() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 ? arguments[1] : void 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ew();
  const r = Ci("useDefaults");
  if (t = t ?? r.type.name ?? r.type.__name, !t)
    throw new Error("[Vuetify] Could not determine component name");
  const i = T(() => {
    var l;
    return (l = n.value) == null ? void 0 : l[e._as ?? t];
  }), s = new Proxy(e, {
    get(l, c) {
      var f, d, h, p;
      const u = Reflect.get(l, c);
      return c === "class" || c === "style" ? [(f = i.value) == null ? void 0 : f[c], u].filter((g) => g != null) : typeof c == "string" && !_N(r.vnode, c) ? ((d = i.value) == null ? void 0 : d[c]) ?? ((p = (h = n.value) == null ? void 0 : h.global) == null ? void 0 : p[c]) ?? u : u;
    }
  }), a = gi();
  Zc(() => {
    if (i.value) {
      const l = Object.entries(i.value).filter((c) => {
        let [u] = c;
        return u.startsWith(u[0].toUpperCase());
      });
      a.value = l.length ? Object.fromEntries(l) : void 0;
    } else
      a.value = void 0;
  });
  function o() {
    const l = EN(Bd, r);
    $i(Bd, T(() => a.value ? Z_((l == null ? void 0 : l.value) ?? {}, a.value) : l == null ? void 0 : l.value));
  }
  return {
    props: s,
    provideSubDefaults: o
  };
}
function cu(e) {
  if (e._setup = e._setup ?? e.setup, !e.name)
    return Ca("The component is missing an explicit name, unable to generate default prop value"), e;
  if (e._setup) {
    e.props = Ze(e.props ?? {}, e.name)();
    const t = Object.keys(e.props).filter((n) => n !== "class" && n !== "style");
    e.filterProps = function(r) {
      return G_(r, t);
    }, e.props._as = String, e.setup = function(r, i) {
      const s = ew();
      if (!s.value)
        return e._setup(r, i);
      const {
        props: a,
        provideSubDefaults: o
      } = wN(r, r._as ?? e.name, s), l = e._setup(a, i);
      return o(), l;
    };
  }
  return e;
}
function sn() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
  return (t) => (e ? cu : be)(t);
}
const $N = "cubic-bezier(0.4, 0, 0.2, 1)";
function Ci(e, t) {
  const n = $d();
  if (!n)
    throw new Error(`[Vuetify] ${e} ${t || "must be called from inside a setup function"}`);
  return n;
}
function Hs() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "composables";
  const t = Ci(e).type;
  return ci((t == null ? void 0 : t.aliasName) || (t == null ? void 0 : t.name));
}
let tw = 0, Ol = /* @__PURE__ */ new WeakMap();
function uu() {
  const e = Ci("getUid");
  if (Ol.has(e))
    return Ol.get(e);
  {
    const t = tw++;
    return Ol.set(e, t), t;
  }
}
uu.reset = () => {
  tw = 0, Ol = /* @__PURE__ */ new WeakMap();
};
function EN(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ci("injectSelf");
  const {
    provides: n
  } = t;
  if (n && e in n)
    return n[e];
}
function Wn(e) {
  const t = Ci("useRender");
  t.render = e;
}
function Nd(e, t) {
  let n;
  function r() {
    n = JA(), n.run(() => t.length ? t(() => {
      n == null || n.stop(), r();
    }) : t());
  }
  fe(e, (i) => {
    i && !n ? r() : i || (n == null || n.stop(), n = void 0);
  }, {
    immediate: !0
  }), KA(() => {
    n == null || n.stop();
  });
}
function wo(e, t, n) {
  let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : (f) => f, i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : (f) => f;
  const s = Ci("useProxiedModel"), a = oe(e[t] !== void 0 ? e[t] : n), o = ci(t), c = o !== t ? T(() => {
    var f, d, h, p;
    return e[t], !!(((f = s.vnode.props) != null && f.hasOwnProperty(t) || (d = s.vnode.props) != null && d.hasOwnProperty(o)) && ((h = s.vnode.props) != null && h.hasOwnProperty(`onUpdate:${t}`) || (p = s.vnode.props) != null && p.hasOwnProperty(`onUpdate:${o}`)));
  }) : T(() => {
    var f, d;
    return e[t], !!((f = s.vnode.props) != null && f.hasOwnProperty(t) && ((d = s.vnode.props) != null && d.hasOwnProperty(`onUpdate:${t}`)));
  });
  Nd(() => !c.value, () => {
    fe(() => e[t], (f) => {
      a.value = f;
    });
  });
  const u = T({
    get() {
      const f = e[t];
      return r(c.value ? f : a.value);
    },
    set(f) {
      const d = i(f), h = QA(c.value ? e[t] : a.value);
      h === d || r(h) === f || (a.value = d, s == null || s.emit(`update:${t}`, d));
    }
  });
  return Object.defineProperty(u, "externalValue", {
    get: () => c.value ? e[t] : a.value
  }), u;
}
const nw = Symbol.for("vuetify:locale");
function AN() {
  const e = ur(nw);
  if (!e)
    throw new Error("[Vuetify] Could not find injected locale instance");
  return e;
}
function fu() {
  const e = ur(nw);
  if (!e)
    throw new Error("[Vuetify] Could not find injected rtl instance");
  return {
    isRtl: e.isRtl,
    rtlClasses: e.rtlClasses
  };
}
const xv = Symbol.for("vuetify:theme"), du = Ze({
  theme: String
}, "theme");
function _h(e) {
  Ci("provideTheme");
  const t = ur(xv, null);
  if (!t)
    throw new Error("Could not find Vuetify theme injection");
  const n = T(() => e.theme ?? t.name.value), r = T(() => t.themes.value[n.value]), i = T(() => t.isDisabled ? void 0 : `v-theme--${n.value}`), s = {
    ...t,
    name: n,
    current: r,
    themeClasses: i
  };
  return $i(xv, s), s;
}
const rw = Ze({
  tag: {
    type: String,
    default: "div"
  }
}, "tag"), kN = Ze({
  disabled: Boolean,
  group: Boolean,
  hideOnLeave: Boolean,
  leaveAbsolute: Boolean,
  mode: String,
  origin: String
}, "transition");
function an(e, t, n) {
  return sn()({
    name: e,
    props: kN({
      mode: n,
      origin: t
    }),
    setup(r, i) {
      let {
        slots: s
      } = i;
      const a = {
        onBeforeEnter(o) {
          r.origin && (o.style.transformOrigin = r.origin);
        },
        onLeave(o) {
          if (r.leaveAbsolute) {
            const {
              offsetTop: l,
              offsetLeft: c,
              offsetWidth: u,
              offsetHeight: f
            } = o;
            o._transitionInitialStyles = {
              position: o.style.position,
              top: o.style.top,
              left: o.style.left,
              width: o.style.width,
              height: o.style.height
            }, o.style.position = "absolute", o.style.top = `${l}px`, o.style.left = `${c}px`, o.style.width = `${u}px`, o.style.height = `${f}px`;
          }
          r.hideOnLeave && o.style.setProperty("display", "none", "important");
        },
        onAfterLeave(o) {
          if (r.leaveAbsolute && (o != null && o._transitionInitialStyles)) {
            const {
              position: l,
              top: c,
              left: u,
              width: f,
              height: d
            } = o._transitionInitialStyles;
            delete o._transitionInitialStyles, o.style.position = l || "", o.style.top = c || "", o.style.left = u || "", o.style.width = f || "", o.style.height = d || "";
          }
        }
      };
      return () => {
        const o = r.group ? gb : Fs;
        return er(o, {
          name: r.disabled ? "" : e,
          css: !r.disabled,
          ...r.group ? void 0 : {
            mode: r.mode
          },
          ...r.disabled ? {} : a
        }, s.default);
      };
    }
  });
}
function iw(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "in-out";
  return sn()({
    name: e,
    props: {
      mode: {
        type: String,
        default: n
      },
      disabled: Boolean
    },
    setup(r, i) {
      let {
        slots: s
      } = i;
      return () => er(Fs, {
        name: r.disabled ? "" : e,
        css: !r.disabled,
        // mode: props.mode, // TODO: vuejs/vue-next#3104
        ...r.disabled ? {} : t
      }, s.default);
    }
  });
}
function sw() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  const n = (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1) ? "width" : "height", r = ek(`offset-${n}`);
  return {
    onBeforeEnter(a) {
      a._parent = a.parentNode, a._initialStyle = {
        transition: a.style.transition,
        overflow: a.style.overflow,
        [n]: a.style[n]
      };
    },
    onEnter(a) {
      const o = a._initialStyle;
      a.style.setProperty("transition", "none", "important"), a.style.overflow = "hidden";
      const l = `${a[r]}px`;
      a.style[n] = "0", a.offsetHeight, a.style.transition = o.transition, e && a._parent && a._parent.classList.add(e), requestAnimationFrame(() => {
        a.style[n] = l;
      });
    },
    onAfterEnter: s,
    onEnterCancelled: s,
    onLeave(a) {
      a._initialStyle = {
        transition: "",
        overflow: a.style.overflow,
        [n]: a.style[n]
      }, a.style.overflow = "hidden", a.style[n] = `${a[r]}px`, a.offsetHeight, requestAnimationFrame(() => a.style[n] = "0");
    },
    onAfterLeave: i,
    onLeaveCancelled: i
  };
  function i(a) {
    e && a._parent && a._parent.classList.remove(e), s(a);
  }
  function s(a) {
    const o = a._initialStyle[n];
    a.style.overflow = a._initialStyle.overflow, o != null && (a.style[n] = o), delete a._initialStyle;
  }
}
an("fab-transition", "center center", "out-in");
an("dialog-bottom-transition");
an("dialog-top-transition");
an("fade-transition");
an("scale-transition");
an("scroll-x-transition");
an("scroll-x-reverse-transition");
an("scroll-y-transition");
an("scroll-y-reverse-transition");
an("slide-x-transition");
an("slide-x-reverse-transition");
const aw = an("slide-y-transition");
an("slide-y-reverse-transition");
iw("expand-transition", sw());
const CN = iw("expand-x-transition", sw("", !0)), ow = Ze({
  transition: {
    type: [Boolean, String, Object],
    default: "fade-transition",
    validator: (e) => e !== !0
  }
}, "transition"), lw = (e, t) => {
  let {
    slots: n
  } = t;
  const {
    transition: r,
    disabled: i,
    ...s
  } = e, {
    component: a = Fs,
    ...o
  } = typeof r == "object" ? r : {};
  return er(a, Gt(typeof r == "string" ? {
    name: i ? "" : r
  } : o, s, {
    disabled: i
  }), n);
};
function DN(e, t) {
  if (!q_)
    return;
  const n = t.modifiers || {}, r = t.value, {
    handler: i,
    options: s
  } = typeof r == "object" ? r : {
    handler: r,
    options: {}
  }, a = new IntersectionObserver(function() {
    var f;
    let o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], l = arguments.length > 1 ? arguments[1] : void 0;
    const c = (f = e._observe) == null ? void 0 : f[t.instance.$.uid];
    if (!c)
      return;
    const u = o.some((d) => d.isIntersecting);
    i && (!n.quiet || c.init) && (!n.once || u || c.init) && i(u, o, l), u && n.once ? cw(e, t) : c.init = !0;
  }, s);
  e._observe = Object(e._observe), e._observe[t.instance.$.uid] = {
    init: !1,
    observer: a
  }, a.observe(e);
}
function cw(e, t) {
  var r;
  const n = (r = e._observe) == null ? void 0 : r[t.instance.$.uid];
  n && (n.observer.unobserve(e), delete e._observe[t.instance.$.uid]);
}
const SN = {
  mounted: DN,
  unmounted: cw
}, TN = SN;
function uw(e) {
  return J_(() => {
    const t = [], n = {};
    if (e.value.background)
      if (Rd(e.value.background)) {
        if (n.backgroundColor = e.value.background, !e.value.text && vN(e.value.background)) {
          const r = ya(e.value.background);
          if (r.a == null || r.a === 1) {
            const i = bN(r);
            n.color = i, n.caretColor = i;
          }
        }
      } else
        t.push(`bg-${e.value.background}`);
    return e.value.text && (Rd(e.value.text) ? (n.color = e.value.text, n.caretColor = e.value.text) : t.push(`text-${e.value.text}`)), {
      colorClasses: t,
      colorStyles: n
    };
  });
}
function hu(e, t) {
  const n = T(() => ({
    text: Cr(e) ? e.value : t ? e[t] : null
  })), {
    colorClasses: r,
    colorStyles: i
  } = uw(n);
  return {
    textColorClasses: r,
    textColorStyles: i
  };
}
function Ld(e, t) {
  const n = T(() => ({
    background: Cr(e) ? e.value : t ? e[t] : null
  })), {
    colorClasses: r,
    colorStyles: i
  } = uw(n);
  return {
    backgroundColorClasses: r,
    backgroundColorStyles: i
  };
}
const fw = Ze({
  rounded: {
    type: [Boolean, Number, String],
    default: void 0
  }
}, "rounded");
function dw(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Hs();
  return {
    roundedClasses: T(() => {
      const r = Cr(e) ? e.value : e.rounded, i = [];
      if (r === !0 || r === "")
        i.push(`${t}--rounded`);
      else if (typeof r == "string" || r === 0)
        for (const s of String(r).split(" "))
          i.push(`rounded-${s}`);
      return i;
    })
  };
}
const ON = [null, "default", "comfortable", "compact"], MN = Ze({
  density: {
    type: String,
    default: "default",
    validator: (e) => ON.includes(e)
  }
}, "density");
function FN(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Hs();
  return {
    densityClasses: T(() => `${t}--density-${e.density}`)
  };
}
const ui = [String, Function, Object, Array], PN = Symbol.for("vuetify:icons"), pu = Ze({
  icon: {
    type: ui
  },
  // Could not remove this and use makeTagProps, types complained because it is not required
  tag: {
    type: String,
    required: !0
  }
}, "icon"), bv = sn()({
  name: "VComponentIcon",
  props: pu(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return () => {
      const r = e.icon;
      return U(e.tag, null, {
        default: () => {
          var i;
          return [e.icon ? U(r, null, null) : (i = n.default) == null ? void 0 : i.call(n)];
        }
      });
    };
  }
}), IN = cu({
  name: "VSvgIcon",
  inheritAttrs: !1,
  props: pu(),
  setup(e, t) {
    let {
      attrs: n
    } = t;
    return () => U(e.tag, Gt(n, {
      style: null
    }), {
      default: () => [U("svg", {
        class: "v-icon__svg",
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        role: "img",
        "aria-hidden": "true"
      }, [Array.isArray(e.icon) ? e.icon.map((r) => Array.isArray(r) ? U("path", {
        d: r[0],
        "fill-opacity": r[1]
      }, null) : U("path", {
        d: r
      }, null)) : U("path", {
        d: e.icon
      }, null)])]
    });
  }
});
cu({
  name: "VLigatureIcon",
  props: pu(),
  setup(e) {
    return () => U(e.tag, null, {
      default: () => [e.icon]
    });
  }
});
cu({
  name: "VClassIcon",
  props: pu(),
  setup(e) {
    return () => U(e.tag, {
      class: e.icon
    }, null);
  }
});
const RN = (e) => {
  const t = ur(PN);
  if (!t)
    throw new Error("Missing Vuetify Icons provide!");
  return {
    iconData: T(() => {
      var l;
      const r = X(e);
      if (!r)
        return {
          component: bv
        };
      let i = r;
      if (typeof i == "string" && (i = i.trim(), i.startsWith("$") && (i = (l = t.aliases) == null ? void 0 : l[i.slice(1)])), !i)
        throw new Error(`Could not find aliased icon "${r}"`);
      if (Array.isArray(i))
        return {
          component: IN,
          icon: i
        };
      if (typeof i != "string")
        return {
          component: bv,
          icon: i
        };
      const s = Object.keys(t.sets).find((c) => typeof i == "string" && i.startsWith(`${c}:`)), a = s ? i.slice(s.length + 1) : i;
      return {
        component: t.sets[s ?? t.defaultSet].component,
        icon: a
      };
    })
  };
}, BN = ["x-small", "small", "default", "large", "x-large"], NN = Ze({
  size: {
    type: [String, Number],
    default: "default"
  }
}, "size");
function LN(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Hs();
  return J_(() => {
    let n, r;
    return Id(BN, e.size) ? n = `${t}--size-${e.size}` : e.size && (r = {
      width: Nt(e.size),
      height: Nt(e.size)
    }), {
      sizeClasses: n,
      sizeStyles: r
    };
  });
}
const jN = Ze({
  color: String,
  start: Boolean,
  end: Boolean,
  icon: ui,
  ...pr(),
  ...NN(),
  ...rw({
    tag: "i"
  }),
  ...du()
}, "VIcon"), zN = sn()({
  name: "VIcon",
  props: jN(),
  setup(e, t) {
    let {
      attrs: n,
      slots: r
    } = t;
    const i = oe(), {
      themeClasses: s
    } = _h(e), {
      iconData: a
    } = RN(T(() => i.value || e.icon)), {
      sizeClasses: o
    } = LN(e), {
      textColorClasses: l,
      textColorStyles: c
    } = hu(ss(e, "color"));
    return Wn(() => {
      var f, d;
      const u = (f = r.default) == null ? void 0 : f.call(r);
      return u && (i.value = (d = K_(u).filter((h) => h.type === tk && h.children && typeof h.children == "string")[0]) == null ? void 0 : d.children), U(a.value.component, {
        tag: e.tag,
        icon: a.value.icon,
        class: ["v-icon", "notranslate", s.value, o.value, l.value, {
          "v-icon--clickable": !!n.onClick,
          "v-icon--start": e.start,
          "v-icon--end": e.end
        }, e.class],
        style: [o.value ? void 0 : {
          fontSize: Nt(e.size),
          height: Nt(e.size),
          width: Nt(e.size)
        }, c.value, e.style],
        role: n.onClick ? "button" : void 0,
        "aria-hidden": !n.onClick
      }, {
        default: () => [u]
      });
    }), {};
  }
});
function VN(e, t) {
  const n = oe(), r = gi(!1);
  if (q_) {
    const i = new IntersectionObserver((s) => {
      e == null || e(s, i), r.value = !!s.find((a) => a.isIntersecting);
    }, t);
    Kc(() => {
      i.disconnect();
    }), fe(n, (s, a) => {
      a && (i.unobserve(a), r.value = !1), s && i.observe(s);
    }, {
      flush: "post"
    });
  }
  return {
    intersectionRef: n,
    isIntersecting: r
  };
}
const _v = {
  center: "center",
  top: "bottom",
  bottom: "top",
  left: "right",
  right: "left"
}, HN = Ze({
  location: String
}, "location");
function WN(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, n = arguments.length > 2 ? arguments[2] : void 0;
  const {
    isRtl: r
  } = fu();
  return {
    locationStyles: T(() => {
      if (!e.location)
        return {};
      const {
        side: s,
        align: a
      } = aN(e.location.split(" ").length > 1 ? e.location : `${e.location} center`, r.value);
      function o(c) {
        return n ? n(c) : 0;
      }
      const l = {};
      return s !== "center" && (t ? l[_v[s]] = `calc(100% - ${o(s)}px)` : l[s] = 0), a !== "center" ? t ? l[_v[a]] = `calc(100% - ${o(a)}px)` : l[a] = 0 : (s === "center" ? l.top = l.left = "50%" : l[{
        top: "left",
        bottom: "left",
        left: "top",
        right: "top"
      }[s]] = "50%", l.transform = {
        top: "translateX(-50%)",
        bottom: "translateX(-50%)",
        left: "translateY(-50%)",
        right: "translateY(-50%)",
        center: "translate(-50%, -50%)"
      }[s]), l;
    })
  };
}
const UN = Ze({
  absolute: Boolean,
  active: {
    type: Boolean,
    default: !0
  },
  bgColor: String,
  bgOpacity: [Number, String],
  bufferValue: {
    type: [Number, String],
    default: 0
  },
  clickable: Boolean,
  color: String,
  height: {
    type: [Number, String],
    default: 4
  },
  indeterminate: Boolean,
  max: {
    type: [Number, String],
    default: 100
  },
  modelValue: {
    type: [Number, String],
    default: 0
  },
  reverse: Boolean,
  stream: Boolean,
  striped: Boolean,
  roundedBar: Boolean,
  ...pr(),
  ...HN({
    location: "top"
  }),
  ...fw(),
  ...rw(),
  ...du()
}, "VProgressLinear"), YN = sn()({
  name: "VProgressLinear",
  props: UN(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const r = wo(e, "modelValue"), {
      isRtl: i,
      rtlClasses: s
    } = fu(), {
      themeClasses: a
    } = _h(e), {
      locationStyles: o
    } = WN(e), {
      textColorClasses: l,
      textColorStyles: c
    } = hu(e, "color"), {
      backgroundColorClasses: u,
      backgroundColorStyles: f
    } = Ld(T(() => e.bgColor || e.color)), {
      backgroundColorClasses: d,
      backgroundColorStyles: h
    } = Ld(e, "color"), {
      roundedClasses: p
    } = dw(e), {
      intersectionRef: g,
      isIntersecting: v
    } = VN(), m = T(() => parseInt(e.max, 10)), x = T(() => parseInt(e.height, 10)), _ = T(() => parseFloat(e.bufferValue) / m.value * 100), y = T(() => parseFloat(r.value) / m.value * 100), b = T(() => i.value !== e.reverse), w = T(() => e.indeterminate ? "fade-transition" : "slide-x-transition"), E = T(() => e.bgOpacity == null ? e.bgOpacity : parseFloat(e.bgOpacity));
    function $(C) {
      if (!g.value)
        return;
      const {
        left: A,
        right: k,
        width: D
      } = g.value.getBoundingClientRect(), S = b.value ? D - C.clientX + (k - D) : C.clientX - A;
      r.value = Math.round(S / D * m.value);
    }
    return Wn(() => U(e.tag, {
      ref: g,
      class: ["v-progress-linear", {
        "v-progress-linear--absolute": e.absolute,
        "v-progress-linear--active": e.active && v.value,
        "v-progress-linear--reverse": b.value,
        "v-progress-linear--rounded": e.rounded,
        "v-progress-linear--rounded-bar": e.roundedBar,
        "v-progress-linear--striped": e.striped
      }, p.value, a.value, s.value, e.class],
      style: [{
        bottom: e.location === "bottom" ? 0 : void 0,
        top: e.location === "top" ? 0 : void 0,
        height: e.active ? Nt(x.value) : 0,
        "--v-progress-linear-height": Nt(x.value),
        ...o.value
      }, e.style],
      role: "progressbar",
      "aria-hidden": e.active ? "false" : "true",
      "aria-valuemin": "0",
      "aria-valuemax": e.max,
      "aria-valuenow": e.indeterminate ? void 0 : y.value,
      onClick: e.clickable && $
    }, {
      default: () => [e.stream && U("div", {
        key: "stream",
        class: ["v-progress-linear__stream", l.value],
        style: {
          ...c.value,
          [b.value ? "left" : "right"]: Nt(-x.value),
          borderTop: `${Nt(x.value / 2)} dotted`,
          opacity: E.value,
          top: `calc(50% - ${Nt(x.value / 4)})`,
          width: Nt(100 - _.value, "%"),
          "--v-progress-linear-stream-to": Nt(x.value * (b.value ? 1 : -1))
        }
      }, null), U("div", {
        class: ["v-progress-linear__background", u.value],
        style: [f.value, {
          opacity: E.value,
          width: Nt(e.stream ? _.value : 100, "%")
        }]
      }, null), U(Fs, {
        name: w.value
      }, {
        default: () => [e.indeterminate ? U("div", {
          class: "v-progress-linear__indeterminate"
        }, [["long", "short"].map((C) => U("div", {
          key: C,
          class: ["v-progress-linear__indeterminate", C, d.value],
          style: h.value
        }, null))]) : U("div", {
          class: ["v-progress-linear__determinate", d.value],
          style: [h.value, {
            width: Nt(y.value, "%")
          }]
        }, null)]
      }), n.default && U("div", {
        class: "v-progress-linear__content"
      }, [n.default({
        value: y.value,
        buffer: _.value
      })])]
    })), {};
  }
}), qN = Ze({
  loading: [Boolean, String]
}, "loader");
function GN(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Hs();
  return {
    loaderClasses: T(() => ({
      [`${t}--loading`]: e.loading
    }))
  };
}
function XN(e, t) {
  var r;
  let {
    slots: n
  } = t;
  return U("div", {
    class: `${e.name}__loader`
  }, [((r = n.default) == null ? void 0 : r.call(n, {
    color: e.color,
    isActive: e.active
  })) || U(YN, {
    absolute: e.absolute,
    active: e.active,
    color: e.color,
    height: "2",
    indeterminate: !0
  }, null)]);
}
const ZN = Ze({
  text: String,
  clickable: Boolean,
  ...pr(),
  ...du()
}, "VLabel"), KN = sn()({
  name: "VLabel",
  props: ZN(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return Wn(() => {
      var r;
      return U("label", {
        class: ["v-label", {
          "v-label--clickable": e.clickable
        }, e.class],
        style: e.style
      }, [e.text, (r = n.default) == null ? void 0 : r.call(n)]);
    }), {};
  }
});
function hw(e) {
  const {
    t
  } = AN();
  function n(r) {
    let {
      name: i
    } = r;
    const s = {
      prepend: "prependAction",
      prependInner: "prependAction",
      append: "appendAction",
      appendInner: "appendAction",
      clear: "clear"
    }[i], a = e[`onClick:${i}`], o = a && s ? t(`$vuetify.input.${s}`, e.label ?? "") : void 0;
    return U(zN, {
      icon: e[`${i}Icon`],
      "aria-label": o,
      onClick: a
    }, null);
  }
  return {
    InputIcon: n
  };
}
const JN = Ze({
  active: Boolean,
  color: String,
  messages: {
    type: [Array, String],
    default: () => []
  },
  ...pr(),
  ...ow({
    transition: {
      component: aw,
      leaveAbsolute: !0,
      group: !0
    }
  })
}, "VMessages"), QN = sn()({
  name: "VMessages",
  props: JN(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const r = T(() => Tl(e.messages)), {
      textColorClasses: i,
      textColorStyles: s
    } = hu(T(() => e.color));
    return Wn(() => U(lw, {
      transition: e.transition,
      tag: "div",
      class: ["v-messages", i.value, e.class],
      style: [s.value, e.style],
      role: "alert",
      "aria-live": "polite"
    }, {
      default: () => [e.active && r.value.map((a, o) => U("div", {
        class: "v-messages__message",
        key: `${o}-${r.value}`
      }, [n.message ? n.message({
        message: a
      }) : a]))]
    })), {};
  }
}), pw = Ze({
  focused: Boolean,
  "onUpdate:focused": cs()
}, "focus");
function gw(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Hs();
  const n = wo(e, "focused"), r = T(() => ({
    [`${t}--focused`]: n.value
  }));
  function i() {
    n.value = !0;
  }
  function s() {
    n.value = !1;
  }
  return {
    focusClasses: r,
    isFocused: n,
    focus: i,
    blur: s
  };
}
const vw = Symbol.for("vuetify:form"), eL = Ze({
  disabled: Boolean,
  fastFail: Boolean,
  readonly: Boolean,
  modelValue: {
    type: Boolean,
    default: null
  },
  validateOn: {
    type: String,
    default: "input"
  }
}, "form");
function tL(e) {
  const t = wo(e, "modelValue"), n = T(() => e.disabled), r = T(() => e.readonly), i = gi(!1), s = oe([]), a = oe([]);
  async function o() {
    const u = [];
    let f = !0;
    a.value = [], i.value = !0;
    for (const d of s.value) {
      const h = await d.validate();
      if (h.length > 0 && (f = !1, u.push({
        id: d.id,
        errorMessages: h
      })), !f && e.fastFail)
        break;
    }
    return a.value = u, i.value = !1, {
      valid: f,
      errors: a.value
    };
  }
  function l() {
    s.value.forEach((u) => u.reset());
  }
  function c() {
    s.value.forEach((u) => u.resetValidation());
  }
  return fe(s, () => {
    let u = 0, f = 0;
    const d = [];
    for (const h of s.value)
      h.isValid === !1 ? (f++, d.push({
        id: h.id,
        errorMessages: h.errorMessages
      })) : h.isValid === !0 && u++;
    a.value = d, t.value = f > 0 ? !1 : u === s.value.length ? !0 : null;
  }, {
    deep: !0
  }), $i(vw, {
    register: (u) => {
      let {
        id: f,
        validate: d,
        reset: h,
        resetValidation: p
      } = u;
      s.value.some((g) => g.id === f) && Ca(`Duplicate input name "${f}"`), s.value.push({
        id: f,
        validate: d,
        reset: h,
        resetValidation: p,
        isValid: null,
        errorMessages: []
      });
    },
    unregister: (u) => {
      s.value = s.value.filter((f) => f.id !== u);
    },
    update: (u, f, d) => {
      const h = s.value.find((p) => p.id === u);
      h && (h.isValid = f, h.errorMessages = d);
    },
    isDisabled: n,
    isReadonly: r,
    isValidating: i,
    isValid: t,
    items: s,
    validateOn: ss(e, "validateOn")
  }), {
    errors: a,
    isDisabled: n,
    isReadonly: r,
    isValidating: i,
    isValid: t,
    items: s,
    validate: o,
    reset: l,
    resetValidation: c
  };
}
function nL() {
  return ur(vw, null);
}
const rL = Ze({
  disabled: {
    type: Boolean,
    default: null
  },
  error: Boolean,
  errorMessages: {
    type: [Array, String],
    default: () => []
  },
  maxErrors: {
    type: [Number, String],
    default: 1
  },
  name: String,
  label: String,
  readonly: {
    type: Boolean,
    default: null
  },
  rules: {
    type: Array,
    default: () => []
  },
  modelValue: null,
  validateOn: String,
  validationValue: null,
  ...pw()
}, "validation");
function iL(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Hs(), n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : uu();
  const r = wo(e, "modelValue"), i = T(() => e.validationValue === void 0 ? r.value : e.validationValue), s = nL(), a = oe([]), o = gi(!0), l = T(() => !!(Tl(r.value === "" ? null : r.value).length || Tl(i.value === "" ? null : i.value).length)), c = T(() => !!(e.disabled ?? (s == null ? void 0 : s.isDisabled.value))), u = T(() => !!(e.readonly ?? (s == null ? void 0 : s.isReadonly.value))), f = T(() => {
    var y;
    return (y = e.errorMessages) != null && y.length ? Tl(e.errorMessages).concat(a.value).slice(0, Math.max(0, +e.maxErrors)) : a.value;
  }), d = T(() => {
    let y = (e.validateOn ?? (s == null ? void 0 : s.validateOn.value)) || "input";
    y === "lazy" && (y = "input lazy");
    const b = new Set((y == null ? void 0 : y.split(" ")) ?? []);
    return {
      blur: b.has("blur") || b.has("input"),
      input: b.has("input"),
      submit: b.has("submit"),
      lazy: b.has("lazy")
    };
  }), h = T(() => {
    var y;
    return e.error || (y = e.errorMessages) != null && y.length ? !1 : e.rules.length ? o.value ? a.value.length || d.value.lazy ? null : !0 : !a.value.length : !0;
  }), p = gi(!1), g = T(() => ({
    [`${t}--error`]: h.value === !1,
    [`${t}--dirty`]: l.value,
    [`${t}--disabled`]: c.value,
    [`${t}--readonly`]: u.value
  })), v = T(() => e.name ?? X(n));
  nk(() => {
    s == null || s.register({
      id: v.value,
      validate: _,
      reset: m,
      resetValidation: x
    });
  }), Kc(() => {
    s == null || s.unregister(v.value);
  }), ct(async () => {
    d.value.lazy || await _(!0), s == null || s.update(v.value, h.value, f.value);
  }), Nd(() => d.value.input, () => {
    fe(i, () => {
      if (i.value != null)
        _();
      else if (e.focused) {
        const y = fe(() => e.focused, (b) => {
          b || _(), y();
        });
      }
    });
  }), Nd(() => d.value.blur, () => {
    fe(() => e.focused, (y) => {
      y || _();
    });
  }), fe(h, () => {
    s == null || s.update(v.value, h.value, f.value);
  });
  function m() {
    r.value = null, un(x);
  }
  function x() {
    o.value = !0, d.value.lazy ? a.value = [] : _(!0);
  }
  async function _() {
    let y = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
    const b = [];
    p.value = !0;
    for (const w of e.rules) {
      if (b.length >= +(e.maxErrors ?? 1))
        break;
      const $ = await (typeof w == "function" ? w : () => w)(i.value);
      if ($ !== !0) {
        if ($ !== !1 && typeof $ != "string") {
          console.warn(`${$} is not a valid value. Rule functions must return boolean true or a string.`);
          continue;
        }
        b.push($ || "");
      }
    }
    return a.value = b, p.value = !1, o.value = y, a.value;
  }
  return {
    errorMessages: f,
    isDirty: l,
    isDisabled: c,
    isReadonly: u,
    isPristine: o,
    isValid: h,
    isValidating: p,
    reset: m,
    resetValidation: x,
    validate: _,
    validationClasses: g
  };
}
const mw = Ze({
  id: String,
  appendIcon: ui,
  centerAffix: {
    type: Boolean,
    default: !0
  },
  prependIcon: ui,
  hideDetails: [Boolean, String],
  hideSpinButtons: Boolean,
  hint: String,
  persistentHint: Boolean,
  messages: {
    type: [Array, String],
    default: () => []
  },
  direction: {
    type: String,
    default: "horizontal",
    validator: (e) => ["horizontal", "vertical"].includes(e)
  },
  "onClick:prepend": cs(),
  "onClick:append": cs(),
  ...pr(),
  ...MN(),
  ...rL()
}, "VInput"), wv = sn()({
  name: "VInput",
  props: {
    ...mw()
  },
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: r,
      emit: i
    } = t;
    const {
      densityClasses: s
    } = FN(e), {
      rtlClasses: a
    } = fu(), {
      InputIcon: o
    } = hw(e), l = uu(), c = T(() => e.id || `input-${l}`), u = T(() => `${c.value}-messages`), {
      errorMessages: f,
      isDirty: d,
      isDisabled: h,
      isReadonly: p,
      isPristine: g,
      isValid: v,
      isValidating: m,
      reset: x,
      resetValidation: _,
      validate: y,
      validationClasses: b
    } = iL(e, "v-input", c), w = T(() => ({
      id: c,
      messagesId: u,
      isDirty: d,
      isDisabled: h,
      isReadonly: p,
      isPristine: g,
      isValid: v,
      isValidating: m,
      reset: x,
      resetValidation: _,
      validate: y
    })), E = T(() => {
      var $;
      return ($ = e.errorMessages) != null && $.length || !g.value && f.value.length ? f.value : e.hint && (e.persistentHint || e.focused) ? e.hint : e.messages;
    });
    return Wn(() => {
      var D, S, L, P;
      const $ = !!(r.prepend || e.prependIcon), C = !!(r.append || e.appendIcon), A = E.value.length > 0, k = !e.hideDetails || e.hideDetails === "auto" && (A || !!r.details);
      return U("div", {
        class: ["v-input", `v-input--${e.direction}`, {
          "v-input--center-affix": e.centerAffix,
          "v-input--hide-spin-buttons": e.hideSpinButtons
        }, s.value, a.value, b.value, e.class],
        style: e.style
      }, [$ && U("div", {
        key: "prepend",
        class: "v-input__prepend"
      }, [(D = r.prepend) == null ? void 0 : D.call(r, w.value), e.prependIcon && U(o, {
        key: "prepend-icon",
        name: "prepend"
      }, null)]), r.default && U("div", {
        class: "v-input__control"
      }, [(S = r.default) == null ? void 0 : S.call(r, w.value)]), C && U("div", {
        key: "append",
        class: "v-input__append"
      }, [e.appendIcon && U(o, {
        key: "append-icon",
        name: "append"
      }, null), (L = r.append) == null ? void 0 : L.call(r, w.value)]), k && U("div", {
        class: "v-input__details"
      }, [U(QN, {
        id: u.value,
        active: A,
        messages: E.value
      }, {
        message: r.message
      }), (P = r.details) == null ? void 0 : P.call(r, w.value)])]);
    }), {
      reset: x,
      resetValidation: _,
      validate: y,
      isValid: v,
      errorMessages: f
    };
  }
}), Zu = Symbol("Forwarded refs");
function Ku(e, t) {
  let n = e;
  for (; n; ) {
    const r = Reflect.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = Object.getPrototypeOf(n);
  }
}
function yw(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  return e[Zu] = n, new Proxy(e, {
    get(i, s) {
      if (Reflect.has(i, s))
        return Reflect.get(i, s);
      if (!(typeof s == "symbol" || s.startsWith("$") || s.startsWith("__"))) {
        for (const a of n)
          if (a.value && Reflect.has(a.value, s)) {
            const o = Reflect.get(a.value, s);
            return typeof o == "function" ? o.bind(a.value) : o;
          }
      }
    },
    has(i, s) {
      if (Reflect.has(i, s))
        return !0;
      if (typeof s == "symbol" || s.startsWith("$") || s.startsWith("__"))
        return !1;
      for (const a of n)
        if (a.value && Reflect.has(a.value, s))
          return !0;
      return !1;
    },
    set(i, s, a) {
      if (Reflect.has(i, s))
        return Reflect.set(i, s, a);
      if (typeof s == "symbol" || s.startsWith("$") || s.startsWith("__"))
        return !1;
      for (const o of n)
        if (o.value && Reflect.has(o.value, s))
          return Reflect.set(o.value, s, a);
      return !1;
    },
    getOwnPropertyDescriptor(i, s) {
      var o;
      const a = Reflect.getOwnPropertyDescriptor(i, s);
      if (a)
        return a;
      if (!(typeof s == "symbol" || s.startsWith("$") || s.startsWith("__"))) {
        for (const l of n) {
          if (!l.value)
            continue;
          const c = Ku(l.value, s) ?? ("_" in l.value ? Ku((o = l.value._) == null ? void 0 : o.setupState, s) : void 0);
          if (c)
            return c;
        }
        for (const l of n) {
          const c = l.value && l.value[Zu];
          if (!c)
            continue;
          const u = c.slice();
          for (; u.length; ) {
            const f = u.shift(), d = Ku(f.value, s);
            if (d)
              return d;
            const h = f.value && f.value[Zu];
            h && u.push(...h);
          }
        }
      }
    }
  });
}
const sL = Ze({
  active: Boolean,
  max: [Number, String],
  value: {
    type: [Number, String],
    default: 0
  },
  ...pr(),
  ...ow({
    transition: {
      component: aw
    }
  })
}, "VCounter"), aL = sn()({
  name: "VCounter",
  functional: !0,
  props: sL(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const r = T(() => e.max ? `${e.value} / ${e.max}` : String(e.value));
    return Wn(() => U(lw, {
      transition: e.transition
    }, {
      default: () => [ds(U("div", {
        class: ["v-counter", e.class],
        style: e.style
      }, [n.default ? n.default({
        counter: r.value,
        max: e.max,
        value: e.value
      }) : r.value]), [[vb, e.active]])]
    })), {};
  }
}), oL = Ze({
  floating: Boolean,
  ...pr()
}, "VFieldLabel"), Yo = sn()({
  name: "VFieldLabel",
  props: oL(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return Wn(() => U(KN, {
      class: ["v-field-label", {
        "v-field-label--floating": e.floating
      }, e.class],
      style: e.style,
      "aria-hidden": e.floating || void 0
    }, n)), {};
  }
}), lL = ["underlined", "outlined", "filled", "solo", "solo-inverted", "solo-filled", "plain"], xw = Ze({
  appendInnerIcon: ui,
  bgColor: String,
  clearable: Boolean,
  clearIcon: {
    type: ui,
    default: "$clear"
  },
  active: Boolean,
  centerAffix: {
    type: Boolean,
    default: void 0
  },
  color: String,
  baseColor: String,
  dirty: Boolean,
  disabled: {
    type: Boolean,
    default: null
  },
  error: Boolean,
  flat: Boolean,
  label: String,
  persistentClear: Boolean,
  prependInnerIcon: ui,
  reverse: Boolean,
  singleLine: Boolean,
  variant: {
    type: String,
    default: "filled",
    validator: (e) => lL.includes(e)
  },
  "onClick:clear": cs(),
  "onClick:appendInner": cs(),
  "onClick:prependInner": cs(),
  ...pr(),
  ...qN(),
  ...fw(),
  ...du()
}, "VField"), bw = sn()({
  name: "VField",
  inheritAttrs: !1,
  props: {
    id: String,
    ...pw(),
    ...xw()
  },
  emits: {
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: r,
      slots: i
    } = t;
    const {
      themeClasses: s
    } = _h(e), {
      loaderClasses: a
    } = GN(e), {
      focusClasses: o,
      isFocused: l,
      focus: c,
      blur: u
    } = gw(e), {
      InputIcon: f
    } = hw(e), {
      roundedClasses: d
    } = dw(e), {
      rtlClasses: h
    } = fu(), p = T(() => e.dirty || e.active), g = T(() => !e.singleLine && !!(e.label || i.label)), v = uu(), m = T(() => e.id || `input-${v}`), x = T(() => `${m.value}-messages`), _ = oe(), y = oe(), b = oe(), w = T(() => ["plain", "underlined"].includes(e.variant)), {
      backgroundColorClasses: E,
      backgroundColorStyles: $
    } = Ld(ss(e, "bgColor")), {
      textColorClasses: C,
      textColorStyles: A
    } = hu(T(() => e.error || e.disabled ? void 0 : p.value && l.value ? e.color : e.baseColor));
    fe(p, (S) => {
      if (g.value) {
        const L = _.value.$el, P = y.value.$el;
        requestAnimationFrame(() => {
          const H = oN(L), M = P.getBoundingClientRect(), B = M.x - H.x, W = M.y - H.y - (H.height / 2 - M.height / 2), R = M.width / 0.75, O = Math.abs(R - H.width) > 1 ? {
            maxWidth: Nt(R)
          } : void 0, N = getComputedStyle(L), z = getComputedStyle(P), I = parseFloat(N.transitionDuration) * 1e3 || 150, te = parseFloat(z.getPropertyValue("--v-field-label-scale")), ee = z.getPropertyValue("color");
          L.style.visibility = "visible", P.style.visibility = "hidden", lN(L, {
            transform: `translate(${B}px, ${W}px) scale(${te})`,
            color: ee,
            ...O
          }, {
            duration: I,
            easing: $N,
            direction: S ? "normal" : "reverse"
          }).finished.then(() => {
            L.style.removeProperty("visibility"), P.style.removeProperty("visibility");
          });
        });
      }
    }, {
      flush: "post"
    });
    const k = T(() => ({
      isActive: p,
      isFocused: l,
      controlRef: b,
      blur: u,
      focus: c
    }));
    function D(S) {
      S.target !== document.activeElement && S.preventDefault();
    }
    return Wn(() => {
      var B, W, R;
      const S = e.variant === "outlined", L = i["prepend-inner"] || e.prependInnerIcon, P = !!(e.clearable || i.clear), H = !!(i["append-inner"] || e.appendInnerIcon || P), M = () => i.label ? i.label({
        ...k.value,
        label: e.label,
        props: {
          for: m.value
        }
      }) : e.label;
      return U("div", Gt({
        class: ["v-field", {
          "v-field--active": p.value,
          "v-field--appended": H,
          "v-field--center-affix": e.centerAffix ?? !w.value,
          "v-field--disabled": e.disabled,
          "v-field--dirty": e.dirty,
          "v-field--error": e.error,
          "v-field--flat": e.flat,
          "v-field--has-background": !!e.bgColor,
          "v-field--persistent-clear": e.persistentClear,
          "v-field--prepended": L,
          "v-field--reverse": e.reverse,
          "v-field--single-line": e.singleLine,
          "v-field--no-label": !M(),
          [`v-field--variant-${e.variant}`]: !0
        }, s.value, E.value, o.value, a.value, d.value, h.value, e.class],
        style: [$.value, e.style],
        onClick: D
      }, n), [U("div", {
        class: "v-field__overlay"
      }, null), U(XN, {
        name: "v-field",
        active: !!e.loading,
        color: e.error ? "error" : typeof e.loading == "string" ? e.loading : e.color
      }, {
        default: i.loader
      }), L && U("div", {
        key: "prepend",
        class: "v-field__prepend-inner"
      }, [e.prependInnerIcon && U(f, {
        key: "prepend-icon",
        name: "prependInner"
      }, null), (B = i["prepend-inner"]) == null ? void 0 : B.call(i, k.value)]), U("div", {
        class: "v-field__field",
        "data-no-activator": ""
      }, [["filled", "solo", "solo-inverted", "solo-filled"].includes(e.variant) && g.value && U(Yo, {
        key: "floating-label",
        ref: y,
        class: [C.value],
        floating: !0,
        for: m.value,
        style: A.value
      }, {
        default: () => [M()]
      }), U(Yo, {
        ref: _,
        for: m.value
      }, {
        default: () => [M()]
      }), (W = i.default) == null ? void 0 : W.call(i, {
        ...k.value,
        props: {
          id: m.value,
          class: "v-field__input",
          "aria-describedby": x.value
        },
        focus: c,
        blur: u
      })]), P && U(CN, {
        key: "clear"
      }, {
        default: () => [ds(U("div", {
          class: "v-field__clearable",
          onMousedown: (O) => {
            O.preventDefault(), O.stopPropagation();
          }
        }, [i.clear ? i.clear() : U(f, {
          name: "clear"
        }, null)]), [[vb, e.dirty]])]
      }), H && U("div", {
        key: "append",
        class: "v-field__append-inner"
      }, [(R = i["append-inner"]) == null ? void 0 : R.call(i, k.value), e.appendInnerIcon && U(f, {
        key: "append-icon",
        name: "appendInner"
      }, null)]), U("div", {
        class: ["v-field__outline", C.value],
        style: A.value
      }, [S && U(Ie, null, [U("div", {
        class: "v-field__outline__start"
      }, null), g.value && U("div", {
        class: "v-field__outline__notch"
      }, [U(Yo, {
        ref: y,
        floating: !0,
        for: m.value
      }, {
        default: () => [M()]
      })]), U("div", {
        class: "v-field__outline__end"
      }, null)]), w.value && g.value && U(Yo, {
        ref: y,
        floating: !0,
        for: m.value
      }, {
        default: () => [M()]
      })])]);
    }), {
      controlRef: b
    };
  }
});
function cL(e) {
  const t = Object.keys(bw.props).filter((n) => !J6(n) && n !== "class" && n !== "style");
  return G_(e, t);
}
const uL = Ze({
  ...pr(),
  ...eL()
}, "VForm"), fL = sn()({
  name: "VForm",
  props: uL(),
  emits: {
    "update:modelValue": (e) => !0,
    submit: (e) => !0
  },
  setup(e, t) {
    let {
      slots: n,
      emit: r
    } = t;
    const i = tL(e), s = oe();
    function a(l) {
      l.preventDefault(), i.reset();
    }
    function o(l) {
      const c = l, u = i.validate();
      c.then = u.then.bind(u), c.catch = u.catch.bind(u), c.finally = u.finally.bind(u), r("submit", c), c.defaultPrevented || u.then((f) => {
        var h;
        let {
          valid: d
        } = f;
        d && ((h = s.value) == null || h.submit());
      }), c.preventDefault();
    }
    return Wn(() => {
      var l;
      return U("form", {
        ref: s,
        class: ["v-form", e.class],
        style: e.style,
        novalidate: !0,
        onReset: a,
        onSubmit: o
      }, [(l = n.default) == null ? void 0 : l.call(n, i)]);
    }), yw(i, s);
  }
}), dL = Ze({
  autoGrow: Boolean,
  autofocus: Boolean,
  counter: [Boolean, Number, String],
  counterValue: Function,
  prefix: String,
  placeholder: String,
  persistentPlaceholder: Boolean,
  persistentCounter: Boolean,
  noResize: Boolean,
  rows: {
    type: [Number, String],
    default: 5,
    validator: (e) => !isNaN(parseFloat(e))
  },
  maxRows: {
    type: [Number, String],
    validator: (e) => !isNaN(parseFloat(e))
  },
  suffix: String,
  modelModifiers: Object,
  ...mw(),
  ...xw()
}, "VTextarea"), $v = sn()({
  name: "VTextarea",
  directives: {
    Intersect: TN
  },
  inheritAttrs: !1,
  props: dL(),
  emits: {
    "click:control": (e) => !0,
    "mousedown:control": (e) => !0,
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: r,
      slots: i
    } = t;
    const s = wo(e, "modelValue"), {
      isFocused: a,
      focus: o,
      blur: l
    } = gw(e), c = T(() => typeof e.counterValue == "function" ? e.counterValue(s.value) : (s.value || "").toString().length), u = T(() => {
      if (n.maxlength)
        return n.maxlength;
      if (!(!e.counter || typeof e.counter != "number" && typeof e.counter != "string"))
        return e.counter;
    });
    function f(k, D) {
      var S, L;
      !e.autofocus || !k || (L = (S = D[0].target) == null ? void 0 : S.focus) == null || L.call(S);
    }
    const d = oe(), h = oe(), p = gi(""), g = oe(), v = T(() => e.persistentPlaceholder || a.value || e.active);
    function m() {
      var k;
      g.value !== document.activeElement && ((k = g.value) == null || k.focus()), a.value || o();
    }
    function x(k) {
      m(), r("click:control", k);
    }
    function _(k) {
      r("mousedown:control", k);
    }
    function y(k) {
      k.stopPropagation(), m(), un(() => {
        s.value = "", rN(e["onClick:clear"], k);
      });
    }
    function b(k) {
      var S;
      const D = k.target;
      if (s.value = D.value, (S = e.modelModifiers) != null && S.trim) {
        const L = [D.selectionStart, D.selectionEnd];
        un(() => {
          D.selectionStart = L[0], D.selectionEnd = L[1];
        });
      }
    }
    const w = oe(), E = oe(+e.rows), $ = T(() => ["plain", "underlined"].includes(e.variant));
    Zc(() => {
      e.autoGrow || (E.value = +e.rows);
    });
    function C() {
      e.autoGrow && un(() => {
        if (!w.value || !h.value)
          return;
        const k = getComputedStyle(w.value), D = getComputedStyle(h.value.$el), S = parseFloat(k.getPropertyValue("--v-field-padding-top")) + parseFloat(k.getPropertyValue("--v-input-padding-top")) + parseFloat(k.getPropertyValue("--v-field-padding-bottom")), L = w.value.scrollHeight, P = parseFloat(k.lineHeight), H = Math.max(parseFloat(e.rows) * P + S, parseFloat(D.getPropertyValue("--v-input-control-height"))), M = parseFloat(e.maxRows) * P + S || 1 / 0, B = tN(L ?? 0, H, M);
        E.value = Math.floor((B - S) / P), p.value = Nt(B);
      });
    }
    ct(C), fe(s, C), fe(() => e.rows, C), fe(() => e.maxRows, C), fe(() => e.density, C);
    let A;
    return fe(w, (k) => {
      k ? (A = new ResizeObserver(C), A.observe(w.value)) : A == null || A.disconnect();
    }), Kc(() => {
      A == null || A.disconnect();
    }), Wn(() => {
      const k = !!(i.counter || e.counter || e.counterValue), D = !!(k || i.details), [S, L] = eN(n), {
        modelValue: P,
        ...H
      } = wv.filterProps(e), M = cL(e);
      return U(wv, Gt({
        ref: d,
        modelValue: s.value,
        "onUpdate:modelValue": (B) => s.value = B,
        class: ["v-textarea v-text-field", {
          "v-textarea--prefixed": e.prefix,
          "v-textarea--suffixed": e.suffix,
          "v-text-field--prefixed": e.prefix,
          "v-text-field--suffixed": e.suffix,
          "v-textarea--auto-grow": e.autoGrow,
          "v-textarea--no-resize": e.noResize || e.autoGrow,
          "v-input--plain-underlined": $.value
        }, e.class],
        style: e.style
      }, S, H, {
        centerAffix: E.value === 1 && !$.value,
        focused: a.value
      }), {
        ...i,
        default: (B) => {
          let {
            id: W,
            isDisabled: R,
            isDirty: O,
            isReadonly: N,
            isValid: z
          } = B;
          return U(bw, Gt({
            ref: h,
            style: {
              "--v-textarea-control-height": p.value
            },
            onClick: x,
            onMousedown: _,
            "onClick:clear": y,
            "onClick:prependInner": e["onClick:prependInner"],
            "onClick:appendInner": e["onClick:appendInner"]
          }, M, {
            id: W.value,
            active: v.value || O.value,
            centerAffix: E.value === 1 && !$.value,
            dirty: O.value || e.dirty,
            disabled: R.value,
            focused: a.value,
            error: z.value === !1
          }), {
            ...i,
            default: (I) => {
              let {
                props: {
                  class: te,
                  ...ee
                }
              } = I;
              return U(Ie, null, [e.prefix && U("span", {
                class: "v-text-field__prefix"
              }, [e.prefix]), ds(U("textarea", Gt({
                ref: g,
                class: te,
                value: s.value,
                onInput: b,
                autofocus: e.autofocus,
                readonly: N.value,
                disabled: R.value,
                placeholder: e.placeholder,
                rows: e.rows,
                name: e.name,
                onFocus: m,
                onBlur: l
              }, ee, L), null), [[pb("intersect"), {
                handler: f
              }, null, {
                once: !0
              }]]), e.autoGrow && ds(U("textarea", {
                class: [te, "v-textarea__sizer"],
                id: `${ee.id}-sizer`,
                "onUpdate:modelValue": (_e) => s.value = _e,
                ref: w,
                readonly: !0,
                "aria-hidden": "true"
              }, null), [[rk, s.value]]), e.suffix && U("span", {
                class: "v-text-field__suffix"
              }, [e.suffix])]);
            }
          });
        },
        details: D ? (B) => {
          var W;
          return U(Ie, null, [(W = i.details) == null ? void 0 : W.call(i, B), k && U(Ie, null, [U("span", null, null), U(aL, {
            active: e.persistentCounter || a.value,
            value: c.value,
            max: u.value
          }, i.counter)])]);
        } : void 0
      });
    }), yw({}, d, h, g);
  }
}), hL = /* @__PURE__ */ be({
  __name: "form",
  props: {
    modelValue: {
      type: Boolean,
      required: !1,
      default: !1
    },
    loading: {
      type: Boolean,
      required: !1,
      default: !1
    },
    readonly: {
      type: Boolean,
      required: !1,
      default: !1
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    lazyValidation: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  emits: {
    "update:modelValue": (e) => !0,
    submit: () => !0
  },
  setup(e, { expose: t, emit: n }) {
    const r = e, i = n;
    t({
      valid: T(() => a.valid),
      validate: (...u) => c(...u)
    });
    const s = oe(), a = Oe({
      valid: r.lazyValidation
    });
    ct(() => {
      un(() => {
        r.lazyValidation && o(!0);
      });
    });
    const o = (u) => {
      a.valid = u !== !1, i("update:modelValue", a.valid);
    }, l = async () => {
      var f;
      let u = await ((f = s.value) == null ? void 0 : f.validate());
      u && u.valid && i("submit");
    }, c = async (u, f) => {
      var h;
      let d = await ((h = s.value) == null ? void 0 : h.validate());
      d && (d.valid ? u() : f && f(d.errors));
    };
    return (u, f) => (j(), G("div", {
      style: et([{ transition: ".25s" }, `opacity: ${e.loading ? 0.5 : 1}`])
    }, [
      U(X(fL), {
        ref_key: "checkform",
        ref: s,
        readonly: e.readonly,
        disabled: e.disabled || e.loading,
        "onUpdate:modelValue": o,
        onSubmit: U0(l, ["stop", "prevent"])
      }, {
        default: pe(() => [
          Ee(u.$slots, "default", {
            valid: a.valid,
            validate: c
          })
        ]),
        _: 3
      }, 8, ["readonly", "disabled"])
    ], 4));
  }
}), pL = /* @__PURE__ */ be({
  __name: "skeleton",
  props: {
    width: {
      type: String,
      required: !1,
      default: () => "100%"
    },
    height: {
      type: String,
      required: !1,
      default: () => "100%"
    },
    avatar: {
      type: Boolean,
      default: () => !1
    }
  },
  setup(e) {
    const t = e, n = T(() => {
      const r = new za();
      return r.set("borderRadius", t.avatar ? "100em" : "8px"), r.set("width", t.width), r.set("height", t.height), r.join();
    });
    return (r, i) => (j(), G("div", {
      class: "component-skeleton",
      style: et(n.value)
    }, null, 4));
  }
}), wh = /* @__PURE__ */ Sn(pL, [["__scopeId", "data-v-085bd51c"]]), gL = /* @__PURE__ */ be({
  __name: "img",
  props: {
    skeleton: {
      type: String,
      required: !1,
      default: () => "auto"
    },
    width: {
      type: String,
      required: !1,
      default: () => null
    },
    loading: {
      type: Boolean,
      required: !1,
      default: () => !1
    },
    minWidth: {
      type: String,
      required: !1,
      default: () => null
    },
    maxWidth: {
      type: String,
      required: !1,
      default: () => null
    },
    height: {
      type: String,
      required: !1,
      default: () => null
    },
    minHeight: {
      type: String,
      required: !1,
      default: () => null
    },
    maxHeight: {
      type: String,
      required: !1,
      default: () => null
    },
    radius: {
      type: String,
      required: !1,
      default: () => null
    },
    avatar: {
      type: Boolean,
      default: () => !1
    },
    cover: {
      type: Boolean,
      default: () => !0
    },
    src: {
      type: null,
      required: !1,
      default: () => ""
    },
    block: {
      type: Boolean,
      required: !1,
      default: () => !1
    },
    ratio: {
      type: Boolean,
      required: !1,
      default: () => !1
    },
    square: {
      type: Boolean,
      required: !1,
      default: () => !1
    }
  },
  emits: {
    onClick: () => !0
  },
  setup(e, { emit: t }) {
    const { notFoundImage: n, staticUrl: r } = Lhe(), i = _o(), s = new Jc({
      concurrentExecutions: 1
    }), a = new Qc({
      delay: 100
    }), o = new ak({
      def: (b) => `${r}/${b}`
    }), l = o.url(typeof n == "function" ? n() : n), c = e, u = t, f = oe(), d = oe(), h = oe(), p = Oe({
      src: "",
      style: "",
      image: null,
      loading: !0,
      elementListenerGroup: null
    }), g = T(() => {
      let b = new za();
      return b.set("width", c.width, "100%"), b.set("height", c.square ? c.width : c.height, "200px"), b.set("maxWidth", c.maxWidth), b.set("maxHeight", c.maxHeight), b.set("overflow", "hidden"), b.set("borderRadius", c.radius), b.set("display", c.block ? "block" : "inline-block"), b.join();
    });
    fe(() => c.src, () => x());
    const v = [];
    for (let b = 0; b < 3; b++) {
      const E = $b([f, d, h][b], ([{ isIntersecting: $ }]) => {
        $ && (x(), v.forEach((C) => C.stop()));
      }, {
        immediate: !0
      });
      v.push(E);
    }
    ct(() => {
      p.elementListenerGroup = new eu(window), p.elementListenerGroup.add("resize", () => a.input("")), a.on("trigger", () => {
        var b, w;
        _((b = p.image) == null ? void 0 : b.width, (w = p.image) == null ? void 0 : w.height);
      });
    }), zt(() => {
      a.close(), p.elementListenerGroup && p.elementListenerGroup.clear();
    });
    const m = () => {
      u("onClick");
    }, x = () => {
      s.push("update", () => new Promise((b) => {
        p.image = new Image();
        let w = c.src ? o.url(c.src) : l;
        p.image.addEventListener("error", () => {
          p.src = l, p.loading = !1, _(300, 200), b(null);
        }), p.image.addEventListener("load", () => {
          var E, $;
          p.src = w, p.loading = !1, _((E = p.image) == null ? void 0 : E.width, ($ = p.image) == null ? void 0 : $.height), b(null);
        }), p.image.src = w;
      }));
    }, _ = (b, w) => {
      let E = new za();
      E.set("width", c.width, `${b}px`), E.set("maxWidth", c.maxWidth), E.set("minWidth", c.minWidth), E.set("height", c.height), E.set("maxHeight", c.maxHeight), E.set("minHeight", c.minHeight), E.set("borderRadius", c.radius), c.cover && E.set("backgroundSize", "cover"), c.height == null && E.set("height", `${w}px`), c.avatar && E.set("borderRadius", "1000em"), c.block && E.set("display", "block"), p.src && E.set("backgroundImage", `url('${p.src}')`), p.style = E.join(), c.square && i.nextTick(() => {
        let $ = y();
        $ && (E.set("height", `${$}px`), p.style = E.join());
      }), c.ratio && i.nextTick(() => {
        let $ = y();
        if (w && b) {
          let C = $ / b;
          E.set("height", `${w * C}px`), p.style = E.join();
        }
      });
    }, y = () => {
      var b, w;
      return ((b = d.value) == null ? void 0 : b.clientWidth) || ((w = f.value) == null ? void 0 : w.clientWidth) || 0;
    };
    return (b, w) => e.skeleton === "always" || p.loading ? (j(), G("div", {
      key: 0,
      ref_key: "wrapper3",
      ref: h,
      style: et(g.value)
    }, [
      e.skeleton !== "hide" ? (j(), ke(wh, {
        key: 0,
        avatar: e.avatar
      }, null, 8, ["avatar"])) : ve("", !0)
    ], 4)) : X(i).hasListener("click") ? (j(), G("div", {
      key: 1,
      ref_key: "wrapper",
      ref: f,
      style: et([{ cursor: "pointer" }, p.style]),
      class: "component-img-basic",
      onClick: m
    }, [
      Ee(b.$slots, "default", {}, void 0, !0),
      U(xs, { "model-value": e.loading }, null, 8, ["model-value"])
    ], 4)) : (j(), G("div", {
      key: 2,
      ref_key: "wrapper2",
      ref: d,
      class: "component-img-basic",
      style: et(p.style)
    }, [
      Ee(b.$slots, "default", {}, void 0, !0),
      U(xs, { "model-value": e.loading }, null, 8, ["model-value"])
    ], 4));
  }
}), vL = /* @__PURE__ */ Sn(gL, [["__scopeId", "data-v-f2bfbc93"]]), mL = /* @__PURE__ */ be({
  __name: "link",
  props: {
    to: {
      type: null,
      required: !0
    },
    target: {
      type: String,
      required: !1,
      default: () => "_self"
    },
    inline: {
      type: Boolean,
      default: !1
    },
    useClick: {
      type: Boolean,
      default: !1
    },
    disabled: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const n = e, r = t, i = T(() => typeof n.to == "string" ? Va.headMatch(n.to, "http") : !1), s = T(() => !(n.disabled || n.useClick || i.value)), a = T(() => {
      const o = {
        style: {
          color: "rgba(var(--v-theme-on-surface), var(--v-high-emphasis-opacity))"
        },
        target: n.target,
        class: {
          "ng-link": !0,
          "d-block": !n.inline,
          "d-inline": n.inline
        }
      };
      return n.disabled ? o : (o.onClick = (l) => {
        l.stopPropagation();
      }, n.useClick ? (o.onClick = (l) => {
        l.stopPropagation(), r("click");
      }, o) : i.value ? (o.href = n.to, o) : (o.to = n.to, o));
    });
    return (o, l) => {
      const c = ge("RouterLink");
      return s.value ? (j(), ke(c, Xl(Gt({ key: 0 }, a.value)), {
        default: pe(() => [
          Ee(o.$slots, "default", {}, void 0, !0)
        ]),
        _: 3
      }, 16)) : (j(), G("a", Xl(Gt({ key: 1 }, a.value)), [
        Ee(o.$slots, "default", {}, void 0, !0)
      ], 16));
    };
  }
}), yL = /* @__PURE__ */ Sn(mL, [["__scopeId", "data-v-a4e972e6"]]), xL = /* @__PURE__ */ be({
  __name: "loaders",
  props: {
    autoStart: {
      required: !1,
      type: Boolean,
      default: () => !0
    },
    items: {
      required: !0,
      type: Array
    }
  },
  setup(e) {
    const t = e, n = Oe({
      int: null,
      error: void 0,
      errorName: "",
      called: !1,
      loading: !0,
      started: !1
    });
    ct(() => {
      setTimeout(() => i(), 10), n.int = setInterval(() => i(), 500), t.autoStart && r();
    }), zt(() => {
      n.int && clearInterval(n.int);
    });
    const r = async () => {
      for (let s of t.items)
        s.called === !1 && await s.start({});
    }, i = () => {
      let s, a = "", o = !1, l = !1, c = t.items || [];
      for (let u of c)
        if (u.called) {
          o = !0;
          break;
        }
      for (let u of c)
        if (u.loading) {
          l = !0;
          break;
        }
      for (let u of c)
        if (u.fail) {
          s = u.fail.error, a = `Loader: ${u.fail.name}`;
          break;
        }
      n.error = s, n.called = o, n.loading = l, n.errorName = a, n.started = !0;
    };
    return (s, a) => (j(), G("div", null, [
      Ee(s.$slots, "default", {
        errorName: n.errorName,
        loading: n.loading,
        error: n.error
      })
    ]));
  }
});
class _w extends Lt {
  constructor(n, r) {
    var i, s, a;
    super();
    V(this, "id");
    V(this, "icon");
    V(this, "aMap");
    V(this, "aMapMarker");
    V(this, "googleMap");
    V(this, "googleMarker");
    V(this, "googleInfowindow");
    this.id = r.id || Lr.createUuid(), this.icon = r.icon, n instanceof Xa && (this.googleMap = n, this.googleInfowindow = new google.maps.InfoWindow({
      content: r.content
    }), this.googleMarker = new google.maps.Marker({
      map: this.googleMap.map,
      icon: this.icon,
      animation: google.maps.Animation.DROP,
      position: r.position
    }), this.googleMarker.addListener("click", () => {
      this.emit("click", this.getPosition());
    }), r.content && ((s = this.googleInfowindow) == null || s.open({
      map: (i = this.googleMap) == null ? void 0 : i.map,
      anchor: this.googleMarker
    }))), n instanceof gu && (this.aMap = n, this.aMap.map && (this.aMapMarker = new AMap.Marker({
      icon: this.icon || "https://a.amap.com/jsapi_demos/static/demo-center/icons/poi-marker-default.png",
      anchor: "bottom-center",
      position: new AMap.LngLat(r.position.lng, r.position.lat)
    }), r.content && this.aMapMarker.setLabel({
      content: r.content,
      offset: new AMap.Pixel(0, 42),
      direction: "center"
    }), this.aMapMarker.setMap(this.aMap.map), this.aMapMarker.on("click", () => {
      this.emit("click", this.getPosition());
    }))), (a = r.onload) == null || a.call(r, this);
  }
  getInMapMarkers() {
    return this.googleMap ? this.googleMap.markers.slice() : this.aMap ? this.aMap.markers.slice() : [];
  }
  hideLabel() {
    this.googleInfowindow && this.googleInfowindow.close(), this.aMapMarker && this.aMapMarker.setLabel({
      content: "",
      offset: new AMap.Pixel(0, 0),
      direction: "center"
    });
  }
  hasLabel() {
    return this.googleInfowindow ? !!this.googleInfowindow.getAnchor() : this.aMapMarker ? !!this.aMapMarker.getLabel().content : !1;
  }
  setLabel(n) {
    var r, i, s;
    this.googleMarker && ((i = this.googleInfowindow) == null || i.open((r = this.googleMap) == null ? void 0 : r.map, this.googleMarker), (s = this.googleInfowindow) == null || s.setContent(n)), this.aMapMarker && this.aMapMarker.setLabel({
      content: n,
      offset: new AMap.Pixel(0, 42),
      direction: "center"
    });
  }
  remove() {
    this.googleMarker && (this.googleMarker.setMap(null), this.googleMap && (this.googleMap.markers = this.googleMap.markers.filter((n) => n.id !== this.id))), this.aMapMarker && (this.aMapMarker.setMap(null), this.aMap && (this.aMap.markers = this.aMap.markers.filter((n) => n.id !== this.id)));
  }
  moveTo(n) {
    this.googleMarker && this.googleMarker.setPosition(n), this.aMapMarker && this.aMapMarker.setPosition([
      n.lng,
      n.lat
    ]);
  }
  getPosition() {
    const n = {
      lat: 0,
      lng: 0
    };
    if (this.googleMarker) {
      let r = this.googleMarker.getPosition();
      r && (n.lat = r.lat(), n.lng = r.lng());
    }
    if (this.aMapMarker) {
      let r = this.aMapMarker.getPosition();
      r && (n.lat = r.getLat(), n.lng = r.getLng());
    }
    return n;
  }
}
const bL = {
  libName: "nextgen-front-lib"
}, yn = new mb(bL.libName), _L = yn.checkout("GoogleMap");
function wL() {
  var t;
  if (!((t = Ye().__ng_state.gmap) != null && t.installed))
    throw _L.create("google map not installed.");
}
class Xa extends Lt {
  constructor() {
    super();
    V(this, "map");
    V(this, "routes", []);
    V(this, "markers", []);
    wL();
  }
  static getNavigationUrl(n) {
    let { startName: r, startLng: i, startLat: s, endName: a, endLng: o, endLat: l } = n, c = `https://www.google.com/maps/dir/?api=1&origin=${s},${i}&destination=${l},${o}&travelmode=driving`;
    return r && (c += `&origin_place_id=${encodeURIComponent(r)}`), a && (c += `&destination_place_id=${encodeURIComponent(a)}`), c;
  }
  static async install(n) {
    const r = Ye();
    r.__ng_state.gmap == null && (r.__ng_state.gmap = {
      installed: !1
    }), r.__ng_state.gmap.installed === !1 && (r.__ng_state.gmap.installed = !0, await new Promise((i, s) => {
      r.initGoogleMap = () => i(null), Ps.importScript(`https://maps.googleapis.com/maps/api/js?key=${n.apiKey}&callback=initGoogleMap`).catch(s);
    }));
  }
  static isInstalled() {
    var r;
    return !!((r = Ye().__ng_state.gmap) != null && r.installed);
  }
  start(n, r) {
    this.map == null && (this.map = new google.maps.Map(n, {
      zoom: r.zoom || 15,
      center: r.center || { lat: 0, lng: 0 }
    }), this.map.setOptions({
      disableDefaultUI: !0
    }), this.map.addListener("click", (i) => {
      var s, a;
      this.emit("click", {
        lat: ((s = i.latLng) == null ? void 0 : s.lat()) || 0,
        lng: ((a = i.latLng) == null ? void 0 : a.lng()) || 0
      });
    }), this.map.addListener("center_changed", () => {
      var i, s;
      this.map && this.emit("move", {
        lat: ((i = this.map.getCenter()) == null ? void 0 : i.lat()) || 0,
        lng: ((s = this.map.getCenter()) == null ? void 0 : s.lng()) || 0
      });
    }));
  }
  moveTo(n) {
    var r;
    (r = this.map) == null || r.moveCamera({
      center: n,
      zoom: this.map.getZoom()
    });
  }
  zoomTo(n) {
    var r;
    (r = this.map) == null || r.moveCamera({
      zoom: n
    });
  }
  close() {
    this.removeAllRoute(), this.removeAllMarker(), this.map && (this.map = void 0);
  }
  fitView() {
    if (this.map) {
      const n = new google.maps.LatLngBounds();
      for (let r of this.markers)
        n.extend(r.getPosition());
      this.map.fitBounds(n);
    }
  }
  // =================
  //
  // Marker
  //
  addMarker(n) {
    const r = new _w(this, n);
    return this.markers.push(r), r.on("click", () => {
      this.emit("clickMarker", r);
    }), r;
  }
  removeAllMarker() {
    this.markers.forEach((n) => n.remove()), this.markers = [];
  }
  reloadMarkers(n) {
    this.markers.filter((r) => !n.find((i) => i.id === r.id)).forEach((r) => r.remove()), n.forEach((r) => {
      const i = this.markers.find((s) => s.id === r.id);
      i ? i.moveTo(r.position) : this.addMarker(r);
    });
  }
  // =================
  //
  // Route
  //
  addRoute(n) {
    const r = new ww(this, n);
    return this.routes.push(r), r;
  }
  removeAllRoute() {
    this.routes.forEach((n) => n.remove()), this.routes = [];
  }
  reloadRoutes(n) {
    this.routes.filter((r) => !n.find((i) => i.id === r.id)).forEach((r) => r.remove()), n.forEach((r) => {
      let i = this.routes.find((s) => s.id === r.id);
      i ? i.update(r) : this.addRoute(r);
    });
  }
}
class ww extends Lt {
  constructor(n, r) {
    super();
    V(this, "id");
    V(this, "aMap");
    V(this, "aMapDriving");
    V(this, "googleMap");
    V(this, "googleDirectionsService");
    V(this, "googleDirectionsRenderer");
    this.id = r.id || Lr.createUuid(), n instanceof Xa && (this.googleMap = n, this.googleDirectionsService = new google.maps.DirectionsService(), this.update(r)), n instanceof gu && (this.aMap = n, this.aMap.map && this.update(r));
  }
  /**
   * @zh 刪除路線
   * @en Remove route
   */
  remove() {
    this.clearRenderer(), this.googleMap && (this.googleMap.routes = this.googleMap.routes.filter((n) => n.id !== this.id)), this.aMap && (this.aMap.routes = this.aMap.routes.filter((n) => n.id !== this.id));
  }
  clearRenderer() {
    if (this.googleDirectionsRenderer && (this.googleDirectionsRenderer.setDirections(null), this.googleDirectionsRenderer.setMap(null), this.googleDirectionsRenderer = void 0), this.aMap) {
      const r = Ye().AMap, i = r.Driving;
      this.aMapDriving && this.aMapDriving.clear(), this.aMapDriving = new i({
        map: this.aMap.map,
        policy: r.DrivingPolicy.LEAST_TIME
      });
    }
  }
  update(n) {
    if (this.clearRenderer(), this.googleMap && this.googleMap.map && this.googleDirectionsService) {
      const r = {
        origin: n.origin,
        destination: n.destination,
        travelMode: google.maps.TravelMode[n.travelMode]
      };
      this.googleDirectionsRenderer = new google.maps.DirectionsRenderer({
        markerOptions: {
          visible: !1
        }
      }), this.googleDirectionsRenderer.setMap(this.googleMap.map), this.googleDirectionsService.route(r, (i, s) => {
        s == google.maps.DirectionsStatus.OK ? this.googleDirectionsRenderer && this.googleDirectionsRenderer.setDirections(i) : this.emit("failed", {
          status: s
        });
      });
    }
    if (this.aMap && this.aMap.map) {
      const r = [n.origin.lng, n.origin.lat], i = [n.destination.lng, n.destination.lat];
      this.aMapDriving.search(r, i, (s, a) => {
        s === "complete" || console.log("获取驾车数据失败：" + a);
      });
    }
  }
}
const $L = yn.checkout("AMap");
function EL() {
  var t;
  if (!((t = Ye().__ng_state.amap) != null && t.installed))
    throw $L.create("amap not installed.");
}
class gu extends Lt {
  constructor() {
    super();
    V(this, "map");
    V(this, "routes", []);
    V(this, "markers", []);
    EL();
  }
  static getNavigationUrl(n) {
    const { startName: r, startLng: i, startLat: s, endName: a, endLng: o, endLat: l } = n, c = new URL("https://uri.amap.com/navigation");
    return c.searchParams.set("from", `${i},${s},${r}`), c.searchParams.set("to", `${o},${l},${a}`), c.searchParams.set("mode", "car"), c.searchParams.set("policy", "1"), c.searchParams.set("src", "mypage"), c.searchParams.set("coordinate", "gaode"), c.searchParams.set("callnative", "1"), c.href;
  }
  static async install(n) {
    const r = Ye();
    r.__ng_state.amap == null && (r.__ng_state.amap = {
      installed: !1
    }), r.__ng_state.amap.installed === !1 && (r.__ng_state.amap.installed = !0, r._AMapSecurityConfig = {
      serviceHost: n.serviceHost,
      securityJsCode: n.securityJsCode
    }, await Ps.importScript(`https://webapi.amap.com/maps?v=2.0&key=${n.apiKey}&plugin=AMap.Driving`));
  }
  static isInstalled() {
    var r;
    return !!((r = Ye().__ng_state.amap) != null && r.installed);
  }
  start(n, r) {
    const i = Ye();
    this.map == null && (this.map = new i.AMap.Map(n, {
      zoom: r.zoom ?? 10,
      center: r.center ? [r.center.lng, r.center.lat] : void 0
    }), this.map.on("click", (s) => {
      this.emit("click", {
        lat: s.lnglat.lat,
        lng: s.lnglat.lng
      });
    }), this.map.on("mapmove", () => {
      this.map && this.emit("move", {
        lat: this.map.getCenter().lat,
        lng: this.map.getCenter().lng
      });
    }));
  }
  moveTo(n) {
    var r;
    (r = this.map) == null || r.setCenter([
      n.lng,
      n.lat
    ]);
  }
  zoomTo(n) {
    var r;
    (r = this.map) == null || r.setZoom(n);
  }
  close() {
    this.removeAllRoute(), this.removeAllMarker(), this.map && (this.map = void 0);
  }
  fitView() {
    this.map && this.map.setFitView();
  }
  // =================
  //
  // Marker
  //
  addMarker(n) {
    const r = new _w(this, n);
    return this.markers.push(r), r.on("click", () => {
      this.emit("clickMarker", r);
    }), r;
  }
  removeAllMarker() {
    this.markers.forEach((n) => n.remove()), this.markers = [];
  }
  reloadMarkers(n) {
    this.markers.filter((r) => !n.find((i) => i.id === r.id)).forEach((r) => r.remove()), n.forEach((r) => {
      const i = this.markers.find((s) => s.id === r.id);
      i ? i.moveTo(r.position) : this.addMarker(r);
    });
  }
  // =================
  //
  // Route
  //
  addRoute(n) {
    const r = new ww(this, n);
    return this.routes.push(r), r;
  }
  removeAllRoute() {
    this.routes.forEach((n) => n.remove()), this.routes = [];
  }
  reloadRoutes(n) {
    this.routes.filter((r) => !n.find((i) => i.id === r.id)).forEach((r) => r.remove()), n.forEach((r) => {
      let i = this.routes.find((s) => s.id === r.id);
      i ? i.update(r) : this.addRoute(r);
    });
  }
}
const AL = /* @__PURE__ */ be({
  __name: "map",
  props: {
    height: {
      type: String,
      required: !1,
      default: "400px"
    },
    /** 可以指定使用哪個地圖，如果不指定系統會從環境判定 */
    mode: {
      type: String,
      required: !1,
      default: () => Xa.isInstalled() ? "google" : "amap"
    },
    zoom: {
      type: Number,
      required: !1,
      default: 8
    },
    center: {
      type: Object,
      required: !0
    },
    markers: {
      type: Array,
      required: !1,
      default: () => []
    },
    routes: {
      type: Array,
      required: !1,
      default: () => []
    }
  },
  emits: {
    move: (e) => !0,
    click: (e) => !0,
    clickMarker: (e) => !0
  },
  setup(e, { expose: t, emit: n }) {
    const r = e, i = n;
    t({
      fitView: () => s.fitView()
    });
    const s = r.mode === "google" ? new Xa() : new gu(), a = oe();
    return ct(() => {
      s && a.value && (s.start(a.value, {
        zoom: r.zoom,
        center: r.center
      }), s.reloadRoutes(r.routes), s.reloadMarkers(r.markers), s.on("move", (o) => i("move", o)), s.on("click", (o) => i("click", o)), s.on("clickMarker", (o) => i("clickMarker", o)));
    }), zt(() => {
      s && s.close();
    }), fe(() => r.zoom, () => s == null ? void 0 : s.zoomTo(r.zoom)), fe(() => r.center, () => s == null ? void 0 : s.moveTo(r.center), {
      deep: !0
    }), fe(() => r.routes, () => s == null ? void 0 : s.reloadRoutes(r.routes), {
      deep: !0
    }), fe(() => r.markers, () => s == null ? void 0 : s.reloadMarkers(r.markers), {
      deep: !0
    }), (o, l) => (j(), G("div", {
      ref_key: "main",
      ref: a,
      style: et({
        height: e.height
      })
    }, null, 4));
  }
}), kL = {
  key: 0,
  class: "component-outline-text py-2"
}, CL = { class: "w-100 opacity-0" }, DL = { key: 1 }, SL = /* @__PURE__ */ be({
  __name: "outline-text",
  props: {
    text: {
      type: String,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: () => !1
    },
    fontColor: {
      type: String,
      required: !1,
      default: () => "white"
    },
    outlineColor: {
      type: String,
      required: !1,
      default: () => "cas-primary"
    },
    outlineWeight: {
      type: Number,
      required: !1,
      default: () => 2
    }
  },
  setup(e) {
    const t = e, n = T(() => t.outlineColor === "cas-primary" ? "#005A8E" : t.outlineColor === "cas-secondary" ? "#5E3013" : Va.headMatch(t.outlineColor, "--") ? `var(${t.outlineColor})` : t.outlineColor);
    return (r, i) => e.disabled === !1 ? (j(), G("div", kL, [
      de("div", {
        class: "w-100 component-outline-text-stroke",
        style: et(`-webkit-text-stroke: ${e.outlineWeight}px ${n.value}`)
      }, Fe(e.text), 5),
      de("div", {
        class: "w-100 component-outline-text-no-stroke",
        style: et({ color: e.fontColor })
      }, Fe(e.text), 5),
      de("div", CL, Fe(e.text), 1)
    ])) : (j(), G("div", DL, [
      de("div", null, Fe(e.text), 1)
    ]));
  }
}), TL = /* @__PURE__ */ Sn(SL, [["__scopeId", "data-v-5c33c662"]]), OL = /* @__PURE__ */ be({
  __name: "pagination",
  props: {
    alwaysShow: {
      type: Boolean,
      required: !1,
      default: () => !1
    },
    totalVisible: {
      type: Number,
      required: !1,
      default: () => null
    },
    color: {
      type: String,
      required: !1,
      default: () => "primary"
    },
    total: {
      type: Number,
      required: !1,
      default: () => 1
    },
    prePage: {
      type: Number,
      required: !1,
      default: () => 1
    },
    modelValue: {
      type: Number,
      required: !1,
      default: () => 1
    },
    loading: {
      type: Boolean,
      required: !1,
      default: () => !1
    },
    scrollTo: {
      type: null,
      required: !1,
      default: () => null
    }
  },
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, { emit: t }) {
    const n = new Zl({
      defCheckValue: () => {
        var c;
        return ((c = r.value) == null ? void 0 : c.clientWidth) || 0;
      },
      points: Zl.bootstrapBreakpoints
    }), r = oe(), i = e, s = t, a = T(() => !!(i.alwaysShow || l.value > 1)), o = T({
      get: () => i.modelValue,
      set: (c) => s("update:modelValue", c || 1)
    }), l = T(() => {
      let c = Math.ceil(i.total / i.prePage);
      return isNaN(c) ? 1 : c || 1;
    });
    return fe(() => o.value, () => {
      if (i.scrollTo)
        if (i.scrollTo === "top")
          window.scrollTo({
            top: 0,
            left: 0,
            behavior: "smooth"
          });
        else {
          const u = i.scrollTo.getBoundingClientRect().top + window.pageYOffset + -100;
          window.scrollTo({
            top: u,
            behavior: "smooth"
          });
        }
    }), (c, u) => {
      const f = ge("v-pagination"), d = ge("v-progress-linear");
      return j(), G("div", {
        ref_key: "wrapper",
        ref: r,
        class: "mt-4"
      }, [
        a.value ? (j(), ke(f, {
          key: 0,
          modelValue: o.value,
          "onUpdate:modelValue": u[0] || (u[0] = (h) => o.value = h),
          color: e.color,
          length: l.value,
          disabled: e.loading,
          size: X(n).in("sm-and-down") ? "small" : "default",
          "total-visible": e.totalVisible ? e.totalVisible : X(n).in("sm-and-down") ? 4 : 7
        }, null, 8, ["modelValue", "color", "length", "disabled", "size", "total-visible"])) : ve("", !0),
        a.value && e.loading ? (j(), ke(d, {
          key: 1,
          "buffer-value": "0",
          indeterminate: "",
          style: { "max-width": "200px" },
          color: e.color
        }, null, 8, ["color"])) : ve("", !0)
      ], 512);
    };
  }
}), $w = (e, t = 100, n = 100) => {
  const r = new Qc({
    delay: t,
    maxValueLength: n
  });
  return ct(() => {
    r.on("trigger", e);
  }), zt(() => {
    r.close();
  }), r;
}, ML = { class: "lib-component-search-bar" }, FL = { class: "text-center" }, PL = /* @__PURE__ */ be({
  __name: "search",
  props: {
    searchValue: {
      type: String,
      required: !0
    },
    items: {
      type: Array,
      required: !1,
      default: () => []
    },
    loading: {
      type: Boolean,
      required: !1,
      default: () => !1
    },
    itemTitle: {
      type: String,
      required: !1,
      default: () => "title"
    }
  },
  emits: {
    closed: () => !0,
    changed: () => !0,
    selected: (e) => !0
  },
  setup(e, { emit: t }) {
    const n = e, r = t, i = $w(() => s(), 100, 5);
    fe(() => n.searchValue, () => {
      i.input("");
    });
    const s = () => {
      n.searchValue ? r("changed") : r("closed");
    }, a = (o) => {
      r("selected", o), r("closed");
    };
    return (o, l) => {
      const c = ge("v-progress-circular"), u = ge("VList"), f = ge("v-list-item");
      return j(), G("div", ML, [
        Ee(o.$slots, "default", {}, void 0, !0),
        e.loading ? (j(), ke(u, {
          key: 0,
          class: "lib-component-search-list rounded elevation-3"
        }, {
          default: pe(() => [
            Ee(o.$slots, "loading", {}, () => [
              de("div", FL, [
                U(c, {
                  color: "primary",
                  indeterminate: ""
                })
              ])
            ], !0)
          ]),
          _: 3
        })) : e.items.length ? (j(), ke(u, {
          key: 1,
          class: "lib-component-search-list rounded elevation-3"
        }, {
          default: pe(() => [
            Ee(o.$slots, "list", {}, () => [
              (j(!0), G(Ie, null, _t(e.items, (d) => (j(), ke(f, {
                key: typeof d == "string" ? d : d[e.itemTitle],
                title: typeof d == "string" ? d : d[e.itemTitle],
                onClick: (h) => a(d)
              }, null, 8, ["title", "onClick"]))), 128))
            ], !0)
          ]),
          _: 3
        })) : ve("", !0)
      ]);
    };
  }
}), IL = /* @__PURE__ */ Sn(PL, [["__scopeId", "data-v-a83e4c70"]]), RL = /* @__PURE__ */ be({
  __name: "skeleton-group",
  props: {
    mobile: {
      type: Array,
      required: !1,
      default: () => null
    },
    desktop: {
      type: Array,
      required: !0,
      default: () => []
    },
    height: {
      type: Number,
      required: !1,
      default: () => 300
    }
  },
  setup(e) {
    const t = new Zl({
      defCheckValue: () => {
        var s;
        return ((s = n.value) == null ? void 0 : s.clientWidth) || 0;
      },
      points: Zl.bootstrapBreakpoints
    }), n = oe(), r = e, i = T(() => r.mobile && t.in("sm-and-down") ? r.mobile : r.desktop);
    return (s, a) => {
      const o = ge("v-col"), l = ge("v-row");
      return j(), G("div", {
        ref_key: "wrapper",
        ref: n,
        style: et({ height: `${e.height}px` })
      }, [
        U(l, {
          "no-gutters": "",
          class: "my-n2 w-100 h-100 flex-nowrap"
        }, {
          default: pe(() => [
            (j(!0), G(Ie, null, _t(i.value, (c, u) => (j(), ke(o, {
              key: u,
              cols: c[0]
            }, {
              default: pe(() => [
                (j(!0), G(Ie, null, _t(c[1], (f) => (j(), G("div", {
                  key: f,
                  style: et({
                    height: `${e.height / c[1]}px`
                  }),
                  class: "pa-2"
                }, [
                  U(wh)
                ], 4))), 128))
              ]),
              _: 2
            }, 1032, ["cols"]))), 128))
          ]),
          _: 1
        })
      ], 4);
    };
  }
}), BL = () => {
  const { service: e, stage: t, version: n } = No(), r = new yb(`lib-${e}-${t}`, {
    intercept: {
      get(i, s, { isDefault: a, defaultValue: o }) {
        return a ? s : s.version !== n ? (r.remove(i), o()) : s.data;
      },
      set(i, s) {
        return {
          data: s,
          version: n,
          createdAt: Date.now()
        };
      }
    },
    defaultColumns: {
      tablefilterMemories: () => ({})
    }
  });
  return r;
}, Ev = () => {
  const { service: e, stage: t, version: n } = No(), r = new yb(`lib-pd-${e}-${t}`, {
    storageSystem: sessionStorage,
    intercept: {
      get(i, s, { isDefault: a, defaultValue: o }) {
        return a ? s : s.version !== n ? (r.remove(i), o()) : s.data;
      },
      set(i, s) {
        return {
          data: s,
          version: n,
          createdAt: Date.now()
        };
      }
    },
    defaultColumns: {}
  });
  return r;
}, NL = ["onClick"], LL = {
  colspan: "100%",
  class: "component-twr-detail"
}, jL = { key: 0 }, zL = /* @__PURE__ */ be({
  __name: "table",
  props: {
    height: {
      type: String,
      required: !1,
      default: () => {
      }
    },
    sorts: {
      type: Object,
      required: !1,
      default: () => ({})
    },
    sortUpValue: {
      type: null,
      required: !1,
      default: () => !0
    },
    sortDownValue: {
      type: null,
      required: !1,
      default: () => !1
    },
    elevation: {
      type: Number,
      required: !1,
      default: () => 1
    },
    fixedHeader: {
      type: Boolean,
      required: !1,
      default: () => !1
    },
    headerColor: {
      type: String,
      required: !1,
      default: () => "secondary"
    },
    textNowrap: {
      type: String,
      required: !1,
      default: () => "none"
    },
    rowStyle: {
      type: Function,
      required: !1,
      default: () => () => ""
    },
    filterMemory: {
      type: String,
      required: !1,
      default: () => ""
    },
    filterShow: {
      type: Boolean,
      required: !1,
      default: () => !1
    },
    filterTitle: {
      type: String,
      required: !1,
      default: () => "Filter"
    },
    fields: {
      required: !0,
      type: Array
    },
    items: {
      required: !0,
      type: Array
    },
    loading: {
      type: Boolean,
      required: !1,
      default: () => !1
    }
  },
  emits: {
    "click-item": (e) => !0,
    "click-sort": (e, t) => !0,
    "update:sorts": (e) => !0
  },
  setup(e, { emit: t }) {
    const n = _o(), r = Kl.peel, i = BL(), s = new eu(), a = e, o = t, l = oe(), c = Oe({
      reloaded: !0,
      modalShow: !1,
      isOverflow: !1,
      showShadow: !1,
      showFields: []
    }), u = T({
      get: () => a.sorts,
      set: (b) => o("update:sorts", b)
    }), f = T(() => n.hasListener("click-item")), d = T(() => {
      if (a.items.length === 0 || a.filterShow === !1)
        return !1;
      for (let b of a.fields)
        if (b.optionShow)
          return !0;
      return !1;
    }), h = T(() => a.fields.filter((b) => c.showFields.includes(b.key))), p = T(() => a.fields.map((w) => w.key).filter((w) => !c.showFields.includes(w)));
    dk(l, () => {
      var w;
      let b = (w = l.value) == null ? void 0 : w.$el;
      if (b) {
        let E = b.getElementsByTagName("table")[0];
        E && (c.isOverflow = E.clientWidth > b.clientWidth, c.showShadow = c.isOverflow);
      }
    });
    const g = new Qc({
      delay: 50
    });
    g.on("trigger", () => {
      c.reloaded = !1, setTimeout(() => {
        c.reloaded = !0;
      }, 10);
    }), fe(() => c.showFields, () => {
      v(), g.input("");
    }, { deep: !0 }), ct(() => {
      c.showFields = a.fields.map((E) => E.key);
      let b = a.filterMemory;
      if (b) {
        let E = i.get("tablefilterMemories");
        E[b] && (c.showFields = c.showFields.filter(($) => !E[b].includes($)));
      }
      let w = l.value.$el.getElementsByClassName("v-table__wrapper")[0];
      w && (s.observe(w), s.add("scroll", () => {
        c.isOverflow && (c.showShadow = w.scrollLeft === 0);
      }));
    }), zt(() => {
      g.close(), s.clear();
    });
    const v = () => {
      let b = a.filterMemory;
      if (b) {
        let w = i.get("tablefilterMemories");
        w[b] ? w[b] = p.value : w[b] = [], i.set("tablefilterMemories", w);
      }
    }, m = (b) => {
      o("click-item", b);
    }, x = (b, w, E) => {
      let $ = r(w, b.key);
      return b.formatter == null ? $ : b.formatter($, b.key, w, E);
    }, _ = () => {
      c.modalShow = !0;
    }, y = (b) => {
      u.value[b] = u.value[b] === a.sortDownValue ? a.sortUpValue : a.sortDownValue, o("click-sort", b, u.value[b]);
    };
    return (b, w) => {
      const E = ge("v-icon"), $ = ge("v-table"), C = ge("v-checkbox"), A = ge("v-badge");
      return j(), G("div", {
        style: { position: "relative" },
        class: Be(`elevation-${e.elevation}`)
      }, [
        U($, {
          ref_key: "table",
          ref: l,
          height: e.height,
          "fixed-header": e.fixedHeader,
          class: Be({
            "component-shadow-right": c.showShadow
          })
        }, {
          default: pe(() => [
            de("thead", null, [
              de("tr", null, [
                (j(!0), G(Ie, null, _t(h.value, (k, D) => (j(), G("th", {
                  key: D + "ff",
                  class: Be({
                    [`bg-${e.headerColor}`]: !0,
                    "text-start": k.textAlign === "start",
                    "text-center": k.textAlign === "center",
                    "text-end": k.textAlign === "end",
                    "component-text-nowrap": ["head", "all"].includes(e.textNowrap)
                  })
                }, [
                  Ee(b.$slots, "h-" + k.key, {
                    field: k,
                    item: null,
                    value: k.label()
                  }, () => [
                    de("span", null, Fe(k.label()), 1)
                  ], !0),
                  k.sortBtn ? (j(), ke(E, {
                    key: 0,
                    size: "small",
                    class: Be(["mx-1 component-table-sort-btn", {
                      "component-table-sort-btn-actived": u.value[k.key] === e.sortUpValue
                    }]),
                    color: u.value[k.key] === e.sortUpValue ? "primary" : "grey",
                    onClick: (S) => y(k.key)
                  }, {
                    default: pe(() => [
                      fn(" mdi-arrow-down-thin ")
                    ]),
                    _: 2
                  }, 1032, ["color", "class", "onClick"])) : ve("", !0)
                ], 2))), 128))
              ])
            ]),
            de("tbody", null, [
              (j(!0), G(Ie, null, _t(e.items, (k, D) => (j(), G(Ie, {
                key: k.key
              }, [
                de("tr", {
                  style: et(e.rowStyle(k, D)),
                  class: Be({
                    "component-twr-is-btn": f.value
                  }),
                  onClick: (S) => m(k)
                }, [
                  (j(!0), G(Ie, null, _t(h.value, (S) => (j(), G("td", {
                    key: S.key,
                    class: Be({
                      "text-start": S.textAlign === "start",
                      "text-center": S.textAlign === "center",
                      "text-end": S.textAlign === "end",
                      "component-text-nowrap": ["body", "all"].includes(e.textNowrap)
                    }),
                    style: et(S.style(x(S, k, D), S.key, k, D))
                  }, [
                    Ee(b.$slots, "t-" + S.key.replace(/\./g, "-"), {
                      item: k,
                      field: S,
                      value: x(S, k, D)
                    }, () => [
                      de("div", null, Fe(x(S, k, D)), 1)
                    ], !0)
                  ], 6))), 128))
                ], 14, NL),
                X(n).hasSlot("details") ? (j(), G("tr", {
                  key: D + "iddi"
                }, [
                  de("td", LL, [
                    Ee(b.$slots, "details", {
                      class: "w-100",
                      item: k
                    }, void 0, !0)
                  ])
                ])) : ve("", !0)
              ], 64))), 128))
            ]),
            Ee(b.$slots, "end", {}, void 0, !0)
          ]),
          _: 3
        }, 8, ["height", "fixed-header", "class"]),
        e.items.length === 0 ? (j(), G("div", jL, [
          Ee(b.$slots, "no-data", {}, void 0, !0)
        ])) : ve("", !0),
        U(xs, { "model-value": e.loading }, null, 8, ["model-value"]),
        U(Y_, {
          modelValue: c.modalShow,
          "onUpdate:modelValue": w[1] || (w[1] = (k) => c.modalShow = k),
          title: e.filterTitle
        }, {
          default: pe(() => [
            (j(!0), G(Ie, null, _t(e.fields, (k) => (j(), G(Ie, {
              key: k.key + "da"
            }, [
              k.optionShow ? (j(), ke(C, {
                key: 0,
                "hide-details": "",
                multiple: "",
                value: k.key,
                label: k.label(),
                "model-value": c.showFields,
                "onUpdate:modelValue": w[0] || (w[0] = (D) => c.showFields = D)
              }, null, 8, ["value", "label", "model-value"])) : ve("", !0)
            ], 64))), 128))
          ]),
          _: 1
        }, 8, ["modelValue", "title"]),
        d.value ? (j(), G("div", {
          key: 1,
          class: "print-no-show component-twr-filter",
          onClick: _
        }, [
          U(A, {
            color: "red",
            "offset-x": "0",
            "offset-y": "0",
            dot: "",
            bordered: "",
            "model-value": p.value.length > 0
          }, {
            default: pe(() => [
              U(E, { size: "small" }, {
                default: pe(() => [
                  fn("mdi-filter")
                ]),
                _: 1
              })
            ]),
            _: 1
          }, 8, ["model-value"])
        ])) : ve("", !0)
      ], 2);
    };
  }
}), VL = /* @__PURE__ */ Sn(zL, [["__scopeId", "data-v-f23594ef"]]), HL = /* @__PURE__ */ be({
  __name: "toolbar",
  props: {
    height: {
      type: String,
      required: !1,
      default: () => "48px"
    }
  },
  setup(e) {
    const t = _o(), n = e, r = Oe({
      headerStyleString: ""
    });
    ct(() => {
      let s = new za();
      s.set("height", n.height), r.headerStyleString = s.join();
    });
    const i = T(() => {
      let s = "50%";
      return t.hasSlot("center") && (s = "33.33333%"), `height: fit-content; width: ${s};`;
    });
    return (s, a) => {
      const o = ge("v-row");
      return j(), G("div", {
        style: et(r.headerStyleString)
      }, [
        U(o, {
          class: "component-toolbar-wrapper h-100",
          "no-gutters": "",
          align: "center"
        }, {
          default: pe(() => [
            de("div", {
              style: et(i.value)
            }, [
              Ee(s.$slots, "default", {}, void 0, !0)
            ], 4),
            X(t).hasSlot("center") ? (j(), G("div", {
              key: 0,
              class: "text-center",
              style: et(i.value)
            }, [
              Ee(s.$slots, "center", {}, void 0, !0)
            ], 4)) : ve("", !0),
            de("div", {
              class: "text-right",
              style: et(i.value)
            }, [
              Ee(s.$slots, "right", {}, void 0, !0)
            ], 4)
          ]),
          _: 3
        })
      ], 4);
    };
  }
}), WL = /* @__PURE__ */ Sn(HL, [["__scopeId", "data-v-df86c481"]]), UL = { key: 1 }, YL = ["accept", "disabled"], qL = ["accept", "disabled"], GL = /* @__PURE__ */ be({
  __name: "upload",
  props: {
    disabled: {
      type: Boolean,
      required: !1,
      default: () => !1
    },
    enabledDrag: {
      type: Boolean,
      required: !1,
      default: () => !1
    },
    loading: {
      type: Boolean,
      required: !1,
      default: () => !1
    },
    multiple: {
      type: Boolean,
      required: !1,
      default: () => !1
    },
    fileType: {
      type: String,
      required: !1,
      default: () => "*/*"
    },
    preupload: {
      type: Function,
      required: !1,
      default: null
    }
  },
  emits: ["error", "uploaded"],
  setup(e, { emit: t }) {
    const n = e, r = t, i = oe(), s = oe(), a = Oe({
      reading: !1,
      draging: !1
    }), o = () => {
      var p;
      a.reading === !1 && n.disabled === !1 && ((p = s.value) == null || p.click());
    }, l = async (p) => {
      if (p && p[0]) {
        let g = [], v = new xb(), m = new Jc({
          concurrentExecutions: 1
        });
        for (let x = 0; x < p.length; x++) {
          let _ = p[x];
          if (h(_) === !1) {
            r("error", {
              type: "NoSupportMineType",
              file: _,
              error: null
            });
            continue;
          }
          if (n.preupload)
            try {
              _ = await n.preupload(_);
            } catch (y) {
              r("error", {
                type: "Unknown",
                file: _,
                error: y
              });
              return;
            }
          if (v.push(`file: ${x}`, () => m.pushAndWait(`file: ${x}`, () => new Promise((y, b) => {
            let w = new FileReader();
            w.readAsDataURL(_), w.onerror = b, w.onload = (E) => {
              E.target && g.push({
                url: E.target.result,
                file: _
              }), y(null);
            };
          }))), n.multiple === !1)
            break;
        }
        a.reading = !0, await v.start({}), a.reading = !1, g.length !== 0 && r("uploaded", {
          files: g
        });
      }
    }, c = async () => {
      var g;
      const p = (g = s.value) == null ? void 0 : g.files;
      await l(Array.from(p || []));
    }, u = async (p) => {
      if (n.disabled === !1) {
        p == null || p.preventDefault();
        const g = [];
        if (a.reading = !0, p && p.dataTransfer && p.dataTransfer.items) {
          for (let v = 0; v < p.dataTransfer.items.length; v++)
            if (p.dataTransfer.items[v].kind === "file") {
              let m = p.dataTransfer.items[v].getAsFile();
              m && g.push(m);
            }
        }
        a.draging = !1, await l(g);
      }
    }, f = (p) => {
      a.reading === !1 && n.disabled === !1 && (p == null || p.preventDefault(), a.draging = !0);
    }, d = (p) => {
      p == null || p.preventDefault(), a.draging = !1;
    }, h = (p) => n.fileType === "*/*" ? !0 : !!n.fileType.split(",").map((m) => m === ".jpg" || m === ".jpeg" ? [
      /image\/(jpeg)/i,
      /image\/(jpg)/i
    ] : m === ".mp3" ? [
      /audio\/(mpeg)/i,
      /audio\/(mp3)/i
    ] : m === "*/*" ? /.*/ : m.indexOf("/*") !== -1 ? new RegExp(m.replace("*", ".+"), "i") : m.startsWith(".") ? new RegExp(`\\${m}$`, "i") : new RegExp(m.replace("/", "\\/"), "i")).flat().some((m) => m.test(p.type) || m.test(p.name));
    return (p, g) => (j(), G("div", {
      style: { width: "fit-content", height: "fit-content", position: "relative" },
      onClick: o
    }, [
      e.enabledDrag ? (j(), G("div", {
        key: 0,
        ref_key: "dropArea",
        ref: i,
        onDrop: u,
        onDragover: f,
        onDragend: d,
        onDragleave: d,
        onDragexit: d
      }, [
        Ee(p.$slots, "default", {
          draging: a.draging,
          reading: a.reading
        })
      ], 544)) : (j(), G("div", UL, [
        Ee(p.$slots, "default", {
          draging: a.draging,
          reading: a.reading
        })
      ])),
      e.multiple ? (j(), G("input", {
        key: 2,
        ref_key: "fileInput",
        ref: s,
        hidden: "",
        type: "file",
        multiple: "",
        accept: e.fileType,
        disabled: a.reading || e.loading,
        onChange: c
      }, null, 40, YL)) : (j(), G("input", {
        key: 3,
        ref_key: "fileInput",
        ref: s,
        hidden: "",
        type: "file",
        accept: e.fileType,
        disabled: a.reading || e.loading,
        onChange: c
      }, null, 40, qL)),
      U(xs, {
        "model-value": e.loading || a.reading
      }, {
        default: pe(() => [
          Ee(p.$slots, "loading")
        ]),
        _: 3
      }, 8, ["model-value"])
    ]));
  }
}), $h = (e, t) => {
  var r, i, s, a, o, l, c, u, f, d, h, p, g, v, m, x, _, y, b, w, E;
  if (typeof e == "string")
    return e;
  if (e.name === "AxiosError") {
    if (typeof ((r = e.response) == null ? void 0 : r.data) == "string" && e.response.data)
      return e.response.data;
    if ((s = (i = e.response) == null ? void 0 : i.data) != null && s.msg)
      return ((o = (a = e.response) == null ? void 0 : a.data) == null ? void 0 : o.msg) || t;
    if ((u = (c = (l = e.response) == null ? void 0 : l.data) == null ? void 0 : c.data) != null && u.msg)
      return ((h = (d = (f = e.response) == null ? void 0 : f.data) == null ? void 0 : d.data) == null ? void 0 : h.msg) || t;
    if ((g = (p = e.response) == null ? void 0 : p.data) != null && g.errors) {
      let $ = (m = (v = e.response) == null ? void 0 : v.data) == null ? void 0 : m.errors;
      if (Array.isArray($))
        return $[0] || t;
      {
        let [C] = Object.values($);
        return C || t;
      }
    }
    if ((y = (_ = (x = e.response) == null ? void 0 : x.data) == null ? void 0 : _.error) != null && y.message) {
      let $ = e.response.data.error.message, C = (E = (w = (b = e.response) == null ? void 0 : b.data) == null ? void 0 : w.error) == null ? void 0 : E.details;
      return typeof C == "string" && C ? `${$} => ${C}` : $;
    }
  }
  let n = e.message;
  return n && typeof n == "string" && n ? n : t || "unknown error";
}, XL = { key: 0 }, ZL = {
  key: 1,
  class: "text-center"
}, KL = { key: 1 }, JL = {
  key: 1,
  class: "text-error text-center py-2"
}, QL = {
  key: 2,
  style: { height: "32px" }
}, e9 = /* @__PURE__ */ be({
  __name: "visible-load",
  props: {
    disabled: {
      type: Boolean,
      required: !1,
      default: () => !1
    }
  },
  emits: {
    inited: (e) => !0,
    error: (e) => !0
  },
  setup(e, { expose: t, emit: n }) {
    const r = _o(), i = oe(), s = new bb(), a = (d) => {
      s.attach("trigger", d);
    }, o = e, l = n;
    t({
      hook: a
    }), $b(i, ([{ isIntersecting: d }]) => {
      c.inited === !1 && l("inited", a), c.inited = !0, c.isIntersecting = d;
    });
    const c = Oe({
      inited: !1,
      error: null,
      ticker: new _b(500),
      loading: !1,
      errorMessage: "",
      isIntersecting: !1
    }), u = T(() => !(c.inited === !1 || o.disabled || c.loading || c.error));
    ct(() => {
      c.ticker.on("next", () => {
        c.isIntersecting && f();
      });
    }), zt(() => {
      c.ticker.close();
    });
    const f = async () => {
      if (u.value === !1)
        return null;
      try {
        c.loading = !0, await s.notify("trigger", null);
      } catch (d) {
        c.error = d, c.errorMessage = $h(d, "unknown error"), l("error", {
          error: c.error,
          message: c.errorMessage
        });
      } finally {
        c.loading = !1;
      }
    };
    return (d, h) => {
      const p = ge("v-progress-circular");
      return j(), G("div", {
        ref_key: "target",
        ref: i
      }, [
        c.loading ? (j(), G("div", XL, [
          X(r).hasSlot("loading") ? Ee(d.$slots, "loading", { key: 0 }) : (j(), G("div", ZL, [
            U(p, {
              indeterminate: "",
              color: "primary"
            })
          ]))
        ])) : ve("", !0),
        c.error ? (j(), G("div", KL, [
          X(r).hasSlot("error") ? Ee(d.$slots, "error", {
            key: 0,
            error: c.error,
            message: c.errorMessage
          }) : (j(), G("div", JL, Fe(c.errorMessage), 1))
        ])) : ve("", !0),
        !X(r).hasSlot("default") && !c.loading && !c.error ? (j(), G("div", QL)) : ve("", !0),
        Ee(d.$slots, "default", {
          loading: c.loading,
          error: c.error,
          message: c.errorMessage
        })
      ], 512);
    };
  }
});
/*!
 * @kurkle/color v0.3.2
 * https://github.com/kurkle/color#readme
 * (c) 2023 Jukka Kurkela
 * Released under the MIT License
 */
function $o(e) {
  return e + 0.5 | 0;
}
const Tr = (e, t, n) => Math.max(Math.min(e, n), t);
function xa(e) {
  return Tr($o(e * 2.55), 0, 255);
}
function Pr(e) {
  return Tr($o(e * 255), 0, 255);
}
function Zn(e) {
  return Tr($o(e / 2.55) / 100, 0, 1);
}
function Av(e) {
  return Tr($o(e * 100), 0, 100);
}
const on = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, jd = [..."0123456789ABCDEF"], t9 = (e) => jd[e & 15], n9 = (e) => jd[(e & 240) >> 4] + jd[e & 15], qo = (e) => (e & 240) >> 4 === (e & 15), r9 = (e) => qo(e.r) && qo(e.g) && qo(e.b) && qo(e.a);
function i9(e) {
  var t = e.length, n;
  return e[0] === "#" && (t === 4 || t === 5 ? n = {
    r: 255 & on[e[1]] * 17,
    g: 255 & on[e[2]] * 17,
    b: 255 & on[e[3]] * 17,
    a: t === 5 ? on[e[4]] * 17 : 255
  } : (t === 7 || t === 9) && (n = {
    r: on[e[1]] << 4 | on[e[2]],
    g: on[e[3]] << 4 | on[e[4]],
    b: on[e[5]] << 4 | on[e[6]],
    a: t === 9 ? on[e[7]] << 4 | on[e[8]] : 255
  })), n;
}
const s9 = (e, t) => e < 255 ? t(e) : "";
function a9(e) {
  var t = r9(e) ? t9 : n9;
  return e ? "#" + t(e.r) + t(e.g) + t(e.b) + s9(e.a, t) : void 0;
}
const o9 = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function Ew(e, t, n) {
  const r = t * Math.min(n, 1 - n), i = (s, a = (s + e / 30) % 12) => n - r * Math.max(Math.min(a - 3, 9 - a, 1), -1);
  return [i(0), i(8), i(4)];
}
function l9(e, t, n) {
  const r = (i, s = (i + e / 60) % 6) => n - n * t * Math.max(Math.min(s, 4 - s, 1), 0);
  return [r(5), r(3), r(1)];
}
function c9(e, t, n) {
  const r = Ew(e, 1, 0.5);
  let i;
  for (t + n > 1 && (i = 1 / (t + n), t *= i, n *= i), i = 0; i < 3; i++)
    r[i] *= 1 - t - n, r[i] += t;
  return r;
}
function u9(e, t, n, r, i) {
  return e === i ? (t - n) / r + (t < n ? 6 : 0) : t === i ? (n - e) / r + 2 : (e - t) / r + 4;
}
function Eh(e) {
  const n = e.r / 255, r = e.g / 255, i = e.b / 255, s = Math.max(n, r, i), a = Math.min(n, r, i), o = (s + a) / 2;
  let l, c, u;
  return s !== a && (u = s - a, c = o > 0.5 ? u / (2 - s - a) : u / (s + a), l = u9(n, r, i, u, s), l = l * 60 + 0.5), [l | 0, c || 0, o];
}
function Ah(e, t, n, r) {
  return (Array.isArray(t) ? e(t[0], t[1], t[2]) : e(t, n, r)).map(Pr);
}
function kh(e, t, n) {
  return Ah(Ew, e, t, n);
}
function f9(e, t, n) {
  return Ah(c9, e, t, n);
}
function d9(e, t, n) {
  return Ah(l9, e, t, n);
}
function Aw(e) {
  return (e % 360 + 360) % 360;
}
function h9(e) {
  const t = o9.exec(e);
  let n = 255, r;
  if (!t)
    return;
  t[5] !== r && (n = t[6] ? xa(+t[5]) : Pr(+t[5]));
  const i = Aw(+t[2]), s = +t[3] / 100, a = +t[4] / 100;
  return t[1] === "hwb" ? r = f9(i, s, a) : t[1] === "hsv" ? r = d9(i, s, a) : r = kh(i, s, a), {
    r: r[0],
    g: r[1],
    b: r[2],
    a: n
  };
}
function p9(e, t) {
  var n = Eh(e);
  n[0] = Aw(n[0] + t), n = kh(n), e.r = n[0], e.g = n[1], e.b = n[2];
}
function g9(e) {
  if (!e)
    return;
  const t = Eh(e), n = t[0], r = Av(t[1]), i = Av(t[2]);
  return e.a < 255 ? `hsla(${n}, ${r}%, ${i}%, ${Zn(e.a)})` : `hsl(${n}, ${r}%, ${i}%)`;
}
const kv = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
}, Cv = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function v9() {
  const e = {}, t = Object.keys(Cv), n = Object.keys(kv);
  let r, i, s, a, o;
  for (r = 0; r < t.length; r++) {
    for (a = o = t[r], i = 0; i < n.length; i++)
      s = n[i], o = o.replace(s, kv[s]);
    s = parseInt(Cv[a], 16), e[o] = [s >> 16 & 255, s >> 8 & 255, s & 255];
  }
  return e;
}
let Go;
function m9(e) {
  Go || (Go = v9(), Go.transparent = [0, 0, 0, 0]);
  const t = Go[e.toLowerCase()];
  return t && {
    r: t[0],
    g: t[1],
    b: t[2],
    a: t.length === 4 ? t[3] : 255
  };
}
const y9 = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function x9(e) {
  const t = y9.exec(e);
  let n = 255, r, i, s;
  if (t) {
    if (t[7] !== r) {
      const a = +t[7];
      n = t[8] ? xa(a) : Tr(a * 255, 0, 255);
    }
    return r = +t[1], i = +t[3], s = +t[5], r = 255 & (t[2] ? xa(r) : Tr(r, 0, 255)), i = 255 & (t[4] ? xa(i) : Tr(i, 0, 255)), s = 255 & (t[6] ? xa(s) : Tr(s, 0, 255)), {
      r,
      g: i,
      b: s,
      a: n
    };
  }
}
function b9(e) {
  return e && (e.a < 255 ? `rgba(${e.r}, ${e.g}, ${e.b}, ${Zn(e.a)})` : `rgb(${e.r}, ${e.g}, ${e.b})`);
}
const Ju = (e) => e <= 31308e-7 ? e * 12.92 : Math.pow(e, 1 / 2.4) * 1.055 - 0.055, Wi = (e) => e <= 0.04045 ? e / 12.92 : Math.pow((e + 0.055) / 1.055, 2.4);
function _9(e, t, n) {
  const r = Wi(Zn(e.r)), i = Wi(Zn(e.g)), s = Wi(Zn(e.b));
  return {
    r: Pr(Ju(r + n * (Wi(Zn(t.r)) - r))),
    g: Pr(Ju(i + n * (Wi(Zn(t.g)) - i))),
    b: Pr(Ju(s + n * (Wi(Zn(t.b)) - s))),
    a: e.a + n * (t.a - e.a)
  };
}
function Xo(e, t, n) {
  if (e) {
    let r = Eh(e);
    r[t] = Math.max(0, Math.min(r[t] + r[t] * n, t === 0 ? 360 : 1)), r = kh(r), e.r = r[0], e.g = r[1], e.b = r[2];
  }
}
function kw(e, t) {
  return e && Object.assign(t || {}, e);
}
function Dv(e) {
  var t = { r: 0, g: 0, b: 0, a: 255 };
  return Array.isArray(e) ? e.length >= 3 && (t = { r: e[0], g: e[1], b: e[2], a: 255 }, e.length > 3 && (t.a = Pr(e[3]))) : (t = kw(e, { r: 0, g: 0, b: 0, a: 1 }), t.a = Pr(t.a)), t;
}
function w9(e) {
  return e.charAt(0) === "r" ? x9(e) : h9(e);
}
class Za {
  constructor(t) {
    if (t instanceof Za)
      return t;
    const n = typeof t;
    let r;
    n === "object" ? r = Dv(t) : n === "string" && (r = i9(t) || m9(t) || w9(t)), this._rgb = r, this._valid = !!r;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var t = kw(this._rgb);
    return t && (t.a = Zn(t.a)), t;
  }
  set rgb(t) {
    this._rgb = Dv(t);
  }
  rgbString() {
    return this._valid ? b9(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? a9(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? g9(this._rgb) : void 0;
  }
  mix(t, n) {
    if (t) {
      const r = this.rgb, i = t.rgb;
      let s;
      const a = n === s ? 0.5 : n, o = 2 * a - 1, l = r.a - i.a, c = ((o * l === -1 ? o : (o + l) / (1 + o * l)) + 1) / 2;
      s = 1 - c, r.r = 255 & c * r.r + s * i.r + 0.5, r.g = 255 & c * r.g + s * i.g + 0.5, r.b = 255 & c * r.b + s * i.b + 0.5, r.a = a * r.a + (1 - a) * i.a, this.rgb = r;
    }
    return this;
  }
  interpolate(t, n) {
    return t && (this._rgb = _9(this._rgb, t._rgb, n)), this;
  }
  clone() {
    return new Za(this.rgb);
  }
  alpha(t) {
    return this._rgb.a = Pr(t), this;
  }
  clearer(t) {
    const n = this._rgb;
    return n.a *= 1 - t, this;
  }
  greyscale() {
    const t = this._rgb, n = $o(t.r * 0.3 + t.g * 0.59 + t.b * 0.11);
    return t.r = t.g = t.b = n, this;
  }
  opaquer(t) {
    const n = this._rgb;
    return n.a *= 1 + t, this;
  }
  negate() {
    const t = this._rgb;
    return t.r = 255 - t.r, t.g = 255 - t.g, t.b = 255 - t.b, this;
  }
  lighten(t) {
    return Xo(this._rgb, 2, t), this;
  }
  darken(t) {
    return Xo(this._rgb, 2, -t), this;
  }
  saturate(t) {
    return Xo(this._rgb, 1, t), this;
  }
  desaturate(t) {
    return Xo(this._rgb, 1, -t), this;
  }
  rotate(t) {
    return p9(this._rgb, t), this;
  }
}
/*!
 * Chart.js v4.4.1
 * https://www.chartjs.org
 * (c) 2023 Chart.js Contributors
 * Released under the MIT License
 */
const $9 = /* @__PURE__ */ (() => {
  let e = 0;
  return () => e++;
})();
function Qe(e) {
  return e === null || typeof e > "u";
}
function gt(e) {
  if (Array.isArray && Array.isArray(e))
    return !0;
  const t = Object.prototype.toString.call(e);
  return t.slice(0, 7) === "[object" && t.slice(-6) === "Array]";
}
function Me(e) {
  return e !== null && Object.prototype.toString.call(e) === "[object Object]";
}
function kt(e) {
  return (typeof e == "number" || e instanceof Number) && isFinite(+e);
}
function en(e, t) {
  return kt(e) ? e : t;
}
function Re(e, t) {
  return typeof e > "u" ? t : e;
}
const E9 = (e, t) => typeof e == "string" && e.endsWith("%") ? parseFloat(e) / 100 : +e / t, Cw = (e, t) => typeof e == "string" && e.endsWith("%") ? parseFloat(e) / 100 * t : +e;
function ot(e, t, n) {
  if (e && typeof e.call == "function")
    return e.apply(n, t);
}
function Bt(e, t, n, r) {
  let i, s, a;
  if (gt(e))
    if (s = e.length, r)
      for (i = s - 1; i >= 0; i--)
        t.call(n, e[i], i);
    else
      for (i = 0; i < s; i++)
        t.call(n, e[i], i);
  else if (Me(e))
    for (a = Object.keys(e), s = a.length, i = 0; i < s; i++)
      t.call(n, e[a[i]], a[i]);
}
function Sv(e, t) {
  let n, r, i, s;
  if (!e || !t || e.length !== t.length)
    return !1;
  for (n = 0, r = e.length; n < r; ++n)
    if (i = e[n], s = t[n], i.datasetIndex !== s.datasetIndex || i.index !== s.index)
      return !1;
  return !0;
}
function vc(e) {
  if (gt(e))
    return e.map(vc);
  if (Me(e)) {
    const t = /* @__PURE__ */ Object.create(null), n = Object.keys(e), r = n.length;
    let i = 0;
    for (; i < r; ++i)
      t[n[i]] = vc(e[n[i]]);
    return t;
  }
  return e;
}
function Dw(e) {
  return [
    "__proto__",
    "prototype",
    "constructor"
  ].indexOf(e) === -1;
}
function A9(e, t, n, r) {
  if (!Dw(e))
    return;
  const i = t[e], s = n[e];
  Me(i) && Me(s) ? Ka(i, s, r) : t[e] = vc(s);
}
function Ka(e, t, n) {
  const r = gt(t) ? t : [
    t
  ], i = r.length;
  if (!Me(e))
    return e;
  n = n || {};
  const s = n.merger || A9;
  let a;
  for (let o = 0; o < i; ++o) {
    if (a = r[o], !Me(a))
      continue;
    const l = Object.keys(a);
    for (let c = 0, u = l.length; c < u; ++c)
      s(l[c], e, a, n);
  }
  return e;
}
function Da(e, t) {
  return Ka(e, t, {
    merger: k9
  });
}
function k9(e, t, n) {
  if (!Dw(e))
    return;
  const r = t[e], i = n[e];
  Me(r) && Me(i) ? Da(r, i) : Object.prototype.hasOwnProperty.call(t, e) || (t[e] = vc(i));
}
const Tv = {
  // Chart.helpers.core resolveObjectKey should resolve empty key to root object
  "": (e) => e,
  // default resolvers
  x: (e) => e.x,
  y: (e) => e.y
};
function C9(e) {
  const t = e.split("."), n = [];
  let r = "";
  for (const i of t)
    r += i, r.endsWith("\\") ? r = r.slice(0, -1) + "." : (n.push(r), r = "");
  return n;
}
function D9(e) {
  const t = C9(e);
  return (n) => {
    for (const r of t) {
      if (r === "")
        break;
      n = n && n[r];
    }
    return n;
  };
}
function Ja(e, t) {
  return (Tv[t] || (Tv[t] = D9(t)))(e);
}
function Ch(e) {
  return e.charAt(0).toUpperCase() + e.slice(1);
}
const mc = (e) => typeof e < "u", Br = (e) => typeof e == "function", Ov = (e, t) => {
  if (e.size !== t.size)
    return !1;
  for (const n of e)
    if (!t.has(n))
      return !1;
  return !0;
};
function S9(e) {
  return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
}
const lt = Math.PI, tt = 2 * lt, T9 = tt + lt, yc = Number.POSITIVE_INFINITY, O9 = lt / 180, vt = lt / 2, Xr = lt / 4, Mv = lt * 2 / 3, Or = Math.log10, bs = Math.sign;
function Sa(e, t, n) {
  return Math.abs(e - t) < n;
}
function Fv(e) {
  const t = Math.round(e);
  e = Sa(e, t, e / 1e3) ? t : e;
  const n = Math.pow(10, Math.floor(Or(e))), r = e / n;
  return (r <= 1 ? 1 : r <= 2 ? 2 : r <= 5 ? 5 : 10) * n;
}
function M9(e) {
  const t = [], n = Math.sqrt(e);
  let r;
  for (r = 1; r < n; r++)
    e % r === 0 && (t.push(r), t.push(e / r));
  return n === (n | 0) && t.push(n), t.sort((i, s) => i - s).pop(), t;
}
function Qa(e) {
  return !isNaN(parseFloat(e)) && isFinite(e);
}
function F9(e, t) {
  const n = Math.round(e);
  return n - t <= e && n + t >= e;
}
function Sw(e, t, n) {
  let r, i, s;
  for (r = 0, i = e.length; r < i; r++)
    s = e[r][n], isNaN(s) || (t.min = Math.min(t.min, s), t.max = Math.max(t.max, s));
}
function Rn(e) {
  return e * (lt / 180);
}
function Dh(e) {
  return e * (180 / lt);
}
function Pv(e) {
  if (!kt(e))
    return;
  let t = 1, n = 0;
  for (; Math.round(e * t) / t !== e; )
    t *= 10, n++;
  return n;
}
function Tw(e, t) {
  const n = t.x - e.x, r = t.y - e.y, i = Math.sqrt(n * n + r * r);
  let s = Math.atan2(r, n);
  return s < -0.5 * lt && (s += tt), {
    angle: s,
    distance: i
  };
}
function Iv(e, t) {
  return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2));
}
function P9(e, t) {
  return (e - t + T9) % tt - lt;
}
function En(e) {
  return (e % tt + tt) % tt;
}
function eo(e, t, n, r) {
  const i = En(e), s = En(t), a = En(n), o = En(s - i), l = En(a - i), c = En(i - s), u = En(i - a);
  return i === s || i === a || r && s === a || o > l && c < u;
}
function nn(e, t, n) {
  return Math.max(t, Math.min(n, e));
}
function I9(e) {
  return nn(e, -32768, 32767);
}
function Ow(e, t, n, r = 1e-6) {
  return e >= Math.min(t, n) - r && e <= Math.max(t, n) + r;
}
function Sh(e, t, n) {
  n = n || ((a) => e[a] < t);
  let r = e.length - 1, i = 0, s;
  for (; r - i > 1; )
    s = i + r >> 1, n(s) ? i = s : r = s;
  return {
    lo: i,
    hi: r
  };
}
const oi = (e, t, n, r) => Sh(e, n, r ? (i) => {
  const s = e[i][t];
  return s < n || s === n && e[i + 1][t] === n;
} : (i) => e[i][t] < n), R9 = (e, t, n) => Sh(e, n, (r) => e[r][t] >= n);
function B9(e, t, n) {
  let r = 0, i = e.length;
  for (; r < i && e[r] < t; )
    r++;
  for (; i > r && e[i - 1] > n; )
    i--;
  return r > 0 || i < e.length ? e.slice(r, i) : e;
}
const Mw = [
  "push",
  "pop",
  "shift",
  "splice",
  "unshift"
];
function N9(e, t) {
  if (e._chartjs) {
    e._chartjs.listeners.push(t);
    return;
  }
  Object.defineProperty(e, "_chartjs", {
    configurable: !0,
    enumerable: !1,
    value: {
      listeners: [
        t
      ]
    }
  }), Mw.forEach((n) => {
    const r = "_onData" + Ch(n), i = e[n];
    Object.defineProperty(e, n, {
      configurable: !0,
      enumerable: !1,
      value(...s) {
        const a = i.apply(this, s);
        return e._chartjs.listeners.forEach((o) => {
          typeof o[r] == "function" && o[r](...s);
        }), a;
      }
    });
  });
}
function Rv(e, t) {
  const n = e._chartjs;
  if (!n)
    return;
  const r = n.listeners, i = r.indexOf(t);
  i !== -1 && r.splice(i, 1), !(r.length > 0) && (Mw.forEach((s) => {
    delete e[s];
  }), delete e._chartjs);
}
function L9(e) {
  const t = new Set(e);
  return t.size === e.length ? e : Array.from(t);
}
const Fw = function() {
  return typeof window > "u" ? function(e) {
    return e();
  } : window.requestAnimationFrame;
}();
function Pw(e, t) {
  let n = [], r = !1;
  return function(...i) {
    n = i, r || (r = !0, Fw.call(window, () => {
      r = !1, e.apply(t, n);
    }));
  };
}
function j9(e, t) {
  let n;
  return function(...r) {
    return t ? (clearTimeout(n), n = setTimeout(e, t, r)) : e.apply(this, r), t;
  };
}
const z9 = (e) => e === "start" ? "left" : e === "end" ? "right" : "center", Bv = (e, t, n) => e === "start" ? t : e === "end" ? n : (t + n) / 2;
function V9(e, t, n) {
  const r = t.length;
  let i = 0, s = r;
  if (e._sorted) {
    const { iScale: a, _parsed: o } = e, l = a.axis, { min: c, max: u, minDefined: f, maxDefined: d } = a.getUserBounds();
    f && (i = nn(Math.min(
      // @ts-expect-error Need to type _parsed
      oi(o, l, c).lo,
      // @ts-expect-error Need to fix types on _lookupByKey
      n ? r : oi(t, l, a.getPixelForValue(c)).lo
    ), 0, r - 1)), d ? s = nn(Math.max(
      // @ts-expect-error Need to type _parsed
      oi(o, a.axis, u, !0).hi + 1,
      // @ts-expect-error Need to fix types on _lookupByKey
      n ? 0 : oi(t, l, a.getPixelForValue(u), !0).hi + 1
    ), i, r) - i : s = r - i;
  }
  return {
    start: i,
    count: s
  };
}
function H9(e) {
  const { xScale: t, yScale: n, _scaleRanges: r } = e, i = {
    xmin: t.min,
    xmax: t.max,
    ymin: n.min,
    ymax: n.max
  };
  if (!r)
    return e._scaleRanges = i, !0;
  const s = r.xmin !== t.min || r.xmax !== t.max || r.ymin !== n.min || r.ymax !== n.max;
  return Object.assign(r, i), s;
}
const Zo = (e) => e === 0 || e === 1, Nv = (e, t, n) => -(Math.pow(2, 10 * (e -= 1)) * Math.sin((e - t) * tt / n)), Lv = (e, t, n) => Math.pow(2, -10 * e) * Math.sin((e - t) * tt / n) + 1, Ta = {
  linear: (e) => e,
  easeInQuad: (e) => e * e,
  easeOutQuad: (e) => -e * (e - 2),
  easeInOutQuad: (e) => (e /= 0.5) < 1 ? 0.5 * e * e : -0.5 * (--e * (e - 2) - 1),
  easeInCubic: (e) => e * e * e,
  easeOutCubic: (e) => (e -= 1) * e * e + 1,
  easeInOutCubic: (e) => (e /= 0.5) < 1 ? 0.5 * e * e * e : 0.5 * ((e -= 2) * e * e + 2),
  easeInQuart: (e) => e * e * e * e,
  easeOutQuart: (e) => -((e -= 1) * e * e * e - 1),
  easeInOutQuart: (e) => (e /= 0.5) < 1 ? 0.5 * e * e * e * e : -0.5 * ((e -= 2) * e * e * e - 2),
  easeInQuint: (e) => e * e * e * e * e,
  easeOutQuint: (e) => (e -= 1) * e * e * e * e + 1,
  easeInOutQuint: (e) => (e /= 0.5) < 1 ? 0.5 * e * e * e * e * e : 0.5 * ((e -= 2) * e * e * e * e + 2),
  easeInSine: (e) => -Math.cos(e * vt) + 1,
  easeOutSine: (e) => Math.sin(e * vt),
  easeInOutSine: (e) => -0.5 * (Math.cos(lt * e) - 1),
  easeInExpo: (e) => e === 0 ? 0 : Math.pow(2, 10 * (e - 1)),
  easeOutExpo: (e) => e === 1 ? 1 : -Math.pow(2, -10 * e) + 1,
  easeInOutExpo: (e) => Zo(e) ? e : e < 0.5 ? 0.5 * Math.pow(2, 10 * (e * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (e * 2 - 1)) + 2),
  easeInCirc: (e) => e >= 1 ? e : -(Math.sqrt(1 - e * e) - 1),
  easeOutCirc: (e) => Math.sqrt(1 - (e -= 1) * e),
  easeInOutCirc: (e) => (e /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - e * e) - 1) : 0.5 * (Math.sqrt(1 - (e -= 2) * e) + 1),
  easeInElastic: (e) => Zo(e) ? e : Nv(e, 0.075, 0.3),
  easeOutElastic: (e) => Zo(e) ? e : Lv(e, 0.075, 0.3),
  easeInOutElastic(e) {
    return Zo(e) ? e : e < 0.5 ? 0.5 * Nv(e * 2, 0.1125, 0.45) : 0.5 + 0.5 * Lv(e * 2 - 1, 0.1125, 0.45);
  },
  easeInBack(e) {
    return e * e * ((1.70158 + 1) * e - 1.70158);
  },
  easeOutBack(e) {
    return (e -= 1) * e * ((1.70158 + 1) * e + 1.70158) + 1;
  },
  easeInOutBack(e) {
    let t = 1.70158;
    return (e /= 0.5) < 1 ? 0.5 * (e * e * (((t *= 1.525) + 1) * e - t)) : 0.5 * ((e -= 2) * e * (((t *= 1.525) + 1) * e + t) + 2);
  },
  easeInBounce: (e) => 1 - Ta.easeOutBounce(1 - e),
  easeOutBounce(e) {
    return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + 0.75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + 0.9375 : 7.5625 * (e -= 2.625 / 2.75) * e + 0.984375;
  },
  easeInOutBounce: (e) => e < 0.5 ? Ta.easeInBounce(e * 2) * 0.5 : Ta.easeOutBounce(e * 2 - 1) * 0.5 + 0.5
};
function Th(e) {
  if (e && typeof e == "object") {
    const t = e.toString();
    return t === "[object CanvasPattern]" || t === "[object CanvasGradient]";
  }
  return !1;
}
function jv(e) {
  return Th(e) ? e : new Za(e);
}
function Qu(e) {
  return Th(e) ? e : new Za(e).saturate(0.5).darken(0.1).hexString();
}
const W9 = [
  "x",
  "y",
  "borderWidth",
  "radius",
  "tension"
], U9 = [
  "color",
  "borderColor",
  "backgroundColor"
];
function Y9(e) {
  e.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  }), e.describe("animation", {
    _fallback: !1,
    _indexable: !1,
    _scriptable: (t) => t !== "onProgress" && t !== "onComplete" && t !== "fn"
  }), e.set("animations", {
    colors: {
      type: "color",
      properties: U9
    },
    numbers: {
      type: "number",
      properties: W9
    }
  }), e.describe("animations", {
    _fallback: "animation"
  }), e.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (t) => t | 0
        }
      }
    }
  });
}
function q9(e) {
  e.set("layout", {
    autoPadding: !0,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
}
const zv = /* @__PURE__ */ new Map();
function G9(e, t) {
  t = t || {};
  const n = e + JSON.stringify(t);
  let r = zv.get(n);
  return r || (r = new Intl.NumberFormat(e, t), zv.set(n, r)), r;
}
function vu(e, t, n) {
  return G9(t, n).format(e);
}
const Iw = {
  values(e) {
    return gt(e) ? e : "" + e;
  },
  numeric(e, t, n) {
    if (e === 0)
      return "0";
    const r = this.chart.options.locale;
    let i, s = e;
    if (n.length > 1) {
      const c = Math.max(Math.abs(n[0].value), Math.abs(n[n.length - 1].value));
      (c < 1e-4 || c > 1e15) && (i = "scientific"), s = X9(e, n);
    }
    const a = Or(Math.abs(s)), o = isNaN(a) ? 1 : Math.max(Math.min(-1 * Math.floor(a), 20), 0), l = {
      notation: i,
      minimumFractionDigits: o,
      maximumFractionDigits: o
    };
    return Object.assign(l, this.options.ticks.format), vu(e, r, l);
  },
  logarithmic(e, t, n) {
    if (e === 0)
      return "0";
    const r = n[t].significand || e / Math.pow(10, Math.floor(Or(e)));
    return [
      1,
      2,
      3,
      5,
      10,
      15
    ].includes(r) || t > 0.8 * n.length ? Iw.numeric.call(this, e, t, n) : "";
  }
};
function X9(e, t) {
  let n = t.length > 3 ? t[2].value - t[1].value : t[1].value - t[0].value;
  return Math.abs(n) >= 1 && e !== Math.floor(e) && (n = e - Math.floor(e)), n;
}
var mu = {
  formatters: Iw
};
function Z9(e) {
  e.set("scale", {
    display: !0,
    offset: !1,
    reverse: !1,
    beginAtZero: !1,
    bounds: "ticks",
    clip: !0,
    grace: 0,
    grid: {
      display: !0,
      lineWidth: 1,
      drawOnChartArea: !0,
      drawTicks: !0,
      tickLength: 8,
      tickWidth: (t, n) => n.lineWidth,
      tickColor: (t, n) => n.color,
      offset: !1
    },
    border: {
      display: !0,
      dash: [],
      dashOffset: 0,
      width: 1
    },
    title: {
      display: !1,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: !1,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: !0,
      autoSkip: !0,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: mu.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: !1,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  }), e.route("scale.ticks", "color", "", "color"), e.route("scale.grid", "color", "", "borderColor"), e.route("scale.border", "color", "", "borderColor"), e.route("scale.title", "color", "", "color"), e.describe("scale", {
    _fallback: !1,
    _scriptable: (t) => !t.startsWith("before") && !t.startsWith("after") && t !== "callback" && t !== "parser",
    _indexable: (t) => t !== "borderDash" && t !== "tickBorderDash" && t !== "dash"
  }), e.describe("scales", {
    _fallback: "scale"
  }), e.describe("scale.ticks", {
    _scriptable: (t) => t !== "backdropPadding" && t !== "callback",
    _indexable: (t) => t !== "backdropPadding"
  });
}
const yi = /* @__PURE__ */ Object.create(null), zd = /* @__PURE__ */ Object.create(null);
function Oa(e, t) {
  if (!t)
    return e;
  const n = t.split(".");
  for (let r = 0, i = n.length; r < i; ++r) {
    const s = n[r];
    e = e[s] || (e[s] = /* @__PURE__ */ Object.create(null));
  }
  return e;
}
function ef(e, t, n) {
  return typeof t == "string" ? Ka(Oa(e, t), n) : Ka(Oa(e, ""), t);
}
class K9 {
  constructor(t, n) {
    this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = (r) => r.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ], this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    }, this.hover = {}, this.hoverBackgroundColor = (r, i) => Qu(i.backgroundColor), this.hoverBorderColor = (r, i) => Qu(i.borderColor), this.hoverColor = (r, i) => Qu(i.color), this.indexAxis = "x", this.interaction = {
      mode: "nearest",
      intersect: !0,
      includeInvisible: !1
    }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(t), this.apply(n);
  }
  set(t, n) {
    return ef(this, t, n);
  }
  get(t) {
    return Oa(this, t);
  }
  describe(t, n) {
    return ef(zd, t, n);
  }
  override(t, n) {
    return ef(yi, t, n);
  }
  route(t, n, r, i) {
    const s = Oa(this, t), a = Oa(this, r), o = "_" + n;
    Object.defineProperties(s, {
      [o]: {
        value: s[n],
        writable: !0
      },
      [n]: {
        enumerable: !0,
        get() {
          const l = this[o], c = a[i];
          return Me(l) ? Object.assign({}, c, l) : Re(l, c);
        },
        set(l) {
          this[o] = l;
        }
      }
    });
  }
  apply(t) {
    t.forEach((n) => n(this));
  }
}
var mt = /* @__PURE__ */ new K9({
  _scriptable: (e) => !e.startsWith("on"),
  _indexable: (e) => e !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: !1,
    _indexable: !1
  }
}, [
  Y9,
  q9,
  Z9
]);
function J9(e) {
  return !e || Qe(e.size) || Qe(e.family) ? null : (e.style ? e.style + " " : "") + (e.weight ? e.weight + " " : "") + e.size + "px " + e.family;
}
function xc(e, t, n, r, i) {
  let s = t[i];
  return s || (s = t[i] = e.measureText(i).width, n.push(i)), s > r && (r = s), r;
}
function Q9(e, t, n, r) {
  r = r || {};
  let i = r.data = r.data || {}, s = r.garbageCollect = r.garbageCollect || [];
  r.font !== t && (i = r.data = {}, s = r.garbageCollect = [], r.font = t), e.save(), e.font = t;
  let a = 0;
  const o = n.length;
  let l, c, u, f, d;
  for (l = 0; l < o; l++)
    if (f = n[l], f != null && !gt(f))
      a = xc(e, i, s, a, f);
    else if (gt(f))
      for (c = 0, u = f.length; c < u; c++)
        d = f[c], d != null && !gt(d) && (a = xc(e, i, s, a, d));
  e.restore();
  const h = s.length / 2;
  if (h > n.length) {
    for (l = 0; l < h; l++)
      delete i[s[l]];
    s.splice(0, h);
  }
  return a;
}
function Zr(e, t, n) {
  const r = e.currentDevicePixelRatio, i = n !== 0 ? Math.max(n / 2, 0.5) : 0;
  return Math.round((t - i) * r) / r + i;
}
function Vv(e, t) {
  t = t || e.getContext("2d"), t.save(), t.resetTransform(), t.clearRect(0, 0, e.width, e.height), t.restore();
}
function e7(e, t, n, r) {
  t7(e, t, n, r, null);
}
function t7(e, t, n, r, i) {
  let s, a, o, l, c, u, f, d;
  const h = t.pointStyle, p = t.rotation, g = t.radius;
  let v = (p || 0) * O9;
  if (h && typeof h == "object" && (s = h.toString(), s === "[object HTMLImageElement]" || s === "[object HTMLCanvasElement]")) {
    e.save(), e.translate(n, r), e.rotate(v), e.drawImage(h, -h.width / 2, -h.height / 2, h.width, h.height), e.restore();
    return;
  }
  if (!(isNaN(g) || g <= 0)) {
    switch (e.beginPath(), h) {
      default:
        i ? e.ellipse(n, r, i / 2, g, 0, 0, tt) : e.arc(n, r, g, 0, tt), e.closePath();
        break;
      case "triangle":
        u = i ? i / 2 : g, e.moveTo(n + Math.sin(v) * u, r - Math.cos(v) * g), v += Mv, e.lineTo(n + Math.sin(v) * u, r - Math.cos(v) * g), v += Mv, e.lineTo(n + Math.sin(v) * u, r - Math.cos(v) * g), e.closePath();
        break;
      case "rectRounded":
        c = g * 0.516, l = g - c, a = Math.cos(v + Xr) * l, f = Math.cos(v + Xr) * (i ? i / 2 - c : l), o = Math.sin(v + Xr) * l, d = Math.sin(v + Xr) * (i ? i / 2 - c : l), e.arc(n - f, r - o, c, v - lt, v - vt), e.arc(n + d, r - a, c, v - vt, v), e.arc(n + f, r + o, c, v, v + vt), e.arc(n - d, r + a, c, v + vt, v + lt), e.closePath();
        break;
      case "rect":
        if (!p) {
          l = Math.SQRT1_2 * g, u = i ? i / 2 : l, e.rect(n - u, r - l, 2 * u, 2 * l);
          break;
        }
        v += Xr;
      case "rectRot":
        f = Math.cos(v) * (i ? i / 2 : g), a = Math.cos(v) * g, o = Math.sin(v) * g, d = Math.sin(v) * (i ? i / 2 : g), e.moveTo(n - f, r - o), e.lineTo(n + d, r - a), e.lineTo(n + f, r + o), e.lineTo(n - d, r + a), e.closePath();
        break;
      case "crossRot":
        v += Xr;
      case "cross":
        f = Math.cos(v) * (i ? i / 2 : g), a = Math.cos(v) * g, o = Math.sin(v) * g, d = Math.sin(v) * (i ? i / 2 : g), e.moveTo(n - f, r - o), e.lineTo(n + f, r + o), e.moveTo(n + d, r - a), e.lineTo(n - d, r + a);
        break;
      case "star":
        f = Math.cos(v) * (i ? i / 2 : g), a = Math.cos(v) * g, o = Math.sin(v) * g, d = Math.sin(v) * (i ? i / 2 : g), e.moveTo(n - f, r - o), e.lineTo(n + f, r + o), e.moveTo(n + d, r - a), e.lineTo(n - d, r + a), v += Xr, f = Math.cos(v) * (i ? i / 2 : g), a = Math.cos(v) * g, o = Math.sin(v) * g, d = Math.sin(v) * (i ? i / 2 : g), e.moveTo(n - f, r - o), e.lineTo(n + f, r + o), e.moveTo(n + d, r - a), e.lineTo(n - d, r + a);
        break;
      case "line":
        a = i ? i / 2 : Math.cos(v) * g, o = Math.sin(v) * g, e.moveTo(n - a, r - o), e.lineTo(n + a, r + o);
        break;
      case "dash":
        e.moveTo(n, r), e.lineTo(n + Math.cos(v) * (i ? i / 2 : g), r + Math.sin(v) * g);
        break;
      case !1:
        e.closePath();
        break;
    }
    e.fill(), t.borderWidth > 0 && e.stroke();
  }
}
function nr(e, t, n) {
  return n = n || 0.5, !t || e && e.x > t.left - n && e.x < t.right + n && e.y > t.top - n && e.y < t.bottom + n;
}
function Rw(e, t) {
  e.save(), e.beginPath(), e.rect(t.left, t.top, t.right - t.left, t.bottom - t.top), e.clip();
}
function Bw(e) {
  e.restore();
}
function n7(e, t, n, r, i) {
  if (!t)
    return e.lineTo(n.x, n.y);
  if (i === "middle") {
    const s = (t.x + n.x) / 2;
    e.lineTo(s, t.y), e.lineTo(s, n.y);
  } else
    i === "after" != !!r ? e.lineTo(t.x, n.y) : e.lineTo(n.x, t.y);
  e.lineTo(n.x, n.y);
}
function r7(e, t, n, r) {
  if (!t)
    return e.lineTo(n.x, n.y);
  e.bezierCurveTo(r ? t.cp1x : t.cp2x, r ? t.cp1y : t.cp2y, r ? n.cp2x : n.cp1x, r ? n.cp2y : n.cp1y, n.x, n.y);
}
function i7(e, t) {
  t.translation && e.translate(t.translation[0], t.translation[1]), Qe(t.rotation) || e.rotate(t.rotation), t.color && (e.fillStyle = t.color), t.textAlign && (e.textAlign = t.textAlign), t.textBaseline && (e.textBaseline = t.textBaseline);
}
function s7(e, t, n, r, i) {
  if (i.strikethrough || i.underline) {
    const s = e.measureText(r), a = t - s.actualBoundingBoxLeft, o = t + s.actualBoundingBoxRight, l = n - s.actualBoundingBoxAscent, c = n + s.actualBoundingBoxDescent, u = i.strikethrough ? (l + c) / 2 : c;
    e.strokeStyle = e.fillStyle, e.beginPath(), e.lineWidth = i.decorationWidth || 2, e.moveTo(a, u), e.lineTo(o, u), e.stroke();
  }
}
function a7(e, t) {
  const n = e.fillStyle;
  e.fillStyle = t.color, e.fillRect(t.left, t.top, t.width, t.height), e.fillStyle = n;
}
function bc(e, t, n, r, i, s = {}) {
  const a = gt(t) ? t : [
    t
  ], o = s.strokeWidth > 0 && s.strokeColor !== "";
  let l, c;
  for (e.save(), e.font = i.string, i7(e, s), l = 0; l < a.length; ++l)
    c = a[l], s.backdrop && a7(e, s.backdrop), o && (s.strokeColor && (e.strokeStyle = s.strokeColor), Qe(s.strokeWidth) || (e.lineWidth = s.strokeWidth), e.strokeText(c, n, r, s.maxWidth)), e.fillText(c, n, r, s.maxWidth), s7(e, n, r, c, s), r += Number(i.lineHeight);
  e.restore();
}
function o7(e, t) {
  const { x: n, y: r, w: i, h: s, radius: a } = t;
  e.arc(n + a.topLeft, r + a.topLeft, a.topLeft, 1.5 * lt, lt, !0), e.lineTo(n, r + s - a.bottomLeft), e.arc(n + a.bottomLeft, r + s - a.bottomLeft, a.bottomLeft, lt, vt, !0), e.lineTo(n + i - a.bottomRight, r + s), e.arc(n + i - a.bottomRight, r + s - a.bottomRight, a.bottomRight, vt, 0, !0), e.lineTo(n + i, r + a.topRight), e.arc(n + i - a.topRight, r + a.topRight, a.topRight, 0, -vt, !0), e.lineTo(n + a.topLeft, r);
}
const l7 = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/, c7 = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function u7(e, t) {
  const n = ("" + e).match(l7);
  if (!n || n[1] === "normal")
    return t * 1.2;
  switch (e = +n[2], n[3]) {
    case "px":
      return e;
    case "%":
      e /= 100;
      break;
  }
  return t * e;
}
const f7 = (e) => +e || 0;
function Oh(e, t) {
  const n = {}, r = Me(t), i = r ? Object.keys(t) : t, s = Me(e) ? r ? (a) => Re(e[a], e[t[a]]) : (a) => e[a] : () => e;
  for (const a of i)
    n[a] = f7(s(a));
  return n;
}
function d7(e) {
  return Oh(e, {
    top: "y",
    right: "x",
    bottom: "y",
    left: "x"
  });
}
function h7(e) {
  return Oh(e, [
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight"
  ]);
}
function cr(e) {
  const t = d7(e);
  return t.width = t.left + t.right, t.height = t.top + t.bottom, t;
}
function _s(e, t) {
  e = e || {}, t = t || mt.font;
  let n = Re(e.size, t.size);
  typeof n == "string" && (n = parseInt(n, 10));
  let r = Re(e.style, t.style);
  r && !("" + r).match(c7) && (console.warn('Invalid font style specified: "' + r + '"'), r = void 0);
  const i = {
    family: Re(e.family, t.family),
    lineHeight: u7(Re(e.lineHeight, t.lineHeight), n),
    size: n,
    style: r,
    weight: Re(e.weight, t.weight),
    string: ""
  };
  return i.string = J9(i), i;
}
function Ko(e, t, n, r) {
  let i = !0, s, a, o;
  for (s = 0, a = e.length; s < a; ++s)
    if (o = e[s], o !== void 0 && (t !== void 0 && typeof o == "function" && (o = o(t), i = !1), n !== void 0 && gt(o) && (o = o[n % o.length], i = !1), o !== void 0))
      return r && !i && (r.cacheable = !1), o;
}
function p7(e, t, n) {
  const { min: r, max: i } = e, s = Cw(t, (i - r) / 2), a = (o, l) => n && o === 0 ? 0 : o + l;
  return {
    min: a(r, -Math.abs(s)),
    max: a(i, s)
  };
}
function Di(e, t) {
  return Object.assign(Object.create(e), t);
}
function Mh(e, t = [
  ""
], n, r, i = () => e[0]) {
  const s = n || e;
  typeof r > "u" && (r = zw("_fallback", e));
  const a = {
    [Symbol.toStringTag]: "Object",
    _cacheable: !0,
    _scopes: e,
    _rootScopes: s,
    _fallback: r,
    _getTarget: i,
    override: (o) => Mh([
      o,
      ...e
    ], t, s, r)
  };
  return new Proxy(a, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(o, l) {
      return delete o[l], delete o._keys, delete e[0][l], !0;
    },
    /**
    * A trap for getting property values.
    */
    get(o, l) {
      return Lw(o, l, () => w7(l, t, e, o));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(o, l) {
      return Reflect.getOwnPropertyDescriptor(o._scopes[0], l);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(e[0]);
    },
    /**
    * A trap for the in operator.
    */
    has(o, l) {
      return Wv(o).includes(l);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys(o) {
      return Wv(o);
    },
    /**
    * A trap for setting property values.
    */
    set(o, l, c) {
      const u = o._storage || (o._storage = i());
      return o[l] = u[l] = c, delete o._keys, !0;
    }
  });
}
function ws(e, t, n, r) {
  const i = {
    _cacheable: !1,
    _proxy: e,
    _context: t,
    _subProxy: n,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: Nw(e, r),
    setContext: (s) => ws(e, s, n, r),
    override: (s) => ws(e.override(s), t, n, r)
  };
  return new Proxy(i, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(s, a) {
      return delete s[a], delete e[a], !0;
    },
    /**
    * A trap for getting property values.
    */
    get(s, a, o) {
      return Lw(s, a, () => v7(s, a, o));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(s, a) {
      return s._descriptors.allKeys ? Reflect.has(e, a) ? {
        enumerable: !0,
        configurable: !0
      } : void 0 : Reflect.getOwnPropertyDescriptor(e, a);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(e);
    },
    /**
    * A trap for the in operator.
    */
    has(s, a) {
      return Reflect.has(e, a);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys() {
      return Reflect.ownKeys(e);
    },
    /**
    * A trap for setting property values.
    */
    set(s, a, o) {
      return e[a] = o, delete s[a], !0;
    }
  });
}
function Nw(e, t = {
  scriptable: !0,
  indexable: !0
}) {
  const { _scriptable: n = t.scriptable, _indexable: r = t.indexable, _allKeys: i = t.allKeys } = e;
  return {
    allKeys: i,
    scriptable: n,
    indexable: r,
    isScriptable: Br(n) ? n : () => n,
    isIndexable: Br(r) ? r : () => r
  };
}
const g7 = (e, t) => e ? e + Ch(t) : t, Fh = (e, t) => Me(t) && e !== "adapters" && (Object.getPrototypeOf(t) === null || t.constructor === Object);
function Lw(e, t, n) {
  if (Object.prototype.hasOwnProperty.call(e, t))
    return e[t];
  const r = n();
  return e[t] = r, r;
}
function v7(e, t, n) {
  const { _proxy: r, _context: i, _subProxy: s, _descriptors: a } = e;
  let o = r[t];
  return Br(o) && a.isScriptable(t) && (o = m7(t, o, e, n)), gt(o) && o.length && (o = y7(t, o, e, a.isIndexable)), Fh(t, o) && (o = ws(o, i, s && s[t], a)), o;
}
function m7(e, t, n, r) {
  const { _proxy: i, _context: s, _subProxy: a, _stack: o } = n;
  if (o.has(e))
    throw new Error("Recursion detected: " + Array.from(o).join("->") + "->" + e);
  o.add(e);
  let l = t(s, a || r);
  return o.delete(e), Fh(e, l) && (l = Ph(i._scopes, i, e, l)), l;
}
function y7(e, t, n, r) {
  const { _proxy: i, _context: s, _subProxy: a, _descriptors: o } = n;
  if (typeof s.index < "u" && r(e))
    return t[s.index % t.length];
  if (Me(t[0])) {
    const l = t, c = i._scopes.filter((u) => u !== l);
    t = [];
    for (const u of l) {
      const f = Ph(c, i, e, u);
      t.push(ws(f, s, a && a[e], o));
    }
  }
  return t;
}
function jw(e, t, n) {
  return Br(e) ? e(t, n) : e;
}
const x7 = (e, t) => e === !0 ? t : typeof e == "string" ? Ja(t, e) : void 0;
function b7(e, t, n, r, i) {
  for (const s of t) {
    const a = x7(n, s);
    if (a) {
      e.add(a);
      const o = jw(a._fallback, n, i);
      if (typeof o < "u" && o !== n && o !== r)
        return o;
    } else if (a === !1 && typeof r < "u" && n !== r)
      return null;
  }
  return !1;
}
function Ph(e, t, n, r) {
  const i = t._rootScopes, s = jw(t._fallback, n, r), a = [
    ...e,
    ...i
  ], o = /* @__PURE__ */ new Set();
  o.add(r);
  let l = Hv(o, a, n, s || n, r);
  return l === null || typeof s < "u" && s !== n && (l = Hv(o, a, s, l, r), l === null) ? !1 : Mh(Array.from(o), [
    ""
  ], i, s, () => _7(t, n, r));
}
function Hv(e, t, n, r, i) {
  for (; n; )
    n = b7(e, t, n, r, i);
  return n;
}
function _7(e, t, n) {
  const r = e._getTarget();
  t in r || (r[t] = {});
  const i = r[t];
  return gt(i) && Me(n) ? n : i || {};
}
function w7(e, t, n, r) {
  let i;
  for (const s of t)
    if (i = zw(g7(s, e), n), typeof i < "u")
      return Fh(e, i) ? Ph(n, r, e, i) : i;
}
function zw(e, t) {
  for (const n of t) {
    if (!n)
      continue;
    const r = n[e];
    if (typeof r < "u")
      return r;
  }
}
function Wv(e) {
  let t = e._keys;
  return t || (t = e._keys = $7(e._scopes)), t;
}
function $7(e) {
  const t = /* @__PURE__ */ new Set();
  for (const n of e)
    for (const r of Object.keys(n).filter((i) => !i.startsWith("_")))
      t.add(r);
  return Array.from(t);
}
const E7 = Number.EPSILON || 1e-14, $s = (e, t) => t < e.length && !e[t].skip && e[t], Vw = (e) => e === "x" ? "y" : "x";
function A7(e, t, n, r) {
  const i = e.skip ? t : e, s = t, a = n.skip ? t : n, o = Iv(s, i), l = Iv(a, s);
  let c = o / (o + l), u = l / (o + l);
  c = isNaN(c) ? 0 : c, u = isNaN(u) ? 0 : u;
  const f = r * c, d = r * u;
  return {
    previous: {
      x: s.x - f * (a.x - i.x),
      y: s.y - f * (a.y - i.y)
    },
    next: {
      x: s.x + d * (a.x - i.x),
      y: s.y + d * (a.y - i.y)
    }
  };
}
function k7(e, t, n) {
  const r = e.length;
  let i, s, a, o, l, c = $s(e, 0);
  for (let u = 0; u < r - 1; ++u)
    if (l = c, c = $s(e, u + 1), !(!l || !c)) {
      if (Sa(t[u], 0, E7)) {
        n[u] = n[u + 1] = 0;
        continue;
      }
      i = n[u] / t[u], s = n[u + 1] / t[u], o = Math.pow(i, 2) + Math.pow(s, 2), !(o <= 9) && (a = 3 / Math.sqrt(o), n[u] = i * a * t[u], n[u + 1] = s * a * t[u]);
    }
}
function C7(e, t, n = "x") {
  const r = Vw(n), i = e.length;
  let s, a, o, l = $s(e, 0);
  for (let c = 0; c < i; ++c) {
    if (a = o, o = l, l = $s(e, c + 1), !o)
      continue;
    const u = o[n], f = o[r];
    a && (s = (u - a[n]) / 3, o[`cp1${n}`] = u - s, o[`cp1${r}`] = f - s * t[c]), l && (s = (l[n] - u) / 3, o[`cp2${n}`] = u + s, o[`cp2${r}`] = f + s * t[c]);
  }
}
function D7(e, t = "x") {
  const n = Vw(t), r = e.length, i = Array(r).fill(0), s = Array(r);
  let a, o, l, c = $s(e, 0);
  for (a = 0; a < r; ++a)
    if (o = l, l = c, c = $s(e, a + 1), !!l) {
      if (c) {
        const u = c[t] - l[t];
        i[a] = u !== 0 ? (c[n] - l[n]) / u : 0;
      }
      s[a] = o ? c ? bs(i[a - 1]) !== bs(i[a]) ? 0 : (i[a - 1] + i[a]) / 2 : i[a - 1] : i[a];
    }
  k7(e, i, s), C7(e, s, t);
}
function Jo(e, t, n) {
  return Math.max(Math.min(e, n), t);
}
function S7(e, t) {
  let n, r, i, s, a, o = nr(e[0], t);
  for (n = 0, r = e.length; n < r; ++n)
    a = s, s = o, o = n < r - 1 && nr(e[n + 1], t), s && (i = e[n], a && (i.cp1x = Jo(i.cp1x, t.left, t.right), i.cp1y = Jo(i.cp1y, t.top, t.bottom)), o && (i.cp2x = Jo(i.cp2x, t.left, t.right), i.cp2y = Jo(i.cp2y, t.top, t.bottom)));
}
function T7(e, t, n, r, i) {
  let s, a, o, l;
  if (t.spanGaps && (e = e.filter((c) => !c.skip)), t.cubicInterpolationMode === "monotone")
    D7(e, i);
  else {
    let c = r ? e[e.length - 1] : e[0];
    for (s = 0, a = e.length; s < a; ++s)
      o = e[s], l = A7(c, o, e[Math.min(s + 1, a - (r ? 0 : 1)) % a], t.tension), o.cp1x = l.previous.x, o.cp1y = l.previous.y, o.cp2x = l.next.x, o.cp2y = l.next.y, c = o;
  }
  t.capBezierPoints && S7(e, n);
}
function Ih() {
  return typeof window < "u" && typeof document < "u";
}
function Rh(e) {
  let t = e.parentNode;
  return t && t.toString() === "[object ShadowRoot]" && (t = t.host), t;
}
function _c(e, t, n) {
  let r;
  return typeof e == "string" ? (r = parseInt(e, 10), e.indexOf("%") !== -1 && (r = r / 100 * t.parentNode[n])) : r = e, r;
}
const yu = (e) => e.ownerDocument.defaultView.getComputedStyle(e, null);
function O7(e, t) {
  return yu(e).getPropertyValue(t);
}
const M7 = [
  "top",
  "right",
  "bottom",
  "left"
];
function fi(e, t, n) {
  const r = {};
  n = n ? "-" + n : "";
  for (let i = 0; i < 4; i++) {
    const s = M7[i];
    r[s] = parseFloat(e[t + "-" + s + n]) || 0;
  }
  return r.width = r.left + r.right, r.height = r.top + r.bottom, r;
}
const F7 = (e, t, n) => (e > 0 || t > 0) && (!n || !n.shadowRoot);
function P7(e, t) {
  const n = e.touches, r = n && n.length ? n[0] : e, { offsetX: i, offsetY: s } = r;
  let a = !1, o, l;
  if (F7(i, s, e.target))
    o = i, l = s;
  else {
    const c = t.getBoundingClientRect();
    o = r.clientX - c.left, l = r.clientY - c.top, a = !0;
  }
  return {
    x: o,
    y: l,
    box: a
  };
}
function ei(e, t) {
  if ("native" in e)
    return e;
  const { canvas: n, currentDevicePixelRatio: r } = t, i = yu(n), s = i.boxSizing === "border-box", a = fi(i, "padding"), o = fi(i, "border", "width"), { x: l, y: c, box: u } = P7(e, n), f = a.left + (u && o.left), d = a.top + (u && o.top);
  let { width: h, height: p } = t;
  return s && (h -= a.width + o.width, p -= a.height + o.height), {
    x: Math.round((l - f) / h * n.width / r),
    y: Math.round((c - d) / p * n.height / r)
  };
}
function I7(e, t, n) {
  let r, i;
  if (t === void 0 || n === void 0) {
    const s = Rh(e);
    if (!s)
      t = e.clientWidth, n = e.clientHeight;
    else {
      const a = s.getBoundingClientRect(), o = yu(s), l = fi(o, "border", "width"), c = fi(o, "padding");
      t = a.width - c.width - l.width, n = a.height - c.height - l.height, r = _c(o.maxWidth, s, "clientWidth"), i = _c(o.maxHeight, s, "clientHeight");
    }
  }
  return {
    width: t,
    height: n,
    maxWidth: r || yc,
    maxHeight: i || yc
  };
}
const Qo = (e) => Math.round(e * 10) / 10;
function R7(e, t, n, r) {
  const i = yu(e), s = fi(i, "margin"), a = _c(i.maxWidth, e, "clientWidth") || yc, o = _c(i.maxHeight, e, "clientHeight") || yc, l = I7(e, t, n);
  let { width: c, height: u } = l;
  if (i.boxSizing === "content-box") {
    const d = fi(i, "border", "width"), h = fi(i, "padding");
    c -= h.width + d.width, u -= h.height + d.height;
  }
  return c = Math.max(0, c - s.width), u = Math.max(0, r ? c / r : u - s.height), c = Qo(Math.min(c, a, l.maxWidth)), u = Qo(Math.min(u, o, l.maxHeight)), c && !u && (u = Qo(c / 2)), (t !== void 0 || n !== void 0) && r && l.height && u > l.height && (u = l.height, c = Qo(Math.floor(u * r))), {
    width: c,
    height: u
  };
}
function Uv(e, t, n) {
  const r = t || 1, i = Math.floor(e.height * r), s = Math.floor(e.width * r);
  e.height = Math.floor(e.height), e.width = Math.floor(e.width);
  const a = e.canvas;
  return a.style && (n || !a.style.height && !a.style.width) && (a.style.height = `${e.height}px`, a.style.width = `${e.width}px`), e.currentDevicePixelRatio !== r || a.height !== i || a.width !== s ? (e.currentDevicePixelRatio = r, a.height = i, a.width = s, e.ctx.setTransform(r, 0, 0, r, 0, 0), !0) : !1;
}
const B7 = function() {
  let e = !1;
  try {
    const t = {
      get passive() {
        return e = !0, !1;
      }
    };
    Ih() && (window.addEventListener("test", null, t), window.removeEventListener("test", null, t));
  } catch {
  }
  return e;
}();
function Yv(e, t) {
  const n = O7(e, t), r = n && n.match(/^(\d+)(\.\d+)?px$/);
  return r ? +r[1] : void 0;
}
function ti(e, t, n, r) {
  return {
    x: e.x + n * (t.x - e.x),
    y: e.y + n * (t.y - e.y)
  };
}
function N7(e, t, n, r) {
  return {
    x: e.x + n * (t.x - e.x),
    y: r === "middle" ? n < 0.5 ? e.y : t.y : r === "after" ? n < 1 ? e.y : t.y : n > 0 ? t.y : e.y
  };
}
function L7(e, t, n, r) {
  const i = {
    x: e.cp2x,
    y: e.cp2y
  }, s = {
    x: t.cp1x,
    y: t.cp1y
  }, a = ti(e, i, n), o = ti(i, s, n), l = ti(s, t, n), c = ti(a, o, n), u = ti(o, l, n);
  return ti(c, u, n);
}
function Hw(e) {
  return e === "angle" ? {
    between: eo,
    compare: P9,
    normalize: En
  } : {
    between: Ow,
    compare: (t, n) => t - n,
    normalize: (t) => t
  };
}
function qv({ start: e, end: t, count: n, loop: r, style: i }) {
  return {
    start: e % n,
    end: t % n,
    loop: r && (t - e + 1) % n === 0,
    style: i
  };
}
function j7(e, t, n) {
  const { property: r, start: i, end: s } = n, { between: a, normalize: o } = Hw(r), l = t.length;
  let { start: c, end: u, loop: f } = e, d, h;
  if (f) {
    for (c += l, u += l, d = 0, h = l; d < h && a(o(t[c % l][r]), i, s); ++d)
      c--, u--;
    c %= l, u %= l;
  }
  return u < c && (u += l), {
    start: c,
    end: u,
    loop: f,
    style: e.style
  };
}
function z7(e, t, n) {
  if (!n)
    return [
      e
    ];
  const { property: r, start: i, end: s } = n, a = t.length, { compare: o, between: l, normalize: c } = Hw(r), { start: u, end: f, loop: d, style: h } = j7(e, t, n), p = [];
  let g = !1, v = null, m, x, _;
  const y = () => l(i, _, m) && o(i, _) !== 0, b = () => o(s, m) === 0 || l(s, _, m), w = () => g || y(), E = () => !g || b();
  for (let $ = u, C = u; $ <= f; ++$)
    x = t[$ % a], !x.skip && (m = c(x[r]), m !== _ && (g = l(m, i, s), v === null && w() && (v = o(m, i) === 0 ? $ : C), v !== null && E() && (p.push(qv({
      start: v,
      end: $,
      loop: d,
      count: a,
      style: h
    })), v = null), C = $, _ = m));
  return v !== null && p.push(qv({
    start: v,
    end: f,
    loop: d,
    count: a,
    style: h
  })), p;
}
function V7(e, t) {
  const n = [], r = e.segments;
  for (let i = 0; i < r.length; i++) {
    const s = z7(r[i], e.points, t);
    s.length && n.push(...s);
  }
  return n;
}
function H7(e, t, n, r) {
  let i = 0, s = t - 1;
  if (n && !r)
    for (; i < t && !e[i].skip; )
      i++;
  for (; i < t && e[i].skip; )
    i++;
  for (i %= t, n && (s += i); s > i && e[s % t].skip; )
    s--;
  return s %= t, {
    start: i,
    end: s
  };
}
function W7(e, t, n, r) {
  const i = e.length, s = [];
  let a = t, o = e[t], l;
  for (l = t + 1; l <= n; ++l) {
    const c = e[l % i];
    c.skip || c.stop ? o.skip || (r = !1, s.push({
      start: t % i,
      end: (l - 1) % i,
      loop: r
    }), t = a = c.stop ? l : null) : (a = l, o.skip && (t = l)), o = c;
  }
  return a !== null && s.push({
    start: t % i,
    end: a % i,
    loop: r
  }), s;
}
function U7(e, t) {
  const n = e.points, r = e.options.spanGaps, i = n.length;
  if (!i)
    return [];
  const s = !!e._loop, { start: a, end: o } = H7(n, i, s, r);
  if (r === !0)
    return Gv(e, [
      {
        start: a,
        end: o,
        loop: s
      }
    ], n, t);
  const l = o < a ? o + i : o, c = !!e._fullLoop && a === 0 && o === i - 1;
  return Gv(e, W7(n, a, l, c), n, t);
}
function Gv(e, t, n, r) {
  return !r || !r.setContext || !n ? t : Y7(e, t, n, r);
}
function Y7(e, t, n, r) {
  const i = e._chart.getContext(), s = Xv(e.options), { _datasetIndex: a, options: { spanGaps: o } } = e, l = n.length, c = [];
  let u = s, f = t[0].start, d = f;
  function h(p, g, v, m) {
    const x = o ? -1 : 1;
    if (p !== g) {
      for (p += l; n[p % l].skip; )
        p -= x;
      for (; n[g % l].skip; )
        g += x;
      p % l !== g % l && (c.push({
        start: p % l,
        end: g % l,
        loop: v,
        style: m
      }), u = m, f = g % l);
    }
  }
  for (const p of t) {
    f = o ? f : p.start;
    let g = n[f % l], v;
    for (d = f + 1; d <= p.end; d++) {
      const m = n[d % l];
      v = Xv(r.setContext(Di(i, {
        type: "segment",
        p0: g,
        p1: m,
        p0DataIndex: (d - 1) % l,
        p1DataIndex: d % l,
        datasetIndex: a
      }))), q7(v, u) && h(f, d - 1, p.loop, u), g = m, u = v;
    }
    f < d - 1 && h(f, d - 1, p.loop, u);
  }
  return c;
}
function Xv(e) {
  return {
    backgroundColor: e.backgroundColor,
    borderCapStyle: e.borderCapStyle,
    borderDash: e.borderDash,
    borderDashOffset: e.borderDashOffset,
    borderJoinStyle: e.borderJoinStyle,
    borderWidth: e.borderWidth,
    borderColor: e.borderColor
  };
}
function q7(e, t) {
  if (!t)
    return !1;
  const n = [], r = function(i, s) {
    return Th(s) ? (n.includes(s) || n.push(s), n.indexOf(s)) : s;
  };
  return JSON.stringify(e, r) !== JSON.stringify(t, r);
}
/*!
 * Chart.js v4.4.1
 * https://www.chartjs.org
 * (c) 2023 Chart.js Contributors
 * Released under the MIT License
 */
class G7 {
  constructor() {
    this._request = null, this._charts = /* @__PURE__ */ new Map(), this._running = !1, this._lastDate = void 0;
  }
  _notify(t, n, r, i) {
    const s = n.listeners[i], a = n.duration;
    s.forEach((o) => o({
      chart: t,
      initial: n.initial,
      numSteps: a,
      currentStep: Math.min(r - n.start, a)
    }));
  }
  _refresh() {
    this._request || (this._running = !0, this._request = Fw.call(window, () => {
      this._update(), this._request = null, this._running && this._refresh();
    }));
  }
  _update(t = Date.now()) {
    let n = 0;
    this._charts.forEach((r, i) => {
      if (!r.running || !r.items.length)
        return;
      const s = r.items;
      let a = s.length - 1, o = !1, l;
      for (; a >= 0; --a)
        l = s[a], l._active ? (l._total > r.duration && (r.duration = l._total), l.tick(t), o = !0) : (s[a] = s[s.length - 1], s.pop());
      o && (i.draw(), this._notify(i, r, t, "progress")), s.length || (r.running = !1, this._notify(i, r, t, "complete"), r.initial = !1), n += s.length;
    }), this._lastDate = t, n === 0 && (this._running = !1);
  }
  _getAnims(t) {
    const n = this._charts;
    let r = n.get(t);
    return r || (r = {
      running: !1,
      initial: !0,
      items: [],
      listeners: {
        complete: [],
        progress: []
      }
    }, n.set(t, r)), r;
  }
  listen(t, n, r) {
    this._getAnims(t).listeners[n].push(r);
  }
  add(t, n) {
    !n || !n.length || this._getAnims(t).items.push(...n);
  }
  has(t) {
    return this._getAnims(t).items.length > 0;
  }
  start(t) {
    const n = this._charts.get(t);
    n && (n.running = !0, n.start = Date.now(), n.duration = n.items.reduce((r, i) => Math.max(r, i._duration), 0), this._refresh());
  }
  running(t) {
    if (!this._running)
      return !1;
    const n = this._charts.get(t);
    return !(!n || !n.running || !n.items.length);
  }
  stop(t) {
    const n = this._charts.get(t);
    if (!n || !n.items.length)
      return;
    const r = n.items;
    let i = r.length - 1;
    for (; i >= 0; --i)
      r[i].cancel();
    n.items = [], this._notify(t, n, Date.now(), "complete");
  }
  remove(t) {
    return this._charts.delete(t);
  }
}
var Xn = /* @__PURE__ */ new G7();
const Zv = "transparent", X7 = {
  boolean(e, t, n) {
    return n > 0.5 ? t : e;
  },
  color(e, t, n) {
    const r = jv(e || Zv), i = r.valid && jv(t || Zv);
    return i && i.valid ? i.mix(r, n).hexString() : t;
  },
  number(e, t, n) {
    return e + (t - e) * n;
  }
};
class Z7 {
  constructor(t, n, r, i) {
    const s = n[r];
    i = Ko([
      t.to,
      i,
      s,
      t.from
    ]);
    const a = Ko([
      t.from,
      s,
      i
    ]);
    this._active = !0, this._fn = t.fn || X7[t.type || typeof a], this._easing = Ta[t.easing] || Ta.linear, this._start = Math.floor(Date.now() + (t.delay || 0)), this._duration = this._total = Math.floor(t.duration), this._loop = !!t.loop, this._target = n, this._prop = r, this._from = a, this._to = i, this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(t, n, r) {
    if (this._active) {
      this._notify(!1);
      const i = this._target[this._prop], s = r - this._start, a = this._duration - s;
      this._start = r, this._duration = Math.floor(Math.max(a, t.duration)), this._total += s, this._loop = !!t.loop, this._to = Ko([
        t.to,
        n,
        i,
        t.from
      ]), this._from = Ko([
        t.from,
        i,
        n
      ]);
    }
  }
  cancel() {
    this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1));
  }
  tick(t) {
    const n = t - this._start, r = this._duration, i = this._prop, s = this._from, a = this._loop, o = this._to;
    let l;
    if (this._active = s !== o && (a || n < r), !this._active) {
      this._target[i] = o, this._notify(!0);
      return;
    }
    if (n < 0) {
      this._target[i] = s;
      return;
    }
    l = n / r % 2, l = a && l > 1 ? 2 - l : l, l = this._easing(Math.min(1, Math.max(0, l))), this._target[i] = this._fn(s, o, l);
  }
  wait() {
    const t = this._promises || (this._promises = []);
    return new Promise((n, r) => {
      t.push({
        res: n,
        rej: r
      });
    });
  }
  _notify(t) {
    const n = t ? "res" : "rej", r = this._promises || [];
    for (let i = 0; i < r.length; i++)
      r[i][n]();
  }
}
class K7 {
  constructor(t, n) {
    this._chart = t, this._properties = /* @__PURE__ */ new Map(), this.configure(n);
  }
  configure(t) {
    if (!Me(t))
      return;
    const n = Object.keys(mt.animation), r = this._properties;
    Object.getOwnPropertyNames(t).forEach((i) => {
      const s = t[i];
      if (!Me(s))
        return;
      const a = {};
      for (const o of n)
        a[o] = s[o];
      (gt(s.properties) && s.properties || [
        i
      ]).forEach((o) => {
        (o === i || !r.has(o)) && r.set(o, a);
      });
    });
  }
  _animateOptions(t, n) {
    const r = n.options, i = Q7(t, r);
    if (!i)
      return [];
    const s = this._createAnimations(i, r);
    return r.$shared && J7(t.options.$animations, r).then(() => {
      t.options = r;
    }, () => {
    }), s;
  }
  _createAnimations(t, n) {
    const r = this._properties, i = [], s = t.$animations || (t.$animations = {}), a = Object.keys(n), o = Date.now();
    let l;
    for (l = a.length - 1; l >= 0; --l) {
      const c = a[l];
      if (c.charAt(0) === "$")
        continue;
      if (c === "options") {
        i.push(...this._animateOptions(t, n));
        continue;
      }
      const u = n[c];
      let f = s[c];
      const d = r.get(c);
      if (f)
        if (d && f.active()) {
          f.update(d, u, o);
          continue;
        } else
          f.cancel();
      if (!d || !d.duration) {
        t[c] = u;
        continue;
      }
      s[c] = f = new Z7(d, t, c, u), i.push(f);
    }
    return i;
  }
  update(t, n) {
    if (this._properties.size === 0) {
      Object.assign(t, n);
      return;
    }
    const r = this._createAnimations(t, n);
    if (r.length)
      return Xn.add(this._chart, r), !0;
  }
}
function J7(e, t) {
  const n = [], r = Object.keys(t);
  for (let i = 0; i < r.length; i++) {
    const s = e[r[i]];
    s && s.active() && n.push(s.wait());
  }
  return Promise.all(n);
}
function Q7(e, t) {
  if (!t)
    return;
  let n = e.options;
  if (!n) {
    e.options = t;
    return;
  }
  return n.$shared && (e.options = n = Object.assign({}, n, {
    $shared: !1,
    $animations: {}
  })), n;
}
function Kv(e, t) {
  const n = e && e.options || {}, r = n.reverse, i = n.min === void 0 ? t : 0, s = n.max === void 0 ? t : 0;
  return {
    start: r ? s : i,
    end: r ? i : s
  };
}
function ej(e, t, n) {
  if (n === !1)
    return !1;
  const r = Kv(e, n), i = Kv(t, n);
  return {
    top: i.end,
    right: r.end,
    bottom: i.start,
    left: r.start
  };
}
function tj(e) {
  let t, n, r, i;
  return Me(e) ? (t = e.top, n = e.right, r = e.bottom, i = e.left) : t = n = r = i = e, {
    top: t,
    right: n,
    bottom: r,
    left: i,
    disabled: e === !1
  };
}
function Ww(e, t) {
  const n = [], r = e._getSortedDatasetMetas(t);
  let i, s;
  for (i = 0, s = r.length; i < s; ++i)
    n.push(r[i].index);
  return n;
}
function Jv(e, t, n, r = {}) {
  const i = e.keys, s = r.mode === "single";
  let a, o, l, c;
  if (t !== null) {
    for (a = 0, o = i.length; a < o; ++a) {
      if (l = +i[a], l === n) {
        if (r.all)
          continue;
        break;
      }
      c = e.values[l], kt(c) && (s || t === 0 || bs(t) === bs(c)) && (t += c);
    }
    return t;
  }
}
function nj(e) {
  const t = Object.keys(e), n = new Array(t.length);
  let r, i, s;
  for (r = 0, i = t.length; r < i; ++r)
    s = t[r], n[r] = {
      x: s,
      y: e[s]
    };
  return n;
}
function Qv(e, t) {
  const n = e && e.options.stacked;
  return n || n === void 0 && t.stack !== void 0;
}
function rj(e, t, n) {
  return `${e.id}.${t.id}.${n.stack || n.type}`;
}
function ij(e) {
  const { min: t, max: n, minDefined: r, maxDefined: i } = e.getUserBounds();
  return {
    min: r ? t : Number.NEGATIVE_INFINITY,
    max: i ? n : Number.POSITIVE_INFINITY
  };
}
function sj(e, t, n) {
  const r = e[t] || (e[t] = {});
  return r[n] || (r[n] = {});
}
function em(e, t, n, r) {
  for (const i of t.getMatchingVisibleMetas(r).reverse()) {
    const s = e[i.index];
    if (n && s > 0 || !n && s < 0)
      return i.index;
  }
  return null;
}
function tm(e, t) {
  const { chart: n, _cachedMeta: r } = e, i = n._stacks || (n._stacks = {}), { iScale: s, vScale: a, index: o } = r, l = s.axis, c = a.axis, u = rj(s, a, r), f = t.length;
  let d;
  for (let h = 0; h < f; ++h) {
    const p = t[h], { [l]: g, [c]: v } = p, m = p._stacks || (p._stacks = {});
    d = m[c] = sj(i, u, g), d[o] = v, d._top = em(d, a, !0, r.type), d._bottom = em(d, a, !1, r.type);
    const x = d._visualValues || (d._visualValues = {});
    x[o] = v;
  }
}
function tf(e, t) {
  const n = e.scales;
  return Object.keys(n).filter((r) => n[r].axis === t).shift();
}
function aj(e, t) {
  return Di(e, {
    active: !1,
    dataset: void 0,
    datasetIndex: t,
    index: t,
    mode: "default",
    type: "dataset"
  });
}
function oj(e, t, n) {
  return Di(e, {
    active: !1,
    dataIndex: t,
    parsed: void 0,
    raw: void 0,
    element: n,
    index: t,
    mode: "default",
    type: "data"
  });
}
function ra(e, t) {
  const n = e.controller.index, r = e.vScale && e.vScale.axis;
  if (r) {
    t = t || e._parsed;
    for (const i of t) {
      const s = i._stacks;
      if (!s || s[r] === void 0 || s[r][n] === void 0)
        return;
      delete s[r][n], s[r]._visualValues !== void 0 && s[r]._visualValues[n] !== void 0 && delete s[r]._visualValues[n];
    }
  }
}
const nf = (e) => e === "reset" || e === "none", nm = (e, t) => t ? e : Object.assign({}, e), lj = (e, t, n) => e && !t.hidden && t._stacked && {
  keys: Ww(n, !0),
  values: null
};
class us {
  constructor(t, n) {
    this.chart = t, this._ctx = t.ctx, this.index = n, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize();
  }
  initialize() {
    const t = this._cachedMeta;
    this.configure(), this.linkScales(), t._stacked = Qv(t.vScale, t), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
  }
  updateIndex(t) {
    this.index !== t && ra(this._cachedMeta), this.index = t;
  }
  linkScales() {
    const t = this.chart, n = this._cachedMeta, r = this.getDataset(), i = (f, d, h, p) => f === "x" ? d : f === "r" ? p : h, s = n.xAxisID = Re(r.xAxisID, tf(t, "x")), a = n.yAxisID = Re(r.yAxisID, tf(t, "y")), o = n.rAxisID = Re(r.rAxisID, tf(t, "r")), l = n.indexAxis, c = n.iAxisID = i(l, s, a, o), u = n.vAxisID = i(l, a, s, o);
    n.xScale = this.getScaleForId(s), n.yScale = this.getScaleForId(a), n.rScale = this.getScaleForId(o), n.iScale = this.getScaleForId(c), n.vScale = this.getScaleForId(u);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(t) {
    return this.chart.scales[t];
  }
  _getOtherScale(t) {
    const n = this._cachedMeta;
    return t === n.iScale ? n.vScale : n.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const t = this._cachedMeta;
    this._data && Rv(this._data, this), t._stacked && ra(t);
  }
  _dataCheck() {
    const t = this.getDataset(), n = t.data || (t.data = []), r = this._data;
    if (Me(n))
      this._data = nj(n);
    else if (r !== n) {
      if (r) {
        Rv(r, this);
        const i = this._cachedMeta;
        ra(i), i._parsed = [];
      }
      n && Object.isExtensible(n) && N9(n, this), this._syncList = [], this._data = n;
    }
  }
  addElements() {
    const t = this._cachedMeta;
    this._dataCheck(), this.datasetElementType && (t.dataset = new this.datasetElementType());
  }
  buildOrUpdateElements(t) {
    const n = this._cachedMeta, r = this.getDataset();
    let i = !1;
    this._dataCheck();
    const s = n._stacked;
    n._stacked = Qv(n.vScale, n), n.stack !== r.stack && (i = !0, ra(n), n.stack = r.stack), this._resyncElements(t), (i || s !== n._stacked) && tm(this, n._parsed);
  }
  configure() {
    const t = this.chart.config, n = t.datasetScopeKeys(this._type), r = t.getOptionScopes(this.getDataset(), n, !0);
    this.options = t.createResolver(r, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {};
  }
  parse(t, n) {
    const { _cachedMeta: r, _data: i } = this, { iScale: s, _stacked: a } = r, o = s.axis;
    let l = t === 0 && n === i.length ? !0 : r._sorted, c = t > 0 && r._parsed[t - 1], u, f, d;
    if (this._parsing === !1)
      r._parsed = i, r._sorted = !0, d = i;
    else {
      gt(i[t]) ? d = this.parseArrayData(r, i, t, n) : Me(i[t]) ? d = this.parseObjectData(r, i, t, n) : d = this.parsePrimitiveData(r, i, t, n);
      const h = () => f[o] === null || c && f[o] < c[o];
      for (u = 0; u < n; ++u)
        r._parsed[u + t] = f = d[u], l && (h() && (l = !1), c = f);
      r._sorted = l;
    }
    a && tm(this, d);
  }
  parsePrimitiveData(t, n, r, i) {
    const { iScale: s, vScale: a } = t, o = s.axis, l = a.axis, c = s.getLabels(), u = s === a, f = new Array(i);
    let d, h, p;
    for (d = 0, h = i; d < h; ++d)
      p = d + r, f[d] = {
        [o]: u || s.parse(c[p], p),
        [l]: a.parse(n[p], p)
      };
    return f;
  }
  parseArrayData(t, n, r, i) {
    const { xScale: s, yScale: a } = t, o = new Array(i);
    let l, c, u, f;
    for (l = 0, c = i; l < c; ++l)
      u = l + r, f = n[u], o[l] = {
        x: s.parse(f[0], u),
        y: a.parse(f[1], u)
      };
    return o;
  }
  parseObjectData(t, n, r, i) {
    const { xScale: s, yScale: a } = t, { xAxisKey: o = "x", yAxisKey: l = "y" } = this._parsing, c = new Array(i);
    let u, f, d, h;
    for (u = 0, f = i; u < f; ++u)
      d = u + r, h = n[d], c[u] = {
        x: s.parse(Ja(h, o), d),
        y: a.parse(Ja(h, l), d)
      };
    return c;
  }
  getParsed(t) {
    return this._cachedMeta._parsed[t];
  }
  getDataElement(t) {
    return this._cachedMeta.data[t];
  }
  applyStack(t, n, r) {
    const i = this.chart, s = this._cachedMeta, a = n[t.axis], o = {
      keys: Ww(i, !0),
      values: n._stacks[t.axis]._visualValues
    };
    return Jv(o, a, s.index, {
      mode: r
    });
  }
  updateRangeFromParsed(t, n, r, i) {
    const s = r[n.axis];
    let a = s === null ? NaN : s;
    const o = i && r._stacks[n.axis];
    i && o && (i.values = o, a = Jv(i, s, this._cachedMeta.index)), t.min = Math.min(t.min, a), t.max = Math.max(t.max, a);
  }
  getMinMax(t, n) {
    const r = this._cachedMeta, i = r._parsed, s = r._sorted && t === r.iScale, a = i.length, o = this._getOtherScale(t), l = lj(n, r, this.chart), c = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    }, { min: u, max: f } = ij(o);
    let d, h;
    function p() {
      h = i[d];
      const g = h[o.axis];
      return !kt(h[t.axis]) || u > g || f < g;
    }
    for (d = 0; d < a && !(!p() && (this.updateRangeFromParsed(c, t, h, l), s)); ++d)
      ;
    if (s) {
      for (d = a - 1; d >= 0; --d)
        if (!p()) {
          this.updateRangeFromParsed(c, t, h, l);
          break;
        }
    }
    return c;
  }
  getAllParsedValues(t) {
    const n = this._cachedMeta._parsed, r = [];
    let i, s, a;
    for (i = 0, s = n.length; i < s; ++i)
      a = n[i][t.axis], kt(a) && r.push(a);
    return r;
  }
  getMaxOverflow() {
    return !1;
  }
  getLabelAndValue(t) {
    const n = this._cachedMeta, r = n.iScale, i = n.vScale, s = this.getParsed(t);
    return {
      label: r ? "" + r.getLabelForValue(s[r.axis]) : "",
      value: i ? "" + i.getLabelForValue(s[i.axis]) : ""
    };
  }
  _update(t) {
    const n = this._cachedMeta;
    this.update(t || "default"), n._clip = tj(Re(this.options.clip, ej(n.xScale, n.yScale, this.getMaxOverflow())));
  }
  update(t) {
  }
  draw() {
    const t = this._ctx, n = this.chart, r = this._cachedMeta, i = r.data || [], s = n.chartArea, a = [], o = this._drawStart || 0, l = this._drawCount || i.length - o, c = this.options.drawActiveElementsOnTop;
    let u;
    for (r.dataset && r.dataset.draw(t, s, o, l), u = o; u < o + l; ++u) {
      const f = i[u];
      f.hidden || (f.active && c ? a.push(f) : f.draw(t, s));
    }
    for (u = 0; u < a.length; ++u)
      a[u].draw(t, s);
  }
  getStyle(t, n) {
    const r = n ? "active" : "default";
    return t === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(r) : this.resolveDataElementOptions(t || 0, r);
  }
  getContext(t, n, r) {
    const i = this.getDataset();
    let s;
    if (t >= 0 && t < this._cachedMeta.data.length) {
      const a = this._cachedMeta.data[t];
      s = a.$context || (a.$context = oj(this.getContext(), t, a)), s.parsed = this.getParsed(t), s.raw = i.data[t], s.index = s.dataIndex = t;
    } else
      s = this.$context || (this.$context = aj(this.chart.getContext(), this.index)), s.dataset = i, s.index = s.datasetIndex = this.index;
    return s.active = !!n, s.mode = r, s;
  }
  resolveDatasetElementOptions(t) {
    return this._resolveElementOptions(this.datasetElementType.id, t);
  }
  resolveDataElementOptions(t, n) {
    return this._resolveElementOptions(this.dataElementType.id, n, t);
  }
  _resolveElementOptions(t, n = "default", r) {
    const i = n === "active", s = this._cachedDataOpts, a = t + "-" + n, o = s[a], l = this.enableOptionSharing && mc(r);
    if (o)
      return nm(o, l);
    const c = this.chart.config, u = c.datasetElementScopeKeys(this._type, t), f = i ? [
      `${t}Hover`,
      "hover",
      t,
      ""
    ] : [
      t,
      ""
    ], d = c.getOptionScopes(this.getDataset(), u), h = Object.keys(mt.elements[t]), p = () => this.getContext(r, i, n), g = c.resolveNamedOptions(d, h, p, f);
    return g.$shared && (g.$shared = l, s[a] = Object.freeze(nm(g, l))), g;
  }
  _resolveAnimations(t, n, r) {
    const i = this.chart, s = this._cachedDataOpts, a = `animation-${n}`, o = s[a];
    if (o)
      return o;
    let l;
    if (i.options.animation !== !1) {
      const u = this.chart.config, f = u.datasetAnimationScopeKeys(this._type, n), d = u.getOptionScopes(this.getDataset(), f);
      l = u.createResolver(d, this.getContext(t, r, n));
    }
    const c = new K7(i, l && l.animations);
    return l && l._cacheable && (s[a] = Object.freeze(c)), c;
  }
  getSharedOptions(t) {
    if (t.$shared)
      return this._sharedOptions || (this._sharedOptions = Object.assign({}, t));
  }
  includeOptions(t, n) {
    return !n || nf(t) || this.chart._animationsDisabled;
  }
  _getSharedOptions(t, n) {
    const r = this.resolveDataElementOptions(t, n), i = this._sharedOptions, s = this.getSharedOptions(r), a = this.includeOptions(n, s) || s !== i;
    return this.updateSharedOptions(s, n, r), {
      sharedOptions: s,
      includeOptions: a
    };
  }
  updateElement(t, n, r, i) {
    nf(i) ? Object.assign(t, r) : this._resolveAnimations(n, i).update(t, r);
  }
  updateSharedOptions(t, n, r) {
    t && !nf(n) && this._resolveAnimations(void 0, n).update(t, r);
  }
  _setStyle(t, n, r, i) {
    t.active = i;
    const s = this.getStyle(n, i);
    this._resolveAnimations(n, r, i).update(t, {
      options: !i && this.getSharedOptions(s) || s
    });
  }
  removeHoverStyle(t, n, r) {
    this._setStyle(t, r, "active", !1);
  }
  setHoverStyle(t, n, r) {
    this._setStyle(t, r, "active", !0);
  }
  _removeDatasetHoverStyle() {
    const t = this._cachedMeta.dataset;
    t && this._setStyle(t, void 0, "active", !1);
  }
  _setDatasetHoverStyle() {
    const t = this._cachedMeta.dataset;
    t && this._setStyle(t, void 0, "active", !0);
  }
  _resyncElements(t) {
    const n = this._data, r = this._cachedMeta.data;
    for (const [o, l, c] of this._syncList)
      this[o](l, c);
    this._syncList = [];
    const i = r.length, s = n.length, a = Math.min(s, i);
    a && this.parse(0, a), s > i ? this._insertElements(i, s - i, t) : s < i && this._removeElements(s, i - s);
  }
  _insertElements(t, n, r = !0) {
    const i = this._cachedMeta, s = i.data, a = t + n;
    let o;
    const l = (c) => {
      for (c.length += n, o = c.length - 1; o >= a; o--)
        c[o] = c[o - n];
    };
    for (l(s), o = t; o < a; ++o)
      s[o] = new this.dataElementType();
    this._parsing && l(i._parsed), this.parse(t, n), r && this.updateElements(s, t, n, "reset");
  }
  updateElements(t, n, r, i) {
  }
  _removeElements(t, n) {
    const r = this._cachedMeta;
    if (this._parsing) {
      const i = r._parsed.splice(t, n);
      r._stacked && ra(r, i);
    }
    r.data.splice(t, n);
  }
  _sync(t) {
    if (this._parsing)
      this._syncList.push(t);
    else {
      const [n, r, i] = t;
      this[n](r, i);
    }
    this.chart._dataChanges.push([
      this.index,
      ...t
    ]);
  }
  _onDataPush() {
    const t = arguments.length;
    this._sync([
      "_insertElements",
      this.getDataset().data.length - t,
      t
    ]);
  }
  _onDataPop() {
    this._sync([
      "_removeElements",
      this._cachedMeta.data.length - 1,
      1
    ]);
  }
  _onDataShift() {
    this._sync([
      "_removeElements",
      0,
      1
    ]);
  }
  _onDataSplice(t, n) {
    n && this._sync([
      "_removeElements",
      t,
      n
    ]);
    const r = arguments.length - 2;
    r && this._sync([
      "_insertElements",
      t,
      r
    ]);
  }
  _onDataUnshift() {
    this._sync([
      "_insertElements",
      0,
      arguments.length
    ]);
  }
}
V(us, "defaults", {}), V(us, "datasetElementType", null), V(us, "dataElementType", null);
function cj(e, t, n) {
  let r = 1, i = 1, s = 0, a = 0;
  if (t < tt) {
    const o = e, l = o + t, c = Math.cos(o), u = Math.sin(o), f = Math.cos(l), d = Math.sin(l), h = (_, y, b) => eo(_, o, l, !0) ? 1 : Math.max(y, y * n, b, b * n), p = (_, y, b) => eo(_, o, l, !0) ? -1 : Math.min(y, y * n, b, b * n), g = h(0, c, f), v = h(vt, u, d), m = p(lt, c, f), x = p(lt + vt, u, d);
    r = (g - m) / 2, i = (v - x) / 2, s = -(g + m) / 2, a = -(v + x) / 2;
  }
  return {
    ratioX: r,
    ratioY: i,
    offsetX: s,
    offsetY: a
  };
}
class ns extends us {
  constructor(t, n) {
    super(t, n), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(t, n) {
    const r = this.getDataset().data, i = this._cachedMeta;
    if (this._parsing === !1)
      i._parsed = r;
    else {
      let s = (l) => +r[l];
      if (Me(r[t])) {
        const { key: l = "value" } = this._parsing;
        s = (c) => +Ja(r[c], l);
      }
      let a, o;
      for (a = t, o = t + n; a < o; ++a)
        i._parsed[a] = s(a);
    }
  }
  _getRotation() {
    return Rn(this.options.rotation - 90);
  }
  _getCircumference() {
    return Rn(this.options.circumference);
  }
  _getRotationExtents() {
    let t = tt, n = -tt;
    for (let r = 0; r < this.chart.data.datasets.length; ++r)
      if (this.chart.isDatasetVisible(r) && this.chart.getDatasetMeta(r).type === this._type) {
        const i = this.chart.getDatasetMeta(r).controller, s = i._getRotation(), a = i._getCircumference();
        t = Math.min(t, s), n = Math.max(n, s + a);
      }
    return {
      rotation: t,
      circumference: n - t
    };
  }
  update(t) {
    const n = this.chart, { chartArea: r } = n, i = this._cachedMeta, s = i.data, a = this.getMaxBorderWidth() + this.getMaxOffset(s) + this.options.spacing, o = Math.max((Math.min(r.width, r.height) - a) / 2, 0), l = Math.min(E9(this.options.cutout, o), 1), c = this._getRingWeight(this.index), { circumference: u, rotation: f } = this._getRotationExtents(), { ratioX: d, ratioY: h, offsetX: p, offsetY: g } = cj(f, u, l), v = (r.width - a) / d, m = (r.height - a) / h, x = Math.max(Math.min(v, m) / 2, 0), _ = Cw(this.options.radius, x), y = Math.max(_ * l, 0), b = (_ - y) / this._getVisibleDatasetWeightTotal();
    this.offsetX = p * _, this.offsetY = g * _, i.total = this.calculateTotal(), this.outerRadius = _ - b * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - b * c, 0), this.updateElements(s, 0, s.length, t);
  }
  _circumference(t, n) {
    const r = this.options, i = this._cachedMeta, s = this._getCircumference();
    return n && r.animation.animateRotate || !this.chart.getDataVisibility(t) || i._parsed[t] === null || i.data[t].hidden ? 0 : this.calculateCircumference(i._parsed[t] * s / tt);
  }
  updateElements(t, n, r, i) {
    const s = i === "reset", a = this.chart, o = a.chartArea, c = a.options.animation, u = (o.left + o.right) / 2, f = (o.top + o.bottom) / 2, d = s && c.animateScale, h = d ? 0 : this.innerRadius, p = d ? 0 : this.outerRadius, { sharedOptions: g, includeOptions: v } = this._getSharedOptions(n, i);
    let m = this._getRotation(), x;
    for (x = 0; x < n; ++x)
      m += this._circumference(x, s);
    for (x = n; x < n + r; ++x) {
      const _ = this._circumference(x, s), y = t[x], b = {
        x: u + this.offsetX,
        y: f + this.offsetY,
        startAngle: m,
        endAngle: m + _,
        circumference: _,
        outerRadius: p,
        innerRadius: h
      };
      v && (b.options = g || this.resolveDataElementOptions(x, y.active ? "active" : i)), m += _, this.updateElement(y, x, b, i);
    }
  }
  calculateTotal() {
    const t = this._cachedMeta, n = t.data;
    let r = 0, i;
    for (i = 0; i < n.length; i++) {
      const s = t._parsed[i];
      s !== null && !isNaN(s) && this.chart.getDataVisibility(i) && !n[i].hidden && (r += Math.abs(s));
    }
    return r;
  }
  calculateCircumference(t) {
    const n = this._cachedMeta.total;
    return n > 0 && !isNaN(t) ? tt * (Math.abs(t) / n) : 0;
  }
  getLabelAndValue(t) {
    const n = this._cachedMeta, r = this.chart, i = r.data.labels || [], s = vu(n._parsed[t], r.options.locale);
    return {
      label: i[t] || "",
      value: s
    };
  }
  getMaxBorderWidth(t) {
    let n = 0;
    const r = this.chart;
    let i, s, a, o, l;
    if (!t) {
      for (i = 0, s = r.data.datasets.length; i < s; ++i)
        if (r.isDatasetVisible(i)) {
          a = r.getDatasetMeta(i), t = a.data, o = a.controller;
          break;
        }
    }
    if (!t)
      return 0;
    for (i = 0, s = t.length; i < s; ++i)
      l = o.resolveDataElementOptions(i), l.borderAlign !== "inner" && (n = Math.max(n, l.borderWidth || 0, l.hoverBorderWidth || 0));
    return n;
  }
  getMaxOffset(t) {
    let n = 0;
    for (let r = 0, i = t.length; r < i; ++r) {
      const s = this.resolveDataElementOptions(r);
      n = Math.max(n, s.offset || 0, s.hoverOffset || 0);
    }
    return n;
  }
  _getRingWeightOffset(t) {
    let n = 0;
    for (let r = 0; r < t; ++r)
      this.chart.isDatasetVisible(r) && (n += this._getRingWeight(r));
    return n;
  }
  _getRingWeight(t) {
    return Math.max(Re(this.chart.data.datasets[t].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
}
V(ns, "id", "doughnut"), V(ns, "defaults", {
  datasetElementType: !1,
  dataElementType: "arc",
  animation: {
    animateRotate: !0,
    animateScale: !1
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "circumference",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "startAngle",
        "x",
        "y",
        "offset",
        "borderWidth",
        "spacing"
      ]
    }
  },
  cutout: "50%",
  rotation: 0,
  circumference: 360,
  radius: "100%",
  spacing: 0,
  indexAxis: "r"
}), V(ns, "descriptors", {
  _scriptable: (t) => t !== "spacing",
  _indexable: (t) => t !== "spacing" && !t.startsWith("borderDash") && !t.startsWith("hoverBorderDash")
}), V(ns, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(t) {
          const n = t.data;
          if (n.labels.length && n.datasets.length) {
            const { labels: { pointStyle: r, color: i } } = t.legend.options;
            return n.labels.map((s, a) => {
              const l = t.getDatasetMeta(0).controller.getStyle(a);
              return {
                text: s,
                fillStyle: l.backgroundColor,
                strokeStyle: l.borderColor,
                fontColor: i,
                lineWidth: l.borderWidth,
                pointStyle: r,
                hidden: !t.getDataVisibility(a),
                index: a
              };
            });
          }
          return [];
        }
      },
      onClick(t, n, r) {
        r.chart.toggleDataVisibility(n.index), r.chart.update();
      }
    }
  }
});
class Ml extends us {
  initialize() {
    this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize();
  }
  update(t) {
    const n = this._cachedMeta, { dataset: r, data: i = [], _dataset: s } = n, a = this.chart._animationsDisabled;
    let { start: o, count: l } = V9(n, i, a);
    this._drawStart = o, this._drawCount = l, H9(n) && (o = 0, l = i.length), r._chart = this.chart, r._datasetIndex = this.index, r._decimated = !!s._decimated, r.points = i;
    const c = this.resolveDatasetElementOptions(t);
    this.options.showLine || (c.borderWidth = 0), c.segment = this.options.segment, this.updateElement(r, void 0, {
      animated: !a,
      options: c
    }, t), this.updateElements(i, o, l, t);
  }
  updateElements(t, n, r, i) {
    const s = i === "reset", { iScale: a, vScale: o, _stacked: l, _dataset: c } = this._cachedMeta, { sharedOptions: u, includeOptions: f } = this._getSharedOptions(n, i), d = a.axis, h = o.axis, { spanGaps: p, segment: g } = this.options, v = Qa(p) ? p : Number.POSITIVE_INFINITY, m = this.chart._animationsDisabled || s || i === "none", x = n + r, _ = t.length;
    let y = n > 0 && this.getParsed(n - 1);
    for (let b = 0; b < _; ++b) {
      const w = t[b], E = m ? w : {};
      if (b < n || b >= x) {
        E.skip = !0;
        continue;
      }
      const $ = this.getParsed(b), C = Qe($[h]), A = E[d] = a.getPixelForValue($[d], b), k = E[h] = s || C ? o.getBasePixel() : o.getPixelForValue(l ? this.applyStack(o, $, l) : $[h], b);
      E.skip = isNaN(A) || isNaN(k) || C, E.stop = b > 0 && Math.abs($[d] - y[d]) > v, g && (E.parsed = $, E.raw = c.data[b]), f && (E.options = u || this.resolveDataElementOptions(b, w.active ? "active" : i)), m || this.updateElement(w, b, E, i), y = $;
    }
  }
  getMaxOverflow() {
    const t = this._cachedMeta, n = t.dataset, r = n.options && n.options.borderWidth || 0, i = t.data || [];
    if (!i.length)
      return r;
    const s = i[0].size(this.resolveDataElementOptions(0)), a = i[i.length - 1].size(this.resolveDataElementOptions(i.length - 1));
    return Math.max(r, s, a) / 2;
  }
  draw() {
    const t = this._cachedMeta;
    t.dataset.updateControlPoints(this.chart.chartArea, t.iScale.axis), super.draw();
  }
}
V(Ml, "id", "line"), V(Ml, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  showLine: !0,
  spanGaps: !1
}), V(Ml, "overrides", {
  scales: {
    _index_: {
      type: "category"
    },
    _value_: {
      type: "linear"
    }
  }
});
class Vd extends ns {
}
V(Vd, "id", "pie"), V(Vd, "defaults", {
  cutout: 0,
  rotation: 0,
  circumference: 360,
  radius: "100%"
});
function Kr() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
class Bh {
  constructor(t) {
    V(this, "options");
    this.options = t || {};
  }
  /**
  * Override default date adapter methods.
  * Accepts type parameter to define options type.
  * @example
  * Chart._adapters._date.override<{myAdapterOption: string}>({
  *   init() {
  *     console.log(this.options.myAdapterOption);
  *   }
  * })
  */
  static override(t) {
    Object.assign(Bh.prototype, t);
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  init() {
  }
  formats() {
    return Kr();
  }
  parse() {
    return Kr();
  }
  format() {
    return Kr();
  }
  add() {
    return Kr();
  }
  diff() {
    return Kr();
  }
  startOf() {
    return Kr();
  }
  endOf() {
    return Kr();
  }
}
var uj = {
  _date: Bh
};
function fj(e, t, n, r) {
  const { controller: i, data: s, _sorted: a } = e, o = i._cachedMeta.iScale;
  if (o && t === o.axis && t !== "r" && a && s.length) {
    const l = o._reversePixels ? R9 : oi;
    if (r) {
      if (i._sharedOptions) {
        const c = s[0], u = typeof c.getRange == "function" && c.getRange(t);
        if (u) {
          const f = l(s, t, n - u), d = l(s, t, n + u);
          return {
            lo: f.lo,
            hi: d.hi
          };
        }
      }
    } else
      return l(s, t, n);
  }
  return {
    lo: 0,
    hi: s.length - 1
  };
}
function Eo(e, t, n, r, i) {
  const s = e.getSortedVisibleDatasetMetas(), a = n[t];
  for (let o = 0, l = s.length; o < l; ++o) {
    const { index: c, data: u } = s[o], { lo: f, hi: d } = fj(s[o], t, a, i);
    for (let h = f; h <= d; ++h) {
      const p = u[h];
      p.skip || r(p, c, h);
    }
  }
}
function dj(e) {
  const t = e.indexOf("x") !== -1, n = e.indexOf("y") !== -1;
  return function(r, i) {
    const s = t ? Math.abs(r.x - i.x) : 0, a = n ? Math.abs(r.y - i.y) : 0;
    return Math.sqrt(Math.pow(s, 2) + Math.pow(a, 2));
  };
}
function rf(e, t, n, r, i) {
  const s = [];
  return !i && !e.isPointInArea(t) || Eo(e, n, t, function(o, l, c) {
    !i && !nr(o, e.chartArea, 0) || o.inRange(t.x, t.y, r) && s.push({
      element: o,
      datasetIndex: l,
      index: c
    });
  }, !0), s;
}
function hj(e, t, n, r) {
  let i = [];
  function s(a, o, l) {
    const { startAngle: c, endAngle: u } = a.getProps([
      "startAngle",
      "endAngle"
    ], r), { angle: f } = Tw(a, {
      x: t.x,
      y: t.y
    });
    eo(f, c, u) && i.push({
      element: a,
      datasetIndex: o,
      index: l
    });
  }
  return Eo(e, n, t, s), i;
}
function pj(e, t, n, r, i, s) {
  let a = [];
  const o = dj(n);
  let l = Number.POSITIVE_INFINITY;
  function c(u, f, d) {
    const h = u.inRange(t.x, t.y, i);
    if (r && !h)
      return;
    const p = u.getCenterPoint(i);
    if (!(!!s || e.isPointInArea(p)) && !h)
      return;
    const v = o(t, p);
    v < l ? (a = [
      {
        element: u,
        datasetIndex: f,
        index: d
      }
    ], l = v) : v === l && a.push({
      element: u,
      datasetIndex: f,
      index: d
    });
  }
  return Eo(e, n, t, c), a;
}
function sf(e, t, n, r, i, s) {
  return !s && !e.isPointInArea(t) ? [] : n === "r" && !r ? hj(e, t, n, i) : pj(e, t, n, r, i, s);
}
function rm(e, t, n, r, i) {
  const s = [], a = n === "x" ? "inXRange" : "inYRange";
  let o = !1;
  return Eo(e, n, t, (l, c, u) => {
    l[a](t[n], i) && (s.push({
      element: l,
      datasetIndex: c,
      index: u
    }), o = o || l.inRange(t.x, t.y, i));
  }), r && !o ? [] : s;
}
var gj = {
  evaluateInteractionItems: Eo,
  modes: {
    index(e, t, n, r) {
      const i = ei(t, e), s = n.axis || "x", a = n.includeInvisible || !1, o = n.intersect ? rf(e, i, s, r, a) : sf(e, i, s, !1, r, a), l = [];
      return o.length ? (e.getSortedVisibleDatasetMetas().forEach((c) => {
        const u = o[0].index, f = c.data[u];
        f && !f.skip && l.push({
          element: f,
          datasetIndex: c.index,
          index: u
        });
      }), l) : [];
    },
    dataset(e, t, n, r) {
      const i = ei(t, e), s = n.axis || "xy", a = n.includeInvisible || !1;
      let o = n.intersect ? rf(e, i, s, r, a) : sf(e, i, s, !1, r, a);
      if (o.length > 0) {
        const l = o[0].datasetIndex, c = e.getDatasetMeta(l).data;
        o = [];
        for (let u = 0; u < c.length; ++u)
          o.push({
            element: c[u],
            datasetIndex: l,
            index: u
          });
      }
      return o;
    },
    point(e, t, n, r) {
      const i = ei(t, e), s = n.axis || "xy", a = n.includeInvisible || !1;
      return rf(e, i, s, r, a);
    },
    nearest(e, t, n, r) {
      const i = ei(t, e), s = n.axis || "xy", a = n.includeInvisible || !1;
      return sf(e, i, s, n.intersect, r, a);
    },
    x(e, t, n, r) {
      const i = ei(t, e);
      return rm(e, i, "x", n.intersect, r);
    },
    y(e, t, n, r) {
      const i = ei(t, e);
      return rm(e, i, "y", n.intersect, r);
    }
  }
};
const Uw = [
  "left",
  "top",
  "right",
  "bottom"
];
function ia(e, t) {
  return e.filter((n) => n.pos === t);
}
function im(e, t) {
  return e.filter((n) => Uw.indexOf(n.pos) === -1 && n.box.axis === t);
}
function sa(e, t) {
  return e.sort((n, r) => {
    const i = t ? r : n, s = t ? n : r;
    return i.weight === s.weight ? i.index - s.index : i.weight - s.weight;
  });
}
function vj(e) {
  const t = [];
  let n, r, i, s, a, o;
  for (n = 0, r = (e || []).length; n < r; ++n)
    i = e[n], { position: s, options: { stack: a, stackWeight: o = 1 } } = i, t.push({
      index: n,
      box: i,
      pos: s,
      horizontal: i.isHorizontal(),
      weight: i.weight,
      stack: a && s + a,
      stackWeight: o
    });
  return t;
}
function mj(e) {
  const t = {};
  for (const n of e) {
    const { stack: r, pos: i, stackWeight: s } = n;
    if (!r || !Uw.includes(i))
      continue;
    const a = t[r] || (t[r] = {
      count: 0,
      placed: 0,
      weight: 0,
      size: 0
    });
    a.count++, a.weight += s;
  }
  return t;
}
function yj(e, t) {
  const n = mj(e), { vBoxMaxWidth: r, hBoxMaxHeight: i } = t;
  let s, a, o;
  for (s = 0, a = e.length; s < a; ++s) {
    o = e[s];
    const { fullSize: l } = o.box, c = n[o.stack], u = c && o.stackWeight / c.weight;
    o.horizontal ? (o.width = u ? u * r : l && t.availableWidth, o.height = i) : (o.width = r, o.height = u ? u * i : l && t.availableHeight);
  }
  return n;
}
function xj(e) {
  const t = vj(e), n = sa(t.filter((c) => c.box.fullSize), !0), r = sa(ia(t, "left"), !0), i = sa(ia(t, "right")), s = sa(ia(t, "top"), !0), a = sa(ia(t, "bottom")), o = im(t, "x"), l = im(t, "y");
  return {
    fullSize: n,
    leftAndTop: r.concat(s),
    rightAndBottom: i.concat(l).concat(a).concat(o),
    chartArea: ia(t, "chartArea"),
    vertical: r.concat(i).concat(l),
    horizontal: s.concat(a).concat(o)
  };
}
function sm(e, t, n, r) {
  return Math.max(e[n], t[n]) + Math.max(e[r], t[r]);
}
function Yw(e, t) {
  e.top = Math.max(e.top, t.top), e.left = Math.max(e.left, t.left), e.bottom = Math.max(e.bottom, t.bottom), e.right = Math.max(e.right, t.right);
}
function bj(e, t, n, r) {
  const { pos: i, box: s } = n, a = e.maxPadding;
  if (!Me(i)) {
    n.size && (e[i] -= n.size);
    const f = r[n.stack] || {
      size: 0,
      count: 1
    };
    f.size = Math.max(f.size, n.horizontal ? s.height : s.width), n.size = f.size / f.count, e[i] += n.size;
  }
  s.getPadding && Yw(a, s.getPadding());
  const o = Math.max(0, t.outerWidth - sm(a, e, "left", "right")), l = Math.max(0, t.outerHeight - sm(a, e, "top", "bottom")), c = o !== e.w, u = l !== e.h;
  return e.w = o, e.h = l, n.horizontal ? {
    same: c,
    other: u
  } : {
    same: u,
    other: c
  };
}
function _j(e) {
  const t = e.maxPadding;
  function n(r) {
    const i = Math.max(t[r] - e[r], 0);
    return e[r] += i, i;
  }
  e.y += n("top"), e.x += n("left"), n("right"), n("bottom");
}
function wj(e, t) {
  const n = t.maxPadding;
  function r(i) {
    const s = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    return i.forEach((a) => {
      s[a] = Math.max(t[a], n[a]);
    }), s;
  }
  return r(e ? [
    "left",
    "right"
  ] : [
    "top",
    "bottom"
  ]);
}
function ba(e, t, n, r) {
  const i = [];
  let s, a, o, l, c, u;
  for (s = 0, a = e.length, c = 0; s < a; ++s) {
    o = e[s], l = o.box, l.update(o.width || t.w, o.height || t.h, wj(o.horizontal, t));
    const { same: f, other: d } = bj(t, n, o, r);
    c |= f && i.length, u = u || d, l.fullSize || i.push(o);
  }
  return c && ba(i, t, n, r) || u;
}
function el(e, t, n, r, i) {
  e.top = n, e.left = t, e.right = t + r, e.bottom = n + i, e.width = r, e.height = i;
}
function am(e, t, n, r) {
  const i = n.padding;
  let { x: s, y: a } = t;
  for (const o of e) {
    const l = o.box, c = r[o.stack] || {
      count: 1,
      placed: 0,
      weight: 1
    }, u = o.stackWeight / c.weight || 1;
    if (o.horizontal) {
      const f = t.w * u, d = c.size || l.height;
      mc(c.start) && (a = c.start), l.fullSize ? el(l, i.left, a, n.outerWidth - i.right - i.left, d) : el(l, t.left + c.placed, a, f, d), c.start = a, c.placed += f, a = l.bottom;
    } else {
      const f = t.h * u, d = c.size || l.width;
      mc(c.start) && (s = c.start), l.fullSize ? el(l, s, i.top, d, n.outerHeight - i.bottom - i.top) : el(l, s, t.top + c.placed, d, f), c.start = s, c.placed += f, s = l.right;
    }
  }
  t.x = s, t.y = a;
}
var tl = {
  addBox(e, t) {
    e.boxes || (e.boxes = []), t.fullSize = t.fullSize || !1, t.position = t.position || "top", t.weight = t.weight || 0, t._layers = t._layers || function() {
      return [
        {
          z: 0,
          draw(n) {
            t.draw(n);
          }
        }
      ];
    }, e.boxes.push(t);
  },
  removeBox(e, t) {
    const n = e.boxes ? e.boxes.indexOf(t) : -1;
    n !== -1 && e.boxes.splice(n, 1);
  },
  configure(e, t, n) {
    t.fullSize = n.fullSize, t.position = n.position, t.weight = n.weight;
  },
  update(e, t, n, r) {
    if (!e)
      return;
    const i = cr(e.options.layout.padding), s = Math.max(t - i.width, 0), a = Math.max(n - i.height, 0), o = xj(e.boxes), l = o.vertical, c = o.horizontal;
    Bt(e.boxes, (g) => {
      typeof g.beforeLayout == "function" && g.beforeLayout();
    });
    const u = l.reduce((g, v) => v.box.options && v.box.options.display === !1 ? g : g + 1, 0) || 1, f = Object.freeze({
      outerWidth: t,
      outerHeight: n,
      padding: i,
      availableWidth: s,
      availableHeight: a,
      vBoxMaxWidth: s / 2 / u,
      hBoxMaxHeight: a / 2
    }), d = Object.assign({}, i);
    Yw(d, cr(r));
    const h = Object.assign({
      maxPadding: d,
      w: s,
      h: a,
      x: i.left,
      y: i.top
    }, i), p = yj(l.concat(c), f);
    ba(o.fullSize, h, f, p), ba(l, h, f, p), ba(c, h, f, p) && ba(l, h, f, p), _j(h), am(o.leftAndTop, h, f, p), h.x += h.w, h.y += h.h, am(o.rightAndBottom, h, f, p), e.chartArea = {
      left: h.left,
      top: h.top,
      right: h.left + h.w,
      bottom: h.top + h.h,
      height: h.h,
      width: h.w
    }, Bt(o.chartArea, (g) => {
      const v = g.box;
      Object.assign(v, e.chartArea), v.update(h.w, h.h, {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      });
    });
  }
};
class qw {
  acquireContext(t, n) {
  }
  releaseContext(t) {
    return !1;
  }
  addEventListener(t, n, r) {
  }
  removeEventListener(t, n, r) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(t, n, r, i) {
    return n = Math.max(0, n || t.width), r = r || t.height, {
      width: n,
      height: Math.max(0, i ? Math.floor(n / i) : r)
    };
  }
  isAttached(t) {
    return !0;
  }
  updateConfig(t) {
  }
}
class $j extends qw {
  acquireContext(t) {
    return t && t.getContext && t.getContext("2d") || null;
  }
  updateConfig(t) {
    t.options.animation = !1;
  }
}
const Fl = "$chartjs", Ej = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
}, om = (e) => e === null || e === "";
function Aj(e, t) {
  const n = e.style, r = e.getAttribute("height"), i = e.getAttribute("width");
  if (e[Fl] = {
    initial: {
      height: r,
      width: i,
      style: {
        display: n.display,
        height: n.height,
        width: n.width
      }
    }
  }, n.display = n.display || "block", n.boxSizing = n.boxSizing || "border-box", om(i)) {
    const s = Yv(e, "width");
    s !== void 0 && (e.width = s);
  }
  if (om(r))
    if (e.style.height === "")
      e.height = e.width / (t || 2);
    else {
      const s = Yv(e, "height");
      s !== void 0 && (e.height = s);
    }
  return e;
}
const Gw = B7 ? {
  passive: !0
} : !1;
function kj(e, t, n) {
  e.addEventListener(t, n, Gw);
}
function Cj(e, t, n) {
  e.canvas.removeEventListener(t, n, Gw);
}
function Dj(e, t) {
  const n = Ej[e.type] || e.type, { x: r, y: i } = ei(e, t);
  return {
    type: n,
    chart: t,
    native: e,
    x: r !== void 0 ? r : null,
    y: i !== void 0 ? i : null
  };
}
function wc(e, t) {
  for (const n of e)
    if (n === t || n.contains(t))
      return !0;
}
function Sj(e, t, n) {
  const r = e.canvas, i = new MutationObserver((s) => {
    let a = !1;
    for (const o of s)
      a = a || wc(o.addedNodes, r), a = a && !wc(o.removedNodes, r);
    a && n();
  });
  return i.observe(document, {
    childList: !0,
    subtree: !0
  }), i;
}
function Tj(e, t, n) {
  const r = e.canvas, i = new MutationObserver((s) => {
    let a = !1;
    for (const o of s)
      a = a || wc(o.removedNodes, r), a = a && !wc(o.addedNodes, r);
    a && n();
  });
  return i.observe(document, {
    childList: !0,
    subtree: !0
  }), i;
}
const to = /* @__PURE__ */ new Map();
let lm = 0;
function Xw() {
  const e = window.devicePixelRatio;
  e !== lm && (lm = e, to.forEach((t, n) => {
    n.currentDevicePixelRatio !== e && t();
  }));
}
function Oj(e, t) {
  to.size || window.addEventListener("resize", Xw), to.set(e, t);
}
function Mj(e) {
  to.delete(e), to.size || window.removeEventListener("resize", Xw);
}
function Fj(e, t, n) {
  const r = e.canvas, i = r && Rh(r);
  if (!i)
    return;
  const s = Pw((o, l) => {
    const c = i.clientWidth;
    n(o, l), c < i.clientWidth && n();
  }, window), a = new ResizeObserver((o) => {
    const l = o[0], c = l.contentRect.width, u = l.contentRect.height;
    c === 0 && u === 0 || s(c, u);
  });
  return a.observe(i), Oj(e, s), a;
}
function af(e, t, n) {
  n && n.disconnect(), t === "resize" && Mj(e);
}
function Pj(e, t, n) {
  const r = e.canvas, i = Pw((s) => {
    e.ctx !== null && n(Dj(s, e));
  }, e);
  return kj(r, t, i), i;
}
class Ij extends qw {
  acquireContext(t, n) {
    const r = t && t.getContext && t.getContext("2d");
    return r && r.canvas === t ? (Aj(t, n), r) : null;
  }
  releaseContext(t) {
    const n = t.canvas;
    if (!n[Fl])
      return !1;
    const r = n[Fl].initial;
    [
      "height",
      "width"
    ].forEach((s) => {
      const a = r[s];
      Qe(a) ? n.removeAttribute(s) : n.setAttribute(s, a);
    });
    const i = r.style || {};
    return Object.keys(i).forEach((s) => {
      n.style[s] = i[s];
    }), n.width = n.width, delete n[Fl], !0;
  }
  addEventListener(t, n, r) {
    this.removeEventListener(t, n);
    const i = t.$proxies || (t.$proxies = {}), a = {
      attach: Sj,
      detach: Tj,
      resize: Fj
    }[n] || Pj;
    i[n] = a(t, n, r);
  }
  removeEventListener(t, n) {
    const r = t.$proxies || (t.$proxies = {}), i = r[n];
    if (!i)
      return;
    ({
      attach: af,
      detach: af,
      resize: af
    }[n] || Cj)(t, n, i), r[n] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(t, n, r, i) {
    return R7(t, n, r, i);
  }
  isAttached(t) {
    const n = Rh(t);
    return !!(n && n.isConnected);
  }
}
function Rj(e) {
  return !Ih() || typeof OffscreenCanvas < "u" && e instanceof OffscreenCanvas ? $j : Ij;
}
var $l;
let Ao = ($l = class {
  constructor() {
    V(this, "x");
    V(this, "y");
    V(this, "active", !1);
    V(this, "options");
    V(this, "$animations");
  }
  tooltipPosition(t) {
    const { x: n, y: r } = this.getProps([
      "x",
      "y"
    ], t);
    return {
      x: n,
      y: r
    };
  }
  hasValue() {
    return Qa(this.x) && Qa(this.y);
  }
  getProps(t, n) {
    const r = this.$animations;
    if (!n || !r)
      return this;
    const i = {};
    return t.forEach((s) => {
      i[s] = r[s] && r[s].active() ? r[s]._to : this[s];
    }), i;
  }
}, V($l, "defaults", {}), V($l, "defaultRoutes"), $l);
function Bj(e, t) {
  const n = e.options.ticks, r = Nj(e), i = Math.min(n.maxTicksLimit || r, r), s = n.major.enabled ? jj(t) : [], a = s.length, o = s[0], l = s[a - 1], c = [];
  if (a > i)
    return zj(t, c, s, a / i), c;
  const u = Lj(s, t, i);
  if (a > 0) {
    let f, d;
    const h = a > 1 ? Math.round((l - o) / (a - 1)) : null;
    for (nl(t, c, u, Qe(h) ? 0 : o - h, o), f = 0, d = a - 1; f < d; f++)
      nl(t, c, u, s[f], s[f + 1]);
    return nl(t, c, u, l, Qe(h) ? t.length : l + h), c;
  }
  return nl(t, c, u), c;
}
function Nj(e) {
  const t = e.options.offset, n = e._tickSize(), r = e._length / n + (t ? 0 : 1), i = e._maxLength / n;
  return Math.floor(Math.min(r, i));
}
function Lj(e, t, n) {
  const r = Vj(e), i = t.length / n;
  if (!r)
    return Math.max(i, 1);
  const s = M9(r);
  for (let a = 0, o = s.length - 1; a < o; a++) {
    const l = s[a];
    if (l > i)
      return l;
  }
  return Math.max(i, 1);
}
function jj(e) {
  const t = [];
  let n, r;
  for (n = 0, r = e.length; n < r; n++)
    e[n].major && t.push(n);
  return t;
}
function zj(e, t, n, r) {
  let i = 0, s = n[0], a;
  for (r = Math.ceil(r), a = 0; a < e.length; a++)
    a === s && (t.push(e[a]), i++, s = n[i * r]);
}
function nl(e, t, n, r, i) {
  const s = Re(r, 0), a = Math.min(Re(i, e.length), e.length);
  let o = 0, l, c, u;
  for (n = Math.ceil(n), i && (l = i - r, n = l / Math.floor(l / n)), u = s; u < 0; )
    o++, u = Math.round(s + o * n);
  for (c = Math.max(s, 0); c < a; c++)
    c === u && (t.push(e[c]), o++, u = Math.round(s + o * n));
}
function Vj(e) {
  const t = e.length;
  let n, r;
  if (t < 2)
    return !1;
  for (r = e[0], n = 1; n < t; ++n)
    if (e[n] - e[n - 1] !== r)
      return !1;
  return r;
}
const Hj = (e) => e === "left" ? "right" : e === "right" ? "left" : e, cm = (e, t, n) => t === "top" || t === "left" ? e[t] + n : e[t] - n, um = (e, t) => Math.min(t || e, e);
function fm(e, t) {
  const n = [], r = e.length / t, i = e.length;
  let s = 0;
  for (; s < i; s += r)
    n.push(e[Math.floor(s)]);
  return n;
}
function Wj(e, t, n) {
  const r = e.ticks.length, i = Math.min(t, r - 1), s = e._startPixel, a = e._endPixel, o = 1e-6;
  let l = e.getPixelForTick(i), c;
  if (!(n && (r === 1 ? c = Math.max(l - s, a - l) : t === 0 ? c = (e.getPixelForTick(1) - l) / 2 : c = (l - e.getPixelForTick(i - 1)) / 2, l += i < t ? c : -c, l < s - o || l > a + o)))
    return l;
}
function Uj(e, t) {
  Bt(e, (n) => {
    const r = n.gc, i = r.length / 2;
    let s;
    if (i > t) {
      for (s = 0; s < i; ++s)
        delete n.data[r[s]];
      r.splice(0, i);
    }
  });
}
function aa(e) {
  return e.drawTicks ? e.tickLength : 0;
}
function dm(e, t) {
  if (!e.display)
    return 0;
  const n = _s(e.font, t), r = cr(e.padding);
  return (gt(e.text) ? e.text.length : 1) * n.lineHeight + r.height;
}
function Yj(e, t) {
  return Di(e, {
    scale: t,
    type: "scale"
  });
}
function qj(e, t, n) {
  return Di(e, {
    tick: n,
    index: t,
    type: "tick"
  });
}
function Gj(e, t, n) {
  let r = z9(e);
  return (n && t !== "right" || !n && t === "right") && (r = Hj(r)), r;
}
function Xj(e, t, n, r) {
  const { top: i, left: s, bottom: a, right: o, chart: l } = e, { chartArea: c, scales: u } = l;
  let f = 0, d, h, p;
  const g = a - i, v = o - s;
  if (e.isHorizontal()) {
    if (h = Bv(r, s, o), Me(n)) {
      const m = Object.keys(n)[0], x = n[m];
      p = u[m].getPixelForValue(x) + g - t;
    } else
      n === "center" ? p = (c.bottom + c.top) / 2 + g - t : p = cm(e, n, t);
    d = o - s;
  } else {
    if (Me(n)) {
      const m = Object.keys(n)[0], x = n[m];
      h = u[m].getPixelForValue(x) - v + t;
    } else
      n === "center" ? h = (c.left + c.right) / 2 - v + t : h = cm(e, n, t);
    p = Bv(r, a, i), f = n === "left" ? -vt : vt;
  }
  return {
    titleX: h,
    titleY: p,
    maxWidth: d,
    rotation: f
  };
}
class Si extends Ao {
  constructor(t) {
    super(), this.id = t.id, this.type = t.type, this.options = void 0, this.ctx = t.ctx, this.chart = t.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0;
  }
  init(t) {
    this.options = t.setContext(this.getContext()), this.axis = t.axis, this._userMin = this.parse(t.min), this._userMax = this.parse(t.max), this._suggestedMin = this.parse(t.suggestedMin), this._suggestedMax = this.parse(t.suggestedMax);
  }
  parse(t, n) {
    return t;
  }
  getUserBounds() {
    let { _userMin: t, _userMax: n, _suggestedMin: r, _suggestedMax: i } = this;
    return t = en(t, Number.POSITIVE_INFINITY), n = en(n, Number.NEGATIVE_INFINITY), r = en(r, Number.POSITIVE_INFINITY), i = en(i, Number.NEGATIVE_INFINITY), {
      min: en(t, r),
      max: en(n, i),
      minDefined: kt(t),
      maxDefined: kt(n)
    };
  }
  getMinMax(t) {
    let { min: n, max: r, minDefined: i, maxDefined: s } = this.getUserBounds(), a;
    if (i && s)
      return {
        min: n,
        max: r
      };
    const o = this.getMatchingVisibleMetas();
    for (let l = 0, c = o.length; l < c; ++l)
      a = o[l].controller.getMinMax(this, t), i || (n = Math.min(n, a.min)), s || (r = Math.max(r, a.max));
    return n = s && n > r ? r : n, r = i && n > r ? n : r, {
      min: en(n, en(r, n)),
      max: en(r, en(n, r))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const t = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || [];
  }
  getLabelItems(t = this.chart.chartArea) {
    return this._labelItems || (this._labelItems = this._computeLabelItems(t));
  }
  beforeLayout() {
    this._cache = {}, this._dataLimitsCached = !1;
  }
  beforeUpdate() {
    ot(this.options.beforeUpdate, [
      this
    ]);
  }
  update(t, n, r) {
    const { beginAtZero: i, grace: s, ticks: a } = this.options, o = a.sampleSize;
    this.beforeUpdate(), this.maxWidth = t, this.maxHeight = n, this._margins = r = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, r), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + r.left + r.right : this.height + r.top + r.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = p7(this, s, i), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();
    const l = o < this.ticks.length;
    this._convertTicksToLabels(l ? fm(this.ticks, o) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), a.display && (a.autoSkip || a.source === "auto") && (this.ticks = Bj(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), l && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate();
  }
  configure() {
    let t = this.options.reverse, n, r;
    this.isHorizontal() ? (n = this.left, r = this.right) : (n = this.top, r = this.bottom, t = !t), this._startPixel = n, this._endPixel = r, this._reversePixels = t, this._length = r - n, this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    ot(this.options.afterUpdate, [
      this
    ]);
  }
  beforeSetDimensions() {
    ot(this.options.beforeSetDimensions, [
      this
    ]);
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0;
  }
  afterSetDimensions() {
    ot(this.options.afterSetDimensions, [
      this
    ]);
  }
  _callHooks(t) {
    this.chart.notifyPlugins(t, this.getContext()), ot(this.options[t], [
      this
    ]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    ot(this.options.beforeTickToLabelConversion, [
      this
    ]);
  }
  generateTickLabels(t) {
    const n = this.options.ticks;
    let r, i, s;
    for (r = 0, i = t.length; r < i; r++)
      s = t[r], s.label = ot(n.callback, [
        s.value,
        r,
        t
      ], this);
  }
  afterTickToLabelConversion() {
    ot(this.options.afterTickToLabelConversion, [
      this
    ]);
  }
  beforeCalculateLabelRotation() {
    ot(this.options.beforeCalculateLabelRotation, [
      this
    ]);
  }
  calculateLabelRotation() {
    const t = this.options, n = t.ticks, r = um(this.ticks.length, t.ticks.maxTicksLimit), i = n.minRotation || 0, s = n.maxRotation;
    let a = i, o, l, c;
    if (!this._isVisible() || !n.display || i >= s || r <= 1 || !this.isHorizontal()) {
      this.labelRotation = i;
      return;
    }
    const u = this._getLabelSizes(), f = u.widest.width, d = u.highest.height, h = nn(this.chart.width - f, 0, this.maxWidth);
    o = t.offset ? this.maxWidth / r : h / (r - 1), f + 6 > o && (o = h / (r - (t.offset ? 0.5 : 1)), l = this.maxHeight - aa(t.grid) - n.padding - dm(t.title, this.chart.options.font), c = Math.sqrt(f * f + d * d), a = Dh(Math.min(Math.asin(nn((u.highest.height + 6) / o, -1, 1)), Math.asin(nn(l / c, -1, 1)) - Math.asin(nn(d / c, -1, 1)))), a = Math.max(i, Math.min(s, a))), this.labelRotation = a;
  }
  afterCalculateLabelRotation() {
    ot(this.options.afterCalculateLabelRotation, [
      this
    ]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    ot(this.options.beforeFit, [
      this
    ]);
  }
  fit() {
    const t = {
      width: 0,
      height: 0
    }, { chart: n, options: { ticks: r, title: i, grid: s } } = this, a = this._isVisible(), o = this.isHorizontal();
    if (a) {
      const l = dm(i, n.options.font);
      if (o ? (t.width = this.maxWidth, t.height = aa(s) + l) : (t.height = this.maxHeight, t.width = aa(s) + l), r.display && this.ticks.length) {
        const { first: c, last: u, widest: f, highest: d } = this._getLabelSizes(), h = r.padding * 2, p = Rn(this.labelRotation), g = Math.cos(p), v = Math.sin(p);
        if (o) {
          const m = r.mirror ? 0 : v * f.width + g * d.height;
          t.height = Math.min(this.maxHeight, t.height + m + h);
        } else {
          const m = r.mirror ? 0 : g * f.width + v * d.height;
          t.width = Math.min(this.maxWidth, t.width + m + h);
        }
        this._calculatePadding(c, u, v, g);
      }
    }
    this._handleMargins(), o ? (this.width = this._length = n.width - this._margins.left - this._margins.right, this.height = t.height) : (this.width = t.width, this.height = this._length = n.height - this._margins.top - this._margins.bottom);
  }
  _calculatePadding(t, n, r, i) {
    const { ticks: { align: s, padding: a }, position: o } = this.options, l = this.labelRotation !== 0, c = o !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const u = this.getPixelForTick(0) - this.left, f = this.right - this.getPixelForTick(this.ticks.length - 1);
      let d = 0, h = 0;
      l ? c ? (d = i * t.width, h = r * n.height) : (d = r * t.height, h = i * n.width) : s === "start" ? h = n.width : s === "end" ? d = t.width : s !== "inner" && (d = t.width / 2, h = n.width / 2), this.paddingLeft = Math.max((d - u + a) * this.width / (this.width - u), 0), this.paddingRight = Math.max((h - f + a) * this.width / (this.width - f), 0);
    } else {
      let u = n.height / 2, f = t.height / 2;
      s === "start" ? (u = 0, f = t.height) : s === "end" && (u = n.height, f = 0), this.paddingTop = u + a, this.paddingBottom = f + a;
    }
  }
  _handleMargins() {
    this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom));
  }
  afterFit() {
    ot(this.options.afterFit, [
      this
    ]);
  }
  isHorizontal() {
    const { axis: t, position: n } = this.options;
    return n === "top" || n === "bottom" || t === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(t) {
    this.beforeTickToLabelConversion(), this.generateTickLabels(t);
    let n, r;
    for (n = 0, r = t.length; n < r; n++)
      Qe(t[n].label) && (t.splice(n, 1), r--, n--);
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let t = this._labelSizes;
    if (!t) {
      const n = this.options.ticks.sampleSize;
      let r = this.ticks;
      n < r.length && (r = fm(r, n)), this._labelSizes = t = this._computeLabelSizes(r, r.length, this.options.ticks.maxTicksLimit);
    }
    return t;
  }
  _computeLabelSizes(t, n, r) {
    const { ctx: i, _longestTextCache: s } = this, a = [], o = [], l = Math.floor(n / um(n, r));
    let c = 0, u = 0, f, d, h, p, g, v, m, x, _, y, b;
    for (f = 0; f < n; f += l) {
      if (p = t[f].label, g = this._resolveTickFontOptions(f), i.font = v = g.string, m = s[v] = s[v] || {
        data: {},
        gc: []
      }, x = g.lineHeight, _ = y = 0, !Qe(p) && !gt(p))
        _ = xc(i, m.data, m.gc, _, p), y = x;
      else if (gt(p))
        for (d = 0, h = p.length; d < h; ++d)
          b = p[d], !Qe(b) && !gt(b) && (_ = xc(i, m.data, m.gc, _, b), y += x);
      a.push(_), o.push(y), c = Math.max(_, c), u = Math.max(y, u);
    }
    Uj(s, n);
    const w = a.indexOf(c), E = o.indexOf(u), $ = (C) => ({
      width: a[C] || 0,
      height: o[C] || 0
    });
    return {
      first: $(0),
      last: $(n - 1),
      widest: $(w),
      highest: $(E),
      widths: a,
      heights: o
    };
  }
  getLabelForValue(t) {
    return t;
  }
  getPixelForValue(t, n) {
    return NaN;
  }
  getValueForPixel(t) {
  }
  getPixelForTick(t) {
    const n = this.ticks;
    return t < 0 || t > n.length - 1 ? null : this.getPixelForValue(n[t].value);
  }
  getPixelForDecimal(t) {
    this._reversePixels && (t = 1 - t);
    const n = this._startPixel + t * this._length;
    return I9(this._alignToPixels ? Zr(this.chart, n, 0) : n);
  }
  getDecimalForPixel(t) {
    const n = (t - this._startPixel) / this._length;
    return this._reversePixels ? 1 - n : n;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min: t, max: n } = this;
    return t < 0 && n < 0 ? n : t > 0 && n > 0 ? t : 0;
  }
  getContext(t) {
    const n = this.ticks || [];
    if (t >= 0 && t < n.length) {
      const r = n[t];
      return r.$context || (r.$context = qj(this.getContext(), t, r));
    }
    return this.$context || (this.$context = Yj(this.chart.getContext(), this));
  }
  _tickSize() {
    const t = this.options.ticks, n = Rn(this.labelRotation), r = Math.abs(Math.cos(n)), i = Math.abs(Math.sin(n)), s = this._getLabelSizes(), a = t.autoSkipPadding || 0, o = s ? s.widest.width + a : 0, l = s ? s.highest.height + a : 0;
    return this.isHorizontal() ? l * r > o * i ? o / r : l / i : l * i < o * r ? l / r : o / i;
  }
  _isVisible() {
    const t = this.options.display;
    return t !== "auto" ? !!t : this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(t) {
    const n = this.axis, r = this.chart, i = this.options, { grid: s, position: a, border: o } = i, l = s.offset, c = this.isHorizontal(), f = this.ticks.length + (l ? 1 : 0), d = aa(s), h = [], p = o.setContext(this.getContext()), g = p.display ? p.width : 0, v = g / 2, m = function(H) {
      return Zr(r, H, g);
    };
    let x, _, y, b, w, E, $, C, A, k, D, S;
    if (a === "top")
      x = m(this.bottom), E = this.bottom - d, C = x - v, k = m(t.top) + v, S = t.bottom;
    else if (a === "bottom")
      x = m(this.top), k = t.top, S = m(t.bottom) - v, E = x + v, C = this.top + d;
    else if (a === "left")
      x = m(this.right), w = this.right - d, $ = x - v, A = m(t.left) + v, D = t.right;
    else if (a === "right")
      x = m(this.left), A = t.left, D = m(t.right) - v, w = x + v, $ = this.left + d;
    else if (n === "x") {
      if (a === "center")
        x = m((t.top + t.bottom) / 2 + 0.5);
      else if (Me(a)) {
        const H = Object.keys(a)[0], M = a[H];
        x = m(this.chart.scales[H].getPixelForValue(M));
      }
      k = t.top, S = t.bottom, E = x + v, C = E + d;
    } else if (n === "y") {
      if (a === "center")
        x = m((t.left + t.right) / 2);
      else if (Me(a)) {
        const H = Object.keys(a)[0], M = a[H];
        x = m(this.chart.scales[H].getPixelForValue(M));
      }
      w = x - v, $ = w - d, A = t.left, D = t.right;
    }
    const L = Re(i.ticks.maxTicksLimit, f), P = Math.max(1, Math.ceil(f / L));
    for (_ = 0; _ < f; _ += P) {
      const H = this.getContext(_), M = s.setContext(H), B = o.setContext(H), W = M.lineWidth, R = M.color, O = B.dash || [], N = B.dashOffset, z = M.tickWidth, I = M.tickColor, te = M.tickBorderDash || [], ee = M.tickBorderDashOffset;
      y = Wj(this, _, l), y !== void 0 && (b = Zr(r, y, W), c ? w = $ = A = D = b : E = C = k = S = b, h.push({
        tx1: w,
        ty1: E,
        tx2: $,
        ty2: C,
        x1: A,
        y1: k,
        x2: D,
        y2: S,
        width: W,
        color: R,
        borderDash: O,
        borderDashOffset: N,
        tickWidth: z,
        tickColor: I,
        tickBorderDash: te,
        tickBorderDashOffset: ee
      }));
    }
    return this._ticksLength = f, this._borderValue = x, h;
  }
  _computeLabelItems(t) {
    const n = this.axis, r = this.options, { position: i, ticks: s } = r, a = this.isHorizontal(), o = this.ticks, { align: l, crossAlign: c, padding: u, mirror: f } = s, d = aa(r.grid), h = d + u, p = f ? -u : h, g = -Rn(this.labelRotation), v = [];
    let m, x, _, y, b, w, E, $, C, A, k, D, S = "middle";
    if (i === "top")
      w = this.bottom - p, E = this._getXAxisLabelAlignment();
    else if (i === "bottom")
      w = this.top + p, E = this._getXAxisLabelAlignment();
    else if (i === "left") {
      const P = this._getYAxisLabelAlignment(d);
      E = P.textAlign, b = P.x;
    } else if (i === "right") {
      const P = this._getYAxisLabelAlignment(d);
      E = P.textAlign, b = P.x;
    } else if (n === "x") {
      if (i === "center")
        w = (t.top + t.bottom) / 2 + h;
      else if (Me(i)) {
        const P = Object.keys(i)[0], H = i[P];
        w = this.chart.scales[P].getPixelForValue(H) + h;
      }
      E = this._getXAxisLabelAlignment();
    } else if (n === "y") {
      if (i === "center")
        b = (t.left + t.right) / 2 - h;
      else if (Me(i)) {
        const P = Object.keys(i)[0], H = i[P];
        b = this.chart.scales[P].getPixelForValue(H);
      }
      E = this._getYAxisLabelAlignment(d).textAlign;
    }
    n === "y" && (l === "start" ? S = "top" : l === "end" && (S = "bottom"));
    const L = this._getLabelSizes();
    for (m = 0, x = o.length; m < x; ++m) {
      _ = o[m], y = _.label;
      const P = s.setContext(this.getContext(m));
      $ = this.getPixelForTick(m) + s.labelOffset, C = this._resolveTickFontOptions(m), A = C.lineHeight, k = gt(y) ? y.length : 1;
      const H = k / 2, M = P.color, B = P.textStrokeColor, W = P.textStrokeWidth;
      let R = E;
      a ? (b = $, E === "inner" && (m === x - 1 ? R = this.options.reverse ? "left" : "right" : m === 0 ? R = this.options.reverse ? "right" : "left" : R = "center"), i === "top" ? c === "near" || g !== 0 ? D = -k * A + A / 2 : c === "center" ? D = -L.highest.height / 2 - H * A + A : D = -L.highest.height + A / 2 : c === "near" || g !== 0 ? D = A / 2 : c === "center" ? D = L.highest.height / 2 - H * A : D = L.highest.height - k * A, f && (D *= -1), g !== 0 && !P.showLabelBackdrop && (b += A / 2 * Math.sin(g))) : (w = $, D = (1 - k) * A / 2);
      let O;
      if (P.showLabelBackdrop) {
        const N = cr(P.backdropPadding), z = L.heights[m], I = L.widths[m];
        let te = D - N.top, ee = 0 - N.left;
        switch (S) {
          case "middle":
            te -= z / 2;
            break;
          case "bottom":
            te -= z;
            break;
        }
        switch (E) {
          case "center":
            ee -= I / 2;
            break;
          case "right":
            ee -= I;
            break;
          case "inner":
            m === x - 1 ? ee -= I : m > 0 && (ee -= I / 2);
            break;
        }
        O = {
          left: ee,
          top: te,
          width: I + N.width,
          height: z + N.height,
          color: P.backdropColor
        };
      }
      v.push({
        label: y,
        font: C,
        textOffset: D,
        options: {
          rotation: g,
          color: M,
          strokeColor: B,
          strokeWidth: W,
          textAlign: R,
          textBaseline: S,
          translation: [
            b,
            w
          ],
          backdrop: O
        }
      });
    }
    return v;
  }
  _getXAxisLabelAlignment() {
    const { position: t, ticks: n } = this.options;
    if (-Rn(this.labelRotation))
      return t === "top" ? "left" : "right";
    let i = "center";
    return n.align === "start" ? i = "left" : n.align === "end" ? i = "right" : n.align === "inner" && (i = "inner"), i;
  }
  _getYAxisLabelAlignment(t) {
    const { position: n, ticks: { crossAlign: r, mirror: i, padding: s } } = this.options, a = this._getLabelSizes(), o = t + s, l = a.widest.width;
    let c, u;
    return n === "left" ? i ? (u = this.right + s, r === "near" ? c = "left" : r === "center" ? (c = "center", u += l / 2) : (c = "right", u += l)) : (u = this.right - o, r === "near" ? c = "right" : r === "center" ? (c = "center", u -= l / 2) : (c = "left", u = this.left)) : n === "right" ? i ? (u = this.left + s, r === "near" ? c = "right" : r === "center" ? (c = "center", u -= l / 2) : (c = "left", u -= l)) : (u = this.left + o, r === "near" ? c = "left" : r === "center" ? (c = "center", u += l / 2) : (c = "right", u = this.right)) : c = "right", {
      textAlign: c,
      x: u
    };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror)
      return;
    const t = this.chart, n = this.options.position;
    if (n === "left" || n === "right")
      return {
        top: 0,
        left: this.left,
        bottom: t.height,
        right: this.right
      };
    if (n === "top" || n === "bottom")
      return {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: t.width
      };
  }
  drawBackground() {
    const { ctx: t, options: { backgroundColor: n }, left: r, top: i, width: s, height: a } = this;
    n && (t.save(), t.fillStyle = n, t.fillRect(r, i, s, a), t.restore());
  }
  getLineWidthForValue(t) {
    const n = this.options.grid;
    if (!this._isVisible() || !n.display)
      return 0;
    const i = this.ticks.findIndex((s) => s.value === t);
    return i >= 0 ? n.setContext(this.getContext(i)).lineWidth : 0;
  }
  drawGrid(t) {
    const n = this.options.grid, r = this.ctx, i = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t));
    let s, a;
    const o = (l, c, u) => {
      !u.width || !u.color || (r.save(), r.lineWidth = u.width, r.strokeStyle = u.color, r.setLineDash(u.borderDash || []), r.lineDashOffset = u.borderDashOffset, r.beginPath(), r.moveTo(l.x, l.y), r.lineTo(c.x, c.y), r.stroke(), r.restore());
    };
    if (n.display)
      for (s = 0, a = i.length; s < a; ++s) {
        const l = i[s];
        n.drawOnChartArea && o({
          x: l.x1,
          y: l.y1
        }, {
          x: l.x2,
          y: l.y2
        }, l), n.drawTicks && o({
          x: l.tx1,
          y: l.ty1
        }, {
          x: l.tx2,
          y: l.ty2
        }, {
          color: l.tickColor,
          width: l.tickWidth,
          borderDash: l.tickBorderDash,
          borderDashOffset: l.tickBorderDashOffset
        });
      }
  }
  drawBorder() {
    const { chart: t, ctx: n, options: { border: r, grid: i } } = this, s = r.setContext(this.getContext()), a = r.display ? s.width : 0;
    if (!a)
      return;
    const o = i.setContext(this.getContext(0)).lineWidth, l = this._borderValue;
    let c, u, f, d;
    this.isHorizontal() ? (c = Zr(t, this.left, a) - a / 2, u = Zr(t, this.right, o) + o / 2, f = d = l) : (f = Zr(t, this.top, a) - a / 2, d = Zr(t, this.bottom, o) + o / 2, c = u = l), n.save(), n.lineWidth = s.width, n.strokeStyle = s.color, n.beginPath(), n.moveTo(c, f), n.lineTo(u, d), n.stroke(), n.restore();
  }
  drawLabels(t) {
    if (!this.options.ticks.display)
      return;
    const r = this.ctx, i = this._computeLabelArea();
    i && Rw(r, i);
    const s = this.getLabelItems(t);
    for (const a of s) {
      const o = a.options, l = a.font, c = a.label, u = a.textOffset;
      bc(r, c, 0, u, l, o);
    }
    i && Bw(r);
  }
  drawTitle() {
    const { ctx: t, options: { position: n, title: r, reverse: i } } = this;
    if (!r.display)
      return;
    const s = _s(r.font), a = cr(r.padding), o = r.align;
    let l = s.lineHeight / 2;
    n === "bottom" || n === "center" || Me(n) ? (l += a.bottom, gt(r.text) && (l += s.lineHeight * (r.text.length - 1))) : l += a.top;
    const { titleX: c, titleY: u, maxWidth: f, rotation: d } = Xj(this, l, n, o);
    bc(t, r.text, 0, 0, s, {
      color: r.color,
      maxWidth: f,
      rotation: d,
      textAlign: Gj(o, n, i),
      textBaseline: "middle",
      translation: [
        c,
        u
      ]
    });
  }
  draw(t) {
    this._isVisible() && (this.drawBackground(), this.drawGrid(t), this.drawBorder(), this.drawTitle(), this.drawLabels(t));
  }
  _layers() {
    const t = this.options, n = t.ticks && t.ticks.z || 0, r = Re(t.grid && t.grid.z, -1), i = Re(t.border && t.border.z, 0);
    return !this._isVisible() || this.draw !== Si.prototype.draw ? [
      {
        z: n,
        draw: (s) => {
          this.draw(s);
        }
      }
    ] : [
      {
        z: r,
        draw: (s) => {
          this.drawBackground(), this.drawGrid(s), this.drawTitle();
        }
      },
      {
        z: i,
        draw: () => {
          this.drawBorder();
        }
      },
      {
        z: n,
        draw: (s) => {
          this.drawLabels(s);
        }
      }
    ];
  }
  getMatchingVisibleMetas(t) {
    const n = this.chart.getSortedVisibleDatasetMetas(), r = this.axis + "AxisID", i = [];
    let s, a;
    for (s = 0, a = n.length; s < a; ++s) {
      const o = n[s];
      o[r] === this.id && (!t || o.type === t) && i.push(o);
    }
    return i;
  }
  _resolveTickFontOptions(t) {
    const n = this.options.ticks.setContext(this.getContext(t));
    return _s(n.font);
  }
  _maxDigits() {
    const t = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / t;
  }
}
class rl {
  constructor(t, n, r) {
    this.type = t, this.scope = n, this.override = r, this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(t) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype);
  }
  register(t) {
    const n = Object.getPrototypeOf(t);
    let r;
    Jj(n) && (r = this.register(n));
    const i = this.items, s = t.id, a = this.scope + "." + s;
    if (!s)
      throw new Error("class does not have id: " + t);
    return s in i || (i[s] = t, Zj(t, a, r), this.override && mt.override(t.id, t.overrides)), a;
  }
  get(t) {
    return this.items[t];
  }
  unregister(t) {
    const n = this.items, r = t.id, i = this.scope;
    r in n && delete n[r], i && r in mt[i] && (delete mt[i][r], this.override && delete yi[r]);
  }
}
function Zj(e, t, n) {
  const r = Ka(/* @__PURE__ */ Object.create(null), [
    n ? mt.get(n) : {},
    mt.get(t),
    e.defaults
  ]);
  mt.set(t, r), e.defaultRoutes && Kj(t, e.defaultRoutes), e.descriptors && mt.describe(t, e.descriptors);
}
function Kj(e, t) {
  Object.keys(t).forEach((n) => {
    const r = n.split("."), i = r.pop(), s = [
      e
    ].concat(r).join("."), a = t[n].split("."), o = a.pop(), l = a.join(".");
    mt.route(s, i, l, o);
  });
}
function Jj(e) {
  return "id" in e && "defaults" in e;
}
class Qj {
  constructor() {
    this.controllers = new rl(us, "datasets", !0), this.elements = new rl(Ao, "elements"), this.plugins = new rl(Object, "plugins"), this.scales = new rl(Si, "scales"), this._typedRegistries = [
      this.controllers,
      this.scales,
      this.elements
    ];
  }
  add(...t) {
    this._each("register", t);
  }
  remove(...t) {
    this._each("unregister", t);
  }
  addControllers(...t) {
    this._each("register", t, this.controllers);
  }
  addElements(...t) {
    this._each("register", t, this.elements);
  }
  addPlugins(...t) {
    this._each("register", t, this.plugins);
  }
  addScales(...t) {
    this._each("register", t, this.scales);
  }
  getController(t) {
    return this._get(t, this.controllers, "controller");
  }
  getElement(t) {
    return this._get(t, this.elements, "element");
  }
  getPlugin(t) {
    return this._get(t, this.plugins, "plugin");
  }
  getScale(t) {
    return this._get(t, this.scales, "scale");
  }
  removeControllers(...t) {
    this._each("unregister", t, this.controllers);
  }
  removeElements(...t) {
    this._each("unregister", t, this.elements);
  }
  removePlugins(...t) {
    this._each("unregister", t, this.plugins);
  }
  removeScales(...t) {
    this._each("unregister", t, this.scales);
  }
  _each(t, n, r) {
    [
      ...n
    ].forEach((i) => {
      const s = r || this._getRegistryForType(i);
      r || s.isForType(i) || s === this.plugins && i.id ? this._exec(t, s, i) : Bt(i, (a) => {
        const o = r || this._getRegistryForType(a);
        this._exec(t, o, a);
      });
    });
  }
  _exec(t, n, r) {
    const i = Ch(t);
    ot(r["before" + i], [], r), n[t](r), ot(r["after" + i], [], r);
  }
  _getRegistryForType(t) {
    for (let n = 0; n < this._typedRegistries.length; n++) {
      const r = this._typedRegistries[n];
      if (r.isForType(t))
        return r;
    }
    return this.plugins;
  }
  _get(t, n, r) {
    const i = n.get(t);
    if (i === void 0)
      throw new Error('"' + t + '" is not a registered ' + r + ".");
    return i;
  }
}
var Mn = /* @__PURE__ */ new Qj();
class ez {
  constructor() {
    this._init = [];
  }
  notify(t, n, r, i) {
    n === "beforeInit" && (this._init = this._createDescriptors(t, !0), this._notify(this._init, t, "install"));
    const s = i ? this._descriptors(t).filter(i) : this._descriptors(t), a = this._notify(s, t, n, r);
    return n === "afterDestroy" && (this._notify(s, t, "stop"), this._notify(this._init, t, "uninstall")), a;
  }
  _notify(t, n, r, i) {
    i = i || {};
    for (const s of t) {
      const a = s.plugin, o = a[r], l = [
        n,
        i,
        s.options
      ];
      if (ot(o, l, a) === !1 && i.cancelable)
        return !1;
    }
    return !0;
  }
  invalidate() {
    Qe(this._cache) || (this._oldCache = this._cache, this._cache = void 0);
  }
  _descriptors(t) {
    if (this._cache)
      return this._cache;
    const n = this._cache = this._createDescriptors(t);
    return this._notifyStateChanges(t), n;
  }
  _createDescriptors(t, n) {
    const r = t && t.config, i = Re(r.options && r.options.plugins, {}), s = tz(r);
    return i === !1 && !n ? [] : rz(t, s, i, n);
  }
  _notifyStateChanges(t) {
    const n = this._oldCache || [], r = this._cache, i = (s, a) => s.filter((o) => !a.some((l) => o.plugin.id === l.plugin.id));
    this._notify(i(n, r), t, "stop"), this._notify(i(r, n), t, "start");
  }
}
function tz(e) {
  const t = {}, n = [], r = Object.keys(Mn.plugins.items);
  for (let s = 0; s < r.length; s++)
    n.push(Mn.getPlugin(r[s]));
  const i = e.plugins || [];
  for (let s = 0; s < i.length; s++) {
    const a = i[s];
    n.indexOf(a) === -1 && (n.push(a), t[a.id] = !0);
  }
  return {
    plugins: n,
    localIds: t
  };
}
function nz(e, t) {
  return !t && e === !1 ? null : e === !0 ? {} : e;
}
function rz(e, { plugins: t, localIds: n }, r, i) {
  const s = [], a = e.getContext();
  for (const o of t) {
    const l = o.id, c = nz(r[l], i);
    c !== null && s.push({
      plugin: o,
      options: iz(e.config, {
        plugin: o,
        local: n[l]
      }, c, a)
    });
  }
  return s;
}
function iz(e, { plugin: t, local: n }, r, i) {
  const s = e.pluginScopeKeys(t), a = e.getOptionScopes(r, s);
  return n && t.defaults && a.push(t.defaults), e.createResolver(a, i, [
    ""
  ], {
    scriptable: !1,
    indexable: !1,
    allKeys: !0
  });
}
function Hd(e, t) {
  const n = mt.datasets[e] || {};
  return ((t.datasets || {})[e] || {}).indexAxis || t.indexAxis || n.indexAxis || "x";
}
function sz(e, t) {
  let n = e;
  return e === "_index_" ? n = t : e === "_value_" && (n = t === "x" ? "y" : "x"), n;
}
function az(e, t) {
  return e === t ? "_index_" : "_value_";
}
function hm(e) {
  if (e === "x" || e === "y" || e === "r")
    return e;
}
function oz(e) {
  if (e === "top" || e === "bottom")
    return "x";
  if (e === "left" || e === "right")
    return "y";
}
function Wd(e, ...t) {
  if (hm(e))
    return e;
  for (const n of t) {
    const r = n.axis || oz(n.position) || e.length > 1 && hm(e[0].toLowerCase());
    if (r)
      return r;
  }
  throw new Error(`Cannot determine type of '${e}' axis. Please provide 'axis' or 'position' option.`);
}
function pm(e, t, n) {
  if (n[t + "AxisID"] === e)
    return {
      axis: t
    };
}
function lz(e, t) {
  if (t.data && t.data.datasets) {
    const n = t.data.datasets.filter((r) => r.xAxisID === e || r.yAxisID === e);
    if (n.length)
      return pm(e, "x", n[0]) || pm(e, "y", n[0]);
  }
  return {};
}
function cz(e, t) {
  const n = yi[e.type] || {
    scales: {}
  }, r = t.scales || {}, i = Hd(e.type, t), s = /* @__PURE__ */ Object.create(null);
  return Object.keys(r).forEach((a) => {
    const o = r[a];
    if (!Me(o))
      return console.error(`Invalid scale configuration for scale: ${a}`);
    if (o._proxy)
      return console.warn(`Ignoring resolver passed as options for scale: ${a}`);
    const l = Wd(a, o, lz(a, e), mt.scales[o.type]), c = az(l, i), u = n.scales || {};
    s[a] = Da(/* @__PURE__ */ Object.create(null), [
      {
        axis: l
      },
      o,
      u[l],
      u[c]
    ]);
  }), e.data.datasets.forEach((a) => {
    const o = a.type || e.type, l = a.indexAxis || Hd(o, t), u = (yi[o] || {}).scales || {};
    Object.keys(u).forEach((f) => {
      const d = sz(f, l), h = a[d + "AxisID"] || d;
      s[h] = s[h] || /* @__PURE__ */ Object.create(null), Da(s[h], [
        {
          axis: d
        },
        r[h],
        u[f]
      ]);
    });
  }), Object.keys(s).forEach((a) => {
    const o = s[a];
    Da(o, [
      mt.scales[o.type],
      mt.scale
    ]);
  }), s;
}
function Zw(e) {
  const t = e.options || (e.options = {});
  t.plugins = Re(t.plugins, {}), t.scales = cz(e, t);
}
function Kw(e) {
  return e = e || {}, e.datasets = e.datasets || [], e.labels = e.labels || [], e;
}
function uz(e) {
  return e = e || {}, e.data = Kw(e.data), Zw(e), e;
}
const gm = /* @__PURE__ */ new Map(), Jw = /* @__PURE__ */ new Set();
function il(e, t) {
  let n = gm.get(e);
  return n || (n = t(), gm.set(e, n), Jw.add(n)), n;
}
const oa = (e, t, n) => {
  const r = Ja(t, n);
  r !== void 0 && e.add(r);
};
class fz {
  constructor(t) {
    this._config = uz(t), this._scopeCache = /* @__PURE__ */ new Map(), this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(t) {
    this._config.type = t;
  }
  get data() {
    return this._config.data;
  }
  set data(t) {
    this._config.data = Kw(t);
  }
  get options() {
    return this._config.options;
  }
  set options(t) {
    this._config.options = t;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const t = this._config;
    this.clearCache(), Zw(t);
  }
  clearCache() {
    this._scopeCache.clear(), this._resolverCache.clear();
  }
  datasetScopeKeys(t) {
    return il(t, () => [
      [
        `datasets.${t}`,
        ""
      ]
    ]);
  }
  datasetAnimationScopeKeys(t, n) {
    return il(`${t}.transition.${n}`, () => [
      [
        `datasets.${t}.transitions.${n}`,
        `transitions.${n}`
      ],
      [
        `datasets.${t}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(t, n) {
    return il(`${t}-${n}`, () => [
      [
        `datasets.${t}.elements.${n}`,
        `datasets.${t}`,
        `elements.${n}`,
        ""
      ]
    ]);
  }
  pluginScopeKeys(t) {
    const n = t.id, r = this.type;
    return il(`${r}-plugin-${n}`, () => [
      [
        `plugins.${n}`,
        ...t.additionalOptionScopes || []
      ]
    ]);
  }
  _cachedScopes(t, n) {
    const r = this._scopeCache;
    let i = r.get(t);
    return (!i || n) && (i = /* @__PURE__ */ new Map(), r.set(t, i)), i;
  }
  getOptionScopes(t, n, r) {
    const { options: i, type: s } = this, a = this._cachedScopes(t, r), o = a.get(n);
    if (o)
      return o;
    const l = /* @__PURE__ */ new Set();
    n.forEach((u) => {
      t && (l.add(t), u.forEach((f) => oa(l, t, f))), u.forEach((f) => oa(l, i, f)), u.forEach((f) => oa(l, yi[s] || {}, f)), u.forEach((f) => oa(l, mt, f)), u.forEach((f) => oa(l, zd, f));
    });
    const c = Array.from(l);
    return c.length === 0 && c.push(/* @__PURE__ */ Object.create(null)), Jw.has(n) && a.set(n, c), c;
  }
  chartOptionScopes() {
    const { options: t, type: n } = this;
    return [
      t,
      yi[n] || {},
      mt.datasets[n] || {},
      {
        type: n
      },
      mt,
      zd
    ];
  }
  resolveNamedOptions(t, n, r, i = [
    ""
  ]) {
    const s = {
      $shared: !0
    }, { resolver: a, subPrefixes: o } = vm(this._resolverCache, t, i);
    let l = a;
    if (hz(a, n)) {
      s.$shared = !1, r = Br(r) ? r() : r;
      const c = this.createResolver(t, r, o);
      l = ws(a, r, c);
    }
    for (const c of n)
      s[c] = l[c];
    return s;
  }
  createResolver(t, n, r = [
    ""
  ], i) {
    const { resolver: s } = vm(this._resolverCache, t, r);
    return Me(n) ? ws(s, n, void 0, i) : s;
  }
}
function vm(e, t, n) {
  let r = e.get(t);
  r || (r = /* @__PURE__ */ new Map(), e.set(t, r));
  const i = n.join();
  let s = r.get(i);
  return s || (s = {
    resolver: Mh(t, n),
    subPrefixes: n.filter((o) => !o.toLowerCase().includes("hover"))
  }, r.set(i, s)), s;
}
const dz = (e) => Me(e) && Object.getOwnPropertyNames(e).some((t) => Br(e[t]));
function hz(e, t) {
  const { isScriptable: n, isIndexable: r } = Nw(e);
  for (const i of t) {
    const s = n(i), a = r(i), o = (a || s) && e[i];
    if (s && (Br(o) || dz(o)) || a && gt(o))
      return !0;
  }
  return !1;
}
var pz = "4.4.1";
const gz = [
  "top",
  "bottom",
  "left",
  "right",
  "chartArea"
];
function mm(e, t) {
  return e === "top" || e === "bottom" || gz.indexOf(e) === -1 && t === "x";
}
function ym(e, t) {
  return function(n, r) {
    return n[e] === r[e] ? n[t] - r[t] : n[e] - r[e];
  };
}
function xm(e) {
  const t = e.chart, n = t.options.animation;
  t.notifyPlugins("afterRender"), ot(n && n.onComplete, [
    e
  ], t);
}
function vz(e) {
  const t = e.chart, n = t.options.animation;
  ot(n && n.onProgress, [
    e
  ], t);
}
function Qw(e) {
  return Ih() && typeof e == "string" ? e = document.getElementById(e) : e && e.length && (e = e[0]), e && e.canvas && (e = e.canvas), e;
}
const Pl = {}, bm = (e) => {
  const t = Qw(e);
  return Object.values(Pl).filter((n) => n.canvas === t).pop();
};
function mz(e, t, n) {
  const r = Object.keys(e);
  for (const i of r) {
    const s = +i;
    if (s >= t) {
      const a = e[i];
      delete e[i], (n > 0 || s > t) && (e[s + n] = a);
    }
  }
}
function yz(e, t, n, r) {
  return !n || e.type === "mouseout" ? null : r ? t : e;
}
function sl(e, t, n) {
  return e.options.clip ? e[n] : t[n];
}
function xz(e, t) {
  const { xScale: n, yScale: r } = e;
  return n && r ? {
    left: sl(n, t, "left"),
    right: sl(n, t, "right"),
    top: sl(r, t, "top"),
    bottom: sl(r, t, "bottom")
  } : t;
}
class Kn {
  static register(...t) {
    Mn.add(...t), _m();
  }
  static unregister(...t) {
    Mn.remove(...t), _m();
  }
  constructor(t, n) {
    const r = this.config = new fz(n), i = Qw(t), s = bm(i);
    if (s)
      throw new Error("Canvas is already in use. Chart with ID '" + s.id + "' must be destroyed before the canvas with ID '" + s.canvas.id + "' can be reused.");
    const a = r.createResolver(r.chartOptionScopes(), this.getContext());
    this.platform = new (r.platform || Rj(i))(), this.platform.updateConfig(r);
    const o = this.platform.acquireContext(i, a.aspectRatio), l = o && o.canvas, c = l && l.height, u = l && l.width;
    if (this.id = $9(), this.ctx = o, this.canvas = l, this.width = u, this.height = c, this._options = a, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new ez(), this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = j9((f) => this.update(f), a.resizeDelay || 0), this._dataChanges = [], Pl[this.id] = this, !o || !l) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    Xn.listen(this, "complete", xm), Xn.listen(this, "progress", vz), this._initialize(), this.attached && this.update();
  }
  get aspectRatio() {
    const { options: { aspectRatio: t, maintainAspectRatio: n }, width: r, height: i, _aspectRatio: s } = this;
    return Qe(t) ? n && s ? s : i ? r / i : null : t;
  }
  get data() {
    return this.config.data;
  }
  set data(t) {
    this.config.data = t;
  }
  get options() {
    return this._options;
  }
  set options(t) {
    this.config.options = t;
  }
  get registry() {
    return Mn;
  }
  _initialize() {
    return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : Uv(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this;
  }
  clear() {
    return Vv(this.canvas, this.ctx), this;
  }
  stop() {
    return Xn.stop(this), this;
  }
  resize(t, n) {
    Xn.running(this) ? this._resizeBeforeDraw = {
      width: t,
      height: n
    } : this._resize(t, n);
  }
  _resize(t, n) {
    const r = this.options, i = this.canvas, s = r.maintainAspectRatio && this.aspectRatio, a = this.platform.getMaximumSize(i, t, n, s), o = r.devicePixelRatio || this.platform.getDevicePixelRatio(), l = this.width ? "resize" : "attach";
    this.width = a.width, this.height = a.height, this._aspectRatio = this.aspectRatio, Uv(this, o, !0) && (this.notifyPlugins("resize", {
      size: a
    }), ot(r.onResize, [
      this,
      a
    ], this), this.attached && this._doResize(l) && this.render());
  }
  ensureScalesHaveIDs() {
    const n = this.options.scales || {};
    Bt(n, (r, i) => {
      r.id = i;
    });
  }
  buildOrUpdateScales() {
    const t = this.options, n = t.scales, r = this.scales, i = Object.keys(r).reduce((a, o) => (a[o] = !1, a), {});
    let s = [];
    n && (s = s.concat(Object.keys(n).map((a) => {
      const o = n[a], l = Wd(a, o), c = l === "r", u = l === "x";
      return {
        options: o,
        dposition: c ? "chartArea" : u ? "bottom" : "left",
        dtype: c ? "radialLinear" : u ? "category" : "linear"
      };
    }))), Bt(s, (a) => {
      const o = a.options, l = o.id, c = Wd(l, o), u = Re(o.type, a.dtype);
      (o.position === void 0 || mm(o.position, c) !== mm(a.dposition)) && (o.position = a.dposition), i[l] = !0;
      let f = null;
      if (l in r && r[l].type === u)
        f = r[l];
      else {
        const d = Mn.getScale(u);
        f = new d({
          id: l,
          type: u,
          ctx: this.ctx,
          chart: this
        }), r[f.id] = f;
      }
      f.init(o, t);
    }), Bt(i, (a, o) => {
      a || delete r[o];
    }), Bt(r, (a) => {
      tl.configure(this, a, a.options), tl.addBox(this, a);
    });
  }
  _updateMetasets() {
    const t = this._metasets, n = this.data.datasets.length, r = t.length;
    if (t.sort((i, s) => i.index - s.index), r > n) {
      for (let i = n; i < r; ++i)
        this._destroyDatasetMeta(i);
      t.splice(n, r - n);
    }
    this._sortedMetasets = t.slice(0).sort(ym("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: t, data: { datasets: n } } = this;
    t.length > n.length && delete this._stacks, t.forEach((r, i) => {
      n.filter((s) => s === r._dataset).length === 0 && this._destroyDatasetMeta(i);
    });
  }
  buildOrUpdateControllers() {
    const t = [], n = this.data.datasets;
    let r, i;
    for (this._removeUnreferencedMetasets(), r = 0, i = n.length; r < i; r++) {
      const s = n[r];
      let a = this.getDatasetMeta(r);
      const o = s.type || this.config.type;
      if (a.type && a.type !== o && (this._destroyDatasetMeta(r), a = this.getDatasetMeta(r)), a.type = o, a.indexAxis = s.indexAxis || Hd(o, this.options), a.order = s.order || 0, a.index = r, a.label = "" + s.label, a.visible = this.isDatasetVisible(r), a.controller)
        a.controller.updateIndex(r), a.controller.linkScales();
      else {
        const l = Mn.getController(o), { datasetElementType: c, dataElementType: u } = mt.datasets[o];
        Object.assign(l, {
          dataElementType: Mn.getElement(u),
          datasetElementType: c && Mn.getElement(c)
        }), a.controller = new l(this, r), t.push(a.controller);
      }
    }
    return this._updateMetasets(), t;
  }
  _resetElements() {
    Bt(this.data.datasets, (t, n) => {
      this.getDatasetMeta(n).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements(), this.notifyPlugins("reset");
  }
  update(t) {
    const n = this.config;
    n.update();
    const r = this._options = n.createResolver(n.chartOptionScopes(), this.getContext()), i = this._animationsDisabled = !r.animation;
    if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), this.notifyPlugins("beforeUpdate", {
      mode: t,
      cancelable: !0
    }) === !1)
      return;
    const s = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let a = 0;
    for (let c = 0, u = this.data.datasets.length; c < u; c++) {
      const { controller: f } = this.getDatasetMeta(c), d = !i && s.indexOf(f) === -1;
      f.buildOrUpdateElements(d), a = Math.max(+f.getMaxOverflow(), a);
    }
    a = this._minPadding = r.layout.autoPadding ? a : 0, this._updateLayout(a), i || Bt(s, (c) => {
      c.reset();
    }), this._updateDatasets(t), this.notifyPlugins("afterUpdate", {
      mode: t
    }), this._layers.sort(ym("z", "_idx"));
    const { _active: o, _lastEvent: l } = this;
    l ? this._eventHandler(l, !0) : o.length && this._updateHoverStyles(o, o, !0), this.render();
  }
  _updateScales() {
    Bt(this.scales, (t) => {
      tl.removeBox(this, t);
    }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const t = this.options, n = new Set(Object.keys(this._listeners)), r = new Set(t.events);
    (!Ov(n, r) || !!this._responsiveListeners !== t.responsive) && (this.unbindEvents(), this.bindEvents());
  }
  _updateHiddenIndices() {
    const { _hiddenIndices: t } = this, n = this._getUniformDataChanges() || [];
    for (const { method: r, start: i, count: s } of n) {
      const a = r === "_removeElements" ? -s : s;
      mz(t, i, a);
    }
  }
  _getUniformDataChanges() {
    const t = this._dataChanges;
    if (!t || !t.length)
      return;
    this._dataChanges = [];
    const n = this.data.datasets.length, r = (s) => new Set(t.filter((a) => a[0] === s).map((a, o) => o + "," + a.splice(1).join(","))), i = r(0);
    for (let s = 1; s < n; s++)
      if (!Ov(i, r(s)))
        return;
    return Array.from(i).map((s) => s.split(",")).map((s) => ({
      method: s[1],
      start: +s[2],
      count: +s[3]
    }));
  }
  _updateLayout(t) {
    if (this.notifyPlugins("beforeLayout", {
      cancelable: !0
    }) === !1)
      return;
    tl.update(this, this.width, this.height, t);
    const n = this.chartArea, r = n.width <= 0 || n.height <= 0;
    this._layers = [], Bt(this.boxes, (i) => {
      r && i.position === "chartArea" || (i.configure && i.configure(), this._layers.push(...i._layers()));
    }, this), this._layers.forEach((i, s) => {
      i._idx = s;
    }), this.notifyPlugins("afterLayout");
  }
  _updateDatasets(t) {
    if (this.notifyPlugins("beforeDatasetsUpdate", {
      mode: t,
      cancelable: !0
    }) !== !1) {
      for (let n = 0, r = this.data.datasets.length; n < r; ++n)
        this.getDatasetMeta(n).controller.configure();
      for (let n = 0, r = this.data.datasets.length; n < r; ++n)
        this._updateDataset(n, Br(t) ? t({
          datasetIndex: n
        }) : t);
      this.notifyPlugins("afterDatasetsUpdate", {
        mode: t
      });
    }
  }
  _updateDataset(t, n) {
    const r = this.getDatasetMeta(t), i = {
      meta: r,
      index: t,
      mode: n,
      cancelable: !0
    };
    this.notifyPlugins("beforeDatasetUpdate", i) !== !1 && (r.controller._update(n), i.cancelable = !1, this.notifyPlugins("afterDatasetUpdate", i));
  }
  render() {
    this.notifyPlugins("beforeRender", {
      cancelable: !0
    }) !== !1 && (Xn.has(this) ? this.attached && !Xn.running(this) && Xn.start(this) : (this.draw(), xm({
      chart: this
    })));
  }
  draw() {
    let t;
    if (this._resizeBeforeDraw) {
      const { width: r, height: i } = this._resizeBeforeDraw;
      this._resize(r, i), this._resizeBeforeDraw = null;
    }
    if (this.clear(), this.width <= 0 || this.height <= 0 || this.notifyPlugins("beforeDraw", {
      cancelable: !0
    }) === !1)
      return;
    const n = this._layers;
    for (t = 0; t < n.length && n[t].z <= 0; ++t)
      n[t].draw(this.chartArea);
    for (this._drawDatasets(); t < n.length; ++t)
      n[t].draw(this.chartArea);
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(t) {
    const n = this._sortedMetasets, r = [];
    let i, s;
    for (i = 0, s = n.length; i < s; ++i) {
      const a = n[i];
      (!t || a.visible) && r.push(a);
    }
    return r;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(!0);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", {
      cancelable: !0
    }) === !1)
      return;
    const t = this.getSortedVisibleDatasetMetas();
    for (let n = t.length - 1; n >= 0; --n)
      this._drawDataset(t[n]);
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(t) {
    const n = this.ctx, r = t._clip, i = !r.disabled, s = xz(t, this.chartArea), a = {
      meta: t,
      index: t.index,
      cancelable: !0
    };
    this.notifyPlugins("beforeDatasetDraw", a) !== !1 && (i && Rw(n, {
      left: r.left === !1 ? 0 : s.left - r.left,
      right: r.right === !1 ? this.width : s.right + r.right,
      top: r.top === !1 ? 0 : s.top - r.top,
      bottom: r.bottom === !1 ? this.height : s.bottom + r.bottom
    }), t.controller.draw(), i && Bw(n), a.cancelable = !1, this.notifyPlugins("afterDatasetDraw", a));
  }
  isPointInArea(t) {
    return nr(t, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(t, n, r, i) {
    const s = gj.modes[n];
    return typeof s == "function" ? s(this, t, r, i) : [];
  }
  getDatasetMeta(t) {
    const n = this.data.datasets[t], r = this._metasets;
    let i = r.filter((s) => s && s._dataset === n).pop();
    return i || (i = {
      type: null,
      data: [],
      dataset: null,
      controller: null,
      hidden: null,
      xAxisID: null,
      yAxisID: null,
      order: n && n.order || 0,
      index: t,
      _dataset: n,
      _parsed: [],
      _sorted: !1
    }, r.push(i)), i;
  }
  getContext() {
    return this.$context || (this.$context = Di(null, {
      chart: this,
      type: "chart"
    }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(t) {
    const n = this.data.datasets[t];
    if (!n)
      return !1;
    const r = this.getDatasetMeta(t);
    return typeof r.hidden == "boolean" ? !r.hidden : !n.hidden;
  }
  setDatasetVisibility(t, n) {
    const r = this.getDatasetMeta(t);
    r.hidden = !n;
  }
  toggleDataVisibility(t) {
    this._hiddenIndices[t] = !this._hiddenIndices[t];
  }
  getDataVisibility(t) {
    return !this._hiddenIndices[t];
  }
  _updateVisibility(t, n, r) {
    const i = r ? "show" : "hide", s = this.getDatasetMeta(t), a = s.controller._resolveAnimations(void 0, i);
    mc(n) ? (s.data[n].hidden = !r, this.update()) : (this.setDatasetVisibility(t, r), a.update(s, {
      visible: r
    }), this.update((o) => o.datasetIndex === t ? i : void 0));
  }
  hide(t, n) {
    this._updateVisibility(t, n, !1);
  }
  show(t, n) {
    this._updateVisibility(t, n, !0);
  }
  _destroyDatasetMeta(t) {
    const n = this._metasets[t];
    n && n.controller && n.controller._destroy(), delete this._metasets[t];
  }
  _stop() {
    let t, n;
    for (this.stop(), Xn.remove(this), t = 0, n = this.data.datasets.length; t < n; ++t)
      this._destroyDatasetMeta(t);
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas: t, ctx: n } = this;
    this._stop(), this.config.clearCache(), t && (this.unbindEvents(), Vv(t, n), this.platform.releaseContext(n), this.canvas = null, this.ctx = null), delete Pl[this.id], this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...t) {
    return this.canvas.toDataURL(...t);
  }
  bindEvents() {
    this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0;
  }
  bindUserEvents() {
    const t = this._listeners, n = this.platform, r = (s, a) => {
      n.addEventListener(this, s, a), t[s] = a;
    }, i = (s, a, o) => {
      s.offsetX = a, s.offsetY = o, this._eventHandler(s);
    };
    Bt(this.options.events, (s) => r(s, i));
  }
  bindResponsiveEvents() {
    this._responsiveListeners || (this._responsiveListeners = {});
    const t = this._responsiveListeners, n = this.platform, r = (l, c) => {
      n.addEventListener(this, l, c), t[l] = c;
    }, i = (l, c) => {
      t[l] && (n.removeEventListener(this, l, c), delete t[l]);
    }, s = (l, c) => {
      this.canvas && this.resize(l, c);
    };
    let a;
    const o = () => {
      i("attach", o), this.attached = !0, this.resize(), r("resize", s), r("detach", a);
    };
    a = () => {
      this.attached = !1, i("resize", s), this._stop(), this._resize(0, 0), r("attach", o);
    }, n.isAttached(this.canvas) ? o() : a();
  }
  unbindEvents() {
    Bt(this._listeners, (t, n) => {
      this.platform.removeEventListener(this, n, t);
    }), this._listeners = {}, Bt(this._responsiveListeners, (t, n) => {
      this.platform.removeEventListener(this, n, t);
    }), this._responsiveListeners = void 0;
  }
  updateHoverStyle(t, n, r) {
    const i = r ? "set" : "remove";
    let s, a, o, l;
    for (n === "dataset" && (s = this.getDatasetMeta(t[0].datasetIndex), s.controller["_" + i + "DatasetHoverStyle"]()), o = 0, l = t.length; o < l; ++o) {
      a = t[o];
      const c = a && this.getDatasetMeta(a.datasetIndex).controller;
      c && c[i + "HoverStyle"](a.element, a.datasetIndex, a.index);
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(t) {
    const n = this._active || [], r = t.map(({ datasetIndex: s, index: a }) => {
      const o = this.getDatasetMeta(s);
      if (!o)
        throw new Error("No dataset found at index " + s);
      return {
        datasetIndex: s,
        element: o.data[a],
        index: a
      };
    });
    !Sv(r, n) && (this._active = r, this._lastEvent = null, this._updateHoverStyles(r, n));
  }
  notifyPlugins(t, n, r) {
    return this._plugins.notify(this, t, n, r);
  }
  isPluginEnabled(t) {
    return this._plugins._cache.filter((n) => n.plugin.id === t).length === 1;
  }
  _updateHoverStyles(t, n, r) {
    const i = this.options.hover, s = (l, c) => l.filter((u) => !c.some((f) => u.datasetIndex === f.datasetIndex && u.index === f.index)), a = s(n, t), o = r ? t : s(t, n);
    a.length && this.updateHoverStyle(a, i.mode, !1), o.length && i.mode && this.updateHoverStyle(o, i.mode, !0);
  }
  _eventHandler(t, n) {
    const r = {
      event: t,
      replay: n,
      cancelable: !0,
      inChartArea: this.isPointInArea(t)
    }, i = (a) => (a.options.events || this.options.events).includes(t.native.type);
    if (this.notifyPlugins("beforeEvent", r, i) === !1)
      return;
    const s = this._handleEvent(t, n, r.inChartArea);
    return r.cancelable = !1, this.notifyPlugins("afterEvent", r, i), (s || r.changed) && this.render(), this;
  }
  _handleEvent(t, n, r) {
    const { _active: i = [], options: s } = this, a = n, o = this._getActiveElements(t, i, r, a), l = S9(t), c = yz(t, this._lastEvent, r, l);
    r && (this._lastEvent = null, ot(s.onHover, [
      t,
      o,
      this
    ], this), l && ot(s.onClick, [
      t,
      o,
      this
    ], this));
    const u = !Sv(o, i);
    return (u || n) && (this._active = o, this._updateHoverStyles(o, i, n)), this._lastEvent = c, u;
  }
  _getActiveElements(t, n, r, i) {
    if (t.type === "mouseout")
      return [];
    if (!r)
      return n;
    const s = this.options.hover;
    return this.getElementsAtEventForMode(t, s.mode, s, i);
  }
}
V(Kn, "defaults", mt), V(Kn, "instances", Pl), V(Kn, "overrides", yi), V(Kn, "registry", Mn), V(Kn, "version", pz), V(Kn, "getChart", bm);
function _m() {
  return Bt(Kn.instances, (e) => e._plugins.invalidate());
}
function bz(e, t, n) {
  const { startAngle: r, pixelMargin: i, x: s, y: a, outerRadius: o, innerRadius: l } = t;
  let c = i / o;
  e.beginPath(), e.arc(s, a, o, r - c, n + c), l > i ? (c = i / l, e.arc(s, a, l, n + c, r - c, !0)) : e.arc(s, a, i, n + vt, r - vt), e.closePath(), e.clip();
}
function _z(e) {
  return Oh(e, [
    "outerStart",
    "outerEnd",
    "innerStart",
    "innerEnd"
  ]);
}
function wz(e, t, n, r) {
  const i = _z(e.options.borderRadius), s = (n - t) / 2, a = Math.min(s, r * t / 2), o = (l) => {
    const c = (n - Math.min(s, l)) * r / 2;
    return nn(l, 0, Math.min(s, c));
  };
  return {
    outerStart: o(i.outerStart),
    outerEnd: o(i.outerEnd),
    innerStart: nn(i.innerStart, 0, a),
    innerEnd: nn(i.innerEnd, 0, a)
  };
}
function Ui(e, t, n, r) {
  return {
    x: n + e * Math.cos(t),
    y: r + e * Math.sin(t)
  };
}
function $c(e, t, n, r, i, s) {
  const { x: a, y: o, startAngle: l, pixelMargin: c, innerRadius: u } = t, f = Math.max(t.outerRadius + r + n - c, 0), d = u > 0 ? u + r + n + c : 0;
  let h = 0;
  const p = i - l;
  if (r) {
    const P = u > 0 ? u - r : 0, H = f > 0 ? f - r : 0, M = (P + H) / 2, B = M !== 0 ? p * M / (M + r) : p;
    h = (p - B) / 2;
  }
  const g = Math.max(1e-3, p * f - n / lt) / f, v = (p - g) / 2, m = l + v + h, x = i - v - h, { outerStart: _, outerEnd: y, innerStart: b, innerEnd: w } = wz(t, d, f, x - m), E = f - _, $ = f - y, C = m + _ / E, A = x - y / $, k = d + b, D = d + w, S = m + b / k, L = x - w / D;
  if (e.beginPath(), s) {
    const P = (C + A) / 2;
    if (e.arc(a, o, f, C, P), e.arc(a, o, f, P, A), y > 0) {
      const W = Ui($, A, a, o);
      e.arc(W.x, W.y, y, A, x + vt);
    }
    const H = Ui(D, x, a, o);
    if (e.lineTo(H.x, H.y), w > 0) {
      const W = Ui(D, L, a, o);
      e.arc(W.x, W.y, w, x + vt, L + Math.PI);
    }
    const M = (x - w / d + (m + b / d)) / 2;
    if (e.arc(a, o, d, x - w / d, M, !0), e.arc(a, o, d, M, m + b / d, !0), b > 0) {
      const W = Ui(k, S, a, o);
      e.arc(W.x, W.y, b, S + Math.PI, m - vt);
    }
    const B = Ui(E, m, a, o);
    if (e.lineTo(B.x, B.y), _ > 0) {
      const W = Ui(E, C, a, o);
      e.arc(W.x, W.y, _, m - vt, C);
    }
  } else {
    e.moveTo(a, o);
    const P = Math.cos(C) * f + a, H = Math.sin(C) * f + o;
    e.lineTo(P, H);
    const M = Math.cos(A) * f + a, B = Math.sin(A) * f + o;
    e.lineTo(M, B);
  }
  e.closePath();
}
function $z(e, t, n, r, i) {
  const { fullCircles: s, startAngle: a, circumference: o } = t;
  let l = t.endAngle;
  if (s) {
    $c(e, t, n, r, l, i);
    for (let c = 0; c < s; ++c)
      e.fill();
    isNaN(o) || (l = a + (o % tt || tt));
  }
  return $c(e, t, n, r, l, i), e.fill(), l;
}
function Ez(e, t, n, r, i) {
  const { fullCircles: s, startAngle: a, circumference: o, options: l } = t, { borderWidth: c, borderJoinStyle: u, borderDash: f, borderDashOffset: d } = l, h = l.borderAlign === "inner";
  if (!c)
    return;
  e.setLineDash(f || []), e.lineDashOffset = d, h ? (e.lineWidth = c * 2, e.lineJoin = u || "round") : (e.lineWidth = c, e.lineJoin = u || "bevel");
  let p = t.endAngle;
  if (s) {
    $c(e, t, n, r, p, i);
    for (let g = 0; g < s; ++g)
      e.stroke();
    isNaN(o) || (p = a + (o % tt || tt));
  }
  h && bz(e, t, p), s || ($c(e, t, n, r, p, i), e.stroke());
}
class _a extends Ao {
  constructor(n) {
    super();
    V(this, "circumference");
    V(this, "endAngle");
    V(this, "fullCircles");
    V(this, "innerRadius");
    V(this, "outerRadius");
    V(this, "pixelMargin");
    V(this, "startAngle");
    this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, n && Object.assign(this, n);
  }
  inRange(n, r, i) {
    const s = this.getProps([
      "x",
      "y"
    ], i), { angle: a, distance: o } = Tw(s, {
      x: n,
      y: r
    }), { startAngle: l, endAngle: c, innerRadius: u, outerRadius: f, circumference: d } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], i), h = (this.options.spacing + this.options.borderWidth) / 2, g = Re(d, c - l) >= tt || eo(a, l, c), v = Ow(o, u + h, f + h);
    return g && v;
  }
  getCenterPoint(n) {
    const { x: r, y: i, startAngle: s, endAngle: a, innerRadius: o, outerRadius: l } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius"
    ], n), { offset: c, spacing: u } = this.options, f = (s + a) / 2, d = (o + l + u + c) / 2;
    return {
      x: r + Math.cos(f) * d,
      y: i + Math.sin(f) * d
    };
  }
  tooltipPosition(n) {
    return this.getCenterPoint(n);
  }
  draw(n) {
    const { options: r, circumference: i } = this, s = (r.offset || 0) / 4, a = (r.spacing || 0) / 2, o = r.circular;
    if (this.pixelMargin = r.borderAlign === "inner" ? 0.33 : 0, this.fullCircles = i > tt ? Math.floor(i / tt) : 0, i === 0 || this.innerRadius < 0 || this.outerRadius < 0)
      return;
    n.save();
    const l = (this.startAngle + this.endAngle) / 2;
    n.translate(Math.cos(l) * s, Math.sin(l) * s);
    const c = 1 - Math.sin(Math.min(lt, i || 0)), u = s * c;
    n.fillStyle = r.backgroundColor, n.strokeStyle = r.borderColor, $z(n, this, u, a, o), Ez(n, this, u, a, o), n.restore();
  }
}
V(_a, "id", "arc"), V(_a, "defaults", {
  borderAlign: "center",
  borderColor: "#fff",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: void 0,
  borderRadius: 0,
  borderWidth: 2,
  offset: 0,
  spacing: 0,
  angle: void 0,
  circular: !0
}), V(_a, "defaultRoutes", {
  backgroundColor: "backgroundColor"
}), V(_a, "descriptors", {
  _scriptable: !0,
  _indexable: (n) => n !== "borderDash"
});
function e2(e, t, n = t) {
  e.lineCap = Re(n.borderCapStyle, t.borderCapStyle), e.setLineDash(Re(n.borderDash, t.borderDash)), e.lineDashOffset = Re(n.borderDashOffset, t.borderDashOffset), e.lineJoin = Re(n.borderJoinStyle, t.borderJoinStyle), e.lineWidth = Re(n.borderWidth, t.borderWidth), e.strokeStyle = Re(n.borderColor, t.borderColor);
}
function Az(e, t, n) {
  e.lineTo(n.x, n.y);
}
function kz(e) {
  return e.stepped ? n7 : e.tension || e.cubicInterpolationMode === "monotone" ? r7 : Az;
}
function t2(e, t, n = {}) {
  const r = e.length, { start: i = 0, end: s = r - 1 } = n, { start: a, end: o } = t, l = Math.max(i, a), c = Math.min(s, o), u = i < a && s < a || i > o && s > o;
  return {
    count: r,
    start: l,
    loop: t.loop,
    ilen: c < l && !u ? r + c - l : c - l
  };
}
function Cz(e, t, n, r) {
  const { points: i, options: s } = t, { count: a, start: o, loop: l, ilen: c } = t2(i, n, r), u = kz(s);
  let { move: f = !0, reverse: d } = r || {}, h, p, g;
  for (h = 0; h <= c; ++h)
    p = i[(o + (d ? c - h : h)) % a], !p.skip && (f ? (e.moveTo(p.x, p.y), f = !1) : u(e, g, p, d, s.stepped), g = p);
  return l && (p = i[(o + (d ? c : 0)) % a], u(e, g, p, d, s.stepped)), !!l;
}
function Dz(e, t, n, r) {
  const i = t.points, { count: s, start: a, ilen: o } = t2(i, n, r), { move: l = !0, reverse: c } = r || {};
  let u = 0, f = 0, d, h, p, g, v, m;
  const x = (y) => (a + (c ? o - y : y)) % s, _ = () => {
    g !== v && (e.lineTo(u, v), e.lineTo(u, g), e.lineTo(u, m));
  };
  for (l && (h = i[x(0)], e.moveTo(h.x, h.y)), d = 0; d <= o; ++d) {
    if (h = i[x(d)], h.skip)
      continue;
    const y = h.x, b = h.y, w = y | 0;
    w === p ? (b < g ? g = b : b > v && (v = b), u = (f * u + y) / ++f) : (_(), e.lineTo(y, b), p = w, f = 0, g = v = b), m = b;
  }
  _();
}
function Ud(e) {
  const t = e.options, n = t.borderDash && t.borderDash.length;
  return !e._decimated && !e._loop && !t.tension && t.cubicInterpolationMode !== "monotone" && !t.stepped && !n ? Dz : Cz;
}
function Sz(e) {
  return e.stepped ? N7 : e.tension || e.cubicInterpolationMode === "monotone" ? L7 : ti;
}
function Tz(e, t, n, r) {
  let i = t._path;
  i || (i = t._path = new Path2D(), t.path(i, n, r) && i.closePath()), e2(e, t.options), e.stroke(i);
}
function Oz(e, t, n, r) {
  const { segments: i, options: s } = t, a = Ud(t);
  for (const o of i)
    e2(e, s, o.style), e.beginPath(), a(e, t, o, {
      start: n,
      end: n + r - 1
    }) && e.closePath(), e.stroke();
}
const Mz = typeof Path2D == "function";
function Fz(e, t, n, r) {
  Mz && !t.options.segment ? Tz(e, t, n, r) : Oz(e, t, n, r);
}
class wa extends Ao {
  constructor(t) {
    super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, t && Object.assign(this, t);
  }
  updateControlPoints(t, n) {
    const r = this.options;
    if ((r.tension || r.cubicInterpolationMode === "monotone") && !r.stepped && !this._pointsUpdated) {
      const i = r.spanGaps ? this._loop : this._fullLoop;
      T7(this._points, r, t, i, n), this._pointsUpdated = !0;
    }
  }
  set points(t) {
    this._points = t, delete this._segments, delete this._path, this._pointsUpdated = !1;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = U7(this, this.options.segment));
  }
  first() {
    const t = this.segments, n = this.points;
    return t.length && n[t[0].start];
  }
  last() {
    const t = this.segments, n = this.points, r = t.length;
    return r && n[t[r - 1].end];
  }
  interpolate(t, n) {
    const r = this.options, i = t[n], s = this.points, a = V7(this, {
      property: n,
      start: i,
      end: i
    });
    if (!a.length)
      return;
    const o = [], l = Sz(r);
    let c, u;
    for (c = 0, u = a.length; c < u; ++c) {
      const { start: f, end: d } = a[c], h = s[f], p = s[d];
      if (h === p) {
        o.push(h);
        continue;
      }
      const g = Math.abs((i - h[n]) / (p[n] - h[n])), v = l(h, p, g, r.stepped);
      v[n] = t[n], o.push(v);
    }
    return o.length === 1 ? o[0] : o;
  }
  pathSegment(t, n, r) {
    return Ud(this)(t, this, n, r);
  }
  path(t, n, r) {
    const i = this.segments, s = Ud(this);
    let a = this._loop;
    n = n || 0, r = r || this.points.length - n;
    for (const o of i)
      a &= s(t, this, o, {
        start: n,
        end: n + r - 1
      });
    return !!a;
  }
  draw(t, n, r, i) {
    const s = this.options || {};
    (this.points || []).length && s.borderWidth && (t.save(), Fz(t, this, r, i), t.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0);
  }
}
V(wa, "id", "line"), V(wa, "defaults", {
  borderCapStyle: "butt",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: "miter",
  borderWidth: 3,
  capBezierPoints: !0,
  cubicInterpolationMode: "default",
  fill: !1,
  spanGaps: !1,
  stepped: !1,
  tension: 0
}), V(wa, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
}), V(wa, "descriptors", {
  _scriptable: !0,
  _indexable: (t) => t !== "borderDash" && t !== "fill"
});
function wm(e, t, n, r) {
  const i = e.options, { [n]: s } = e.getProps([
    n
  ], r);
  return Math.abs(t - s) < i.radius + i.hitRadius;
}
class Il extends Ao {
  constructor(n) {
    super();
    V(this, "parsed");
    V(this, "skip");
    V(this, "stop");
    this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, n && Object.assign(this, n);
  }
  inRange(n, r, i) {
    const s = this.options, { x: a, y: o } = this.getProps([
      "x",
      "y"
    ], i);
    return Math.pow(n - a, 2) + Math.pow(r - o, 2) < Math.pow(s.hitRadius + s.radius, 2);
  }
  inXRange(n, r) {
    return wm(this, n, "x", r);
  }
  inYRange(n, r) {
    return wm(this, n, "y", r);
  }
  getCenterPoint(n) {
    const { x: r, y: i } = this.getProps([
      "x",
      "y"
    ], n);
    return {
      x: r,
      y: i
    };
  }
  size(n) {
    n = n || this.options || {};
    let r = n.radius || 0;
    r = Math.max(r, r && n.hoverRadius || 0);
    const i = r && n.borderWidth || 0;
    return (r + i) * 2;
  }
  draw(n, r) {
    const i = this.options;
    this.skip || i.radius < 0.1 || !nr(this, r, this.size(i) / 2) || (n.strokeStyle = i.borderColor, n.lineWidth = i.borderWidth, n.fillStyle = i.backgroundColor, e7(n, i, this.x, this.y));
  }
  getRange() {
    const n = this.options || {};
    return n.radius + n.hitRadius;
  }
}
V(Il, "id", "point"), /**
* @type {any}
*/
V(Il, "defaults", {
  borderWidth: 1,
  hitRadius: 1,
  hoverBorderWidth: 1,
  hoverRadius: 4,
  pointStyle: "circle",
  radius: 3,
  rotation: 0
}), /**
* @type {any}
*/
V(Il, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
const Pz = (e, t, n, r) => (typeof t == "string" ? (n = e.push(t) - 1, r.unshift({
  index: n,
  label: t
})) : isNaN(t) && (n = null), n);
function Iz(e, t, n, r) {
  const i = e.indexOf(t);
  if (i === -1)
    return Pz(e, t, n, r);
  const s = e.lastIndexOf(t);
  return i !== s ? n : i;
}
const Rz = (e, t) => e === null ? null : nn(Math.round(e), 0, t);
function $m(e) {
  const t = this.getLabels();
  return e >= 0 && e < t.length ? t[e] : e;
}
class Yd extends Si {
  constructor(t) {
    super(t), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [];
  }
  init(t) {
    const n = this._addedLabels;
    if (n.length) {
      const r = this.getLabels();
      for (const { index: i, label: s } of n)
        r[i] === s && r.splice(i, 1);
      this._addedLabels = [];
    }
    super.init(t);
  }
  parse(t, n) {
    if (Qe(t))
      return null;
    const r = this.getLabels();
    return n = isFinite(n) && r[n] === t ? n : Iz(r, t, Re(n, t), this._addedLabels), Rz(n, r.length - 1);
  }
  determineDataLimits() {
    const { minDefined: t, maxDefined: n } = this.getUserBounds();
    let { min: r, max: i } = this.getMinMax(!0);
    this.options.bounds === "ticks" && (t || (r = 0), n || (i = this.getLabels().length - 1)), this.min = r, this.max = i;
  }
  buildTicks() {
    const t = this.min, n = this.max, r = this.options.offset, i = [];
    let s = this.getLabels();
    s = t === 0 && n === s.length - 1 ? s : s.slice(t, n + 1), this._valueRange = Math.max(s.length - (r ? 0 : 1), 1), this._startValue = this.min - (r ? 0.5 : 0);
    for (let a = t; a <= n; a++)
      i.push({
        value: a
      });
    return i;
  }
  getLabelForValue(t) {
    return $m.call(this, t);
  }
  configure() {
    super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels);
  }
  getPixelForValue(t) {
    return typeof t != "number" && (t = this.parse(t)), t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);
  }
  getPixelForTick(t) {
    const n = this.ticks;
    return t < 0 || t > n.length - 1 ? null : this.getPixelForValue(n[t].value);
  }
  getValueForPixel(t) {
    return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
}
V(Yd, "id", "category"), V(Yd, "defaults", {
  ticks: {
    callback: $m
  }
});
function Bz(e, t) {
  const n = [], { bounds: i, step: s, min: a, max: o, precision: l, count: c, maxTicks: u, maxDigits: f, includeBounds: d } = e, h = s || 1, p = u - 1, { min: g, max: v } = t, m = !Qe(a), x = !Qe(o), _ = !Qe(c), y = (v - g) / (f + 1);
  let b = Fv((v - g) / p / h) * h, w, E, $, C;
  if (b < 1e-14 && !m && !x)
    return [
      {
        value: g
      },
      {
        value: v
      }
    ];
  C = Math.ceil(v / b) - Math.floor(g / b), C > p && (b = Fv(C * b / p / h) * h), Qe(l) || (w = Math.pow(10, l), b = Math.ceil(b * w) / w), i === "ticks" ? (E = Math.floor(g / b) * b, $ = Math.ceil(v / b) * b) : (E = g, $ = v), m && x && s && F9((o - a) / s, b / 1e3) ? (C = Math.round(Math.min((o - a) / b, u)), b = (o - a) / C, E = a, $ = o) : _ ? (E = m ? a : E, $ = x ? o : $, C = c - 1, b = ($ - E) / C) : (C = ($ - E) / b, Sa(C, Math.round(C), b / 1e3) ? C = Math.round(C) : C = Math.ceil(C));
  const A = Math.max(Pv(b), Pv(E));
  w = Math.pow(10, Qe(l) ? A : l), E = Math.round(E * w) / w, $ = Math.round($ * w) / w;
  let k = 0;
  for (m && (d && E !== a ? (n.push({
    value: a
  }), E < a && k++, Sa(Math.round((E + k * b) * w) / w, a, Em(a, y, e)) && k++) : E < a && k++); k < C; ++k) {
    const D = Math.round((E + k * b) * w) / w;
    if (x && D > o)
      break;
    n.push({
      value: D
    });
  }
  return x && d && $ !== o ? n.length && Sa(n[n.length - 1].value, o, Em(o, y, e)) ? n[n.length - 1].value = o : n.push({
    value: o
  }) : (!x || $ === o) && n.push({
    value: $
  }), n;
}
function Em(e, t, { horizontal: n, minRotation: r }) {
  const i = Rn(r), s = (n ? Math.sin(i) : Math.cos(i)) || 1e-3, a = 0.75 * t * ("" + e).length;
  return Math.min(t / s, a);
}
class Ec extends Si {
  constructor(t) {
    super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0;
  }
  parse(t, n) {
    return Qe(t) || (typeof t == "number" || t instanceof Number) && !isFinite(+t) ? null : +t;
  }
  handleTickRangeOptions() {
    const { beginAtZero: t } = this.options, { minDefined: n, maxDefined: r } = this.getUserBounds();
    let { min: i, max: s } = this;
    const a = (l) => i = n ? i : l, o = (l) => s = r ? s : l;
    if (t) {
      const l = bs(i), c = bs(s);
      l < 0 && c < 0 ? o(0) : l > 0 && c > 0 && a(0);
    }
    if (i === s) {
      let l = s === 0 ? 1 : Math.abs(s * 0.05);
      o(s + l), t || a(i - l);
    }
    this.min = i, this.max = s;
  }
  getTickLimit() {
    const t = this.options.ticks;
    let { maxTicksLimit: n, stepSize: r } = t, i;
    return r ? (i = Math.ceil(this.max / r) - Math.floor(this.min / r) + 1, i > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${r} would result generating up to ${i} ticks. Limiting to 1000.`), i = 1e3)) : (i = this.computeTickLimit(), n = n || 11), n && (i = Math.min(n, i)), i;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const t = this.options, n = t.ticks;
    let r = this.getTickLimit();
    r = Math.max(2, r);
    const i = {
      maxTicks: r,
      bounds: t.bounds,
      min: t.min,
      max: t.max,
      precision: n.precision,
      step: n.stepSize,
      count: n.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: n.minRotation || 0,
      includeBounds: n.includeBounds !== !1
    }, s = this._range || this, a = Bz(i, s);
    return t.bounds === "ticks" && Sw(a, this, "value"), t.reverse ? (a.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), a;
  }
  configure() {
    const t = this.ticks;
    let n = this.min, r = this.max;
    if (super.configure(), this.options.offset && t.length) {
      const i = (r - n) / Math.max(t.length - 1, 1) / 2;
      n -= i, r += i;
    }
    this._startValue = n, this._endValue = r, this._valueRange = r - n;
  }
  getLabelForValue(t) {
    return vu(t, this.chart.options.locale, this.options.ticks.format);
  }
}
class qd extends Ec {
  determineDataLimits() {
    const { min: t, max: n } = this.getMinMax(!0);
    this.min = kt(t) ? t : 0, this.max = kt(n) ? n : 1, this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const t = this.isHorizontal(), n = t ? this.width : this.height, r = Rn(this.options.ticks.minRotation), i = (t ? Math.sin(r) : Math.cos(r)) || 1e-3, s = this._resolveTickFontOptions(0);
    return Math.ceil(n / Math.min(40, s.lineHeight / i));
  }
  getPixelForValue(t) {
    return t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);
  }
  getValueForPixel(t) {
    return this._startValue + this.getDecimalForPixel(t) * this._valueRange;
  }
}
V(qd, "id", "linear"), V(qd, "defaults", {
  ticks: {
    callback: mu.formatters.numeric
  }
});
const no = (e) => Math.floor(Or(e)), Jr = (e, t) => Math.pow(10, no(e) + t);
function Am(e) {
  return e / Math.pow(10, no(e)) === 1;
}
function km(e, t, n) {
  const r = Math.pow(10, n), i = Math.floor(e / r);
  return Math.ceil(t / r) - i;
}
function Nz(e, t) {
  const n = t - e;
  let r = no(n);
  for (; km(e, t, r) > 10; )
    r++;
  for (; km(e, t, r) < 10; )
    r--;
  return Math.min(r, no(e));
}
function Lz(e, { min: t, max: n }) {
  t = en(e.min, t);
  const r = [], i = no(t);
  let s = Nz(t, n), a = s < 0 ? Math.pow(10, Math.abs(s)) : 1;
  const o = Math.pow(10, s), l = i > s ? Math.pow(10, i) : 0, c = Math.round((t - l) * a) / a, u = Math.floor((t - l) / o / 10) * o * 10;
  let f = Math.floor((c - u) / Math.pow(10, s)), d = en(e.min, Math.round((l + u + f * Math.pow(10, s)) * a) / a);
  for (; d < n; )
    r.push({
      value: d,
      major: Am(d),
      significand: f
    }), f >= 10 ? f = f < 15 ? 15 : 20 : f++, f >= 20 && (s++, f = 2, a = s >= 0 ? 1 : a), d = Math.round((l + u + f * Math.pow(10, s)) * a) / a;
  const h = en(e.max, d);
  return r.push({
    value: h,
    major: Am(h),
    significand: f
  }), r;
}
class Cm extends Si {
  constructor(t) {
    super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0;
  }
  parse(t, n) {
    const r = Ec.prototype.parse.apply(this, [
      t,
      n
    ]);
    if (r === 0) {
      this._zero = !0;
      return;
    }
    return kt(r) && r > 0 ? r : null;
  }
  determineDataLimits() {
    const { min: t, max: n } = this.getMinMax(!0);
    this.min = kt(t) ? Math.max(0, t) : null, this.max = kt(n) ? Math.max(0, n) : null, this.options.beginAtZero && (this._zero = !0), this._zero && this.min !== this._suggestedMin && !kt(this._userMin) && (this.min = t === Jr(this.min, 0) ? Jr(this.min, -1) : Jr(this.min, 0)), this.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    const { minDefined: t, maxDefined: n } = this.getUserBounds();
    let r = this.min, i = this.max;
    const s = (o) => r = t ? r : o, a = (o) => i = n ? i : o;
    r === i && (r <= 0 ? (s(1), a(10)) : (s(Jr(r, -1)), a(Jr(i, 1)))), r <= 0 && s(Jr(i, -1)), i <= 0 && a(Jr(r, 1)), this.min = r, this.max = i;
  }
  buildTicks() {
    const t = this.options, n = {
      min: this._userMin,
      max: this._userMax
    }, r = Lz(n, this);
    return t.bounds === "ticks" && Sw(r, this, "value"), t.reverse ? (r.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), r;
  }
  getLabelForValue(t) {
    return t === void 0 ? "0" : vu(t, this.chart.options.locale, this.options.ticks.format);
  }
  configure() {
    const t = this.min;
    super.configure(), this._startValue = Or(t), this._valueRange = Or(this.max) - Or(t);
  }
  getPixelForValue(t) {
    return (t === void 0 || t === 0) && (t = this.min), t === null || isNaN(t) ? NaN : this.getPixelForDecimal(t === this.min ? 0 : (Or(t) - this._startValue) / this._valueRange);
  }
  getValueForPixel(t) {
    const n = this.getDecimalForPixel(t);
    return Math.pow(10, this._startValue + n * this._valueRange);
  }
}
V(Cm, "id", "logarithmic"), V(Cm, "defaults", {
  ticks: {
    callback: mu.formatters.logarithmic,
    major: {
      enabled: !0
    }
  }
});
function Gd(e) {
  const t = e.ticks;
  if (t.display && e.display) {
    const n = cr(t.backdropPadding);
    return Re(t.font && t.font.size, mt.font.size) + n.height;
  }
  return 0;
}
function jz(e, t, n) {
  return n = gt(n) ? n : [
    n
  ], {
    w: Q9(e, t.string, n),
    h: n.length * t.lineHeight
  };
}
function Dm(e, t, n, r, i) {
  return e === r || e === i ? {
    start: t - n / 2,
    end: t + n / 2
  } : e < r || e > i ? {
    start: t - n,
    end: t
  } : {
    start: t,
    end: t + n
  };
}
function zz(e) {
  const t = {
    l: e.left + e._padding.left,
    r: e.right - e._padding.right,
    t: e.top + e._padding.top,
    b: e.bottom - e._padding.bottom
  }, n = Object.assign({}, t), r = [], i = [], s = e._pointLabels.length, a = e.options.pointLabels, o = a.centerPointLabels ? lt / s : 0;
  for (let l = 0; l < s; l++) {
    const c = a.setContext(e.getPointLabelContext(l));
    i[l] = c.padding;
    const u = e.getPointPosition(l, e.drawingArea + i[l], o), f = _s(c.font), d = jz(e.ctx, f, e._pointLabels[l]);
    r[l] = d;
    const h = En(e.getIndexAngle(l) + o), p = Math.round(Dh(h)), g = Dm(p, u.x, d.w, 0, 180), v = Dm(p, u.y, d.h, 90, 270);
    Vz(n, t, h, g, v);
  }
  e.setCenterPoint(t.l - n.l, n.r - t.r, t.t - n.t, n.b - t.b), e._pointLabelItems = Uz(e, r, i);
}
function Vz(e, t, n, r, i) {
  const s = Math.abs(Math.sin(n)), a = Math.abs(Math.cos(n));
  let o = 0, l = 0;
  r.start < t.l ? (o = (t.l - r.start) / s, e.l = Math.min(e.l, t.l - o)) : r.end > t.r && (o = (r.end - t.r) / s, e.r = Math.max(e.r, t.r + o)), i.start < t.t ? (l = (t.t - i.start) / a, e.t = Math.min(e.t, t.t - l)) : i.end > t.b && (l = (i.end - t.b) / a, e.b = Math.max(e.b, t.b + l));
}
function Hz(e, t, n) {
  const r = e.drawingArea, { extra: i, additionalAngle: s, padding: a, size: o } = n, l = e.getPointPosition(t, r + i + a, s), c = Math.round(Dh(En(l.angle + vt))), u = Gz(l.y, o.h, c), f = Yz(c), d = qz(l.x, o.w, f);
  return {
    visible: !0,
    x: l.x,
    y: u,
    textAlign: f,
    left: d,
    top: u,
    right: d + o.w,
    bottom: u + o.h
  };
}
function Wz(e, t) {
  if (!t)
    return !0;
  const { left: n, top: r, right: i, bottom: s } = e;
  return !(nr({
    x: n,
    y: r
  }, t) || nr({
    x: n,
    y: s
  }, t) || nr({
    x: i,
    y: r
  }, t) || nr({
    x: i,
    y: s
  }, t));
}
function Uz(e, t, n) {
  const r = [], i = e._pointLabels.length, s = e.options, { centerPointLabels: a, display: o } = s.pointLabels, l = {
    extra: Gd(s) / 2,
    additionalAngle: a ? lt / i : 0
  };
  let c;
  for (let u = 0; u < i; u++) {
    l.padding = n[u], l.size = t[u];
    const f = Hz(e, u, l);
    r.push(f), o === "auto" && (f.visible = Wz(f, c), f.visible && (c = f));
  }
  return r;
}
function Yz(e) {
  return e === 0 || e === 180 ? "center" : e < 180 ? "left" : "right";
}
function qz(e, t, n) {
  return n === "right" ? e -= t : n === "center" && (e -= t / 2), e;
}
function Gz(e, t, n) {
  return n === 90 || n === 270 ? e -= t / 2 : (n > 270 || n < 90) && (e -= t), e;
}
function Xz(e, t, n) {
  const { left: r, top: i, right: s, bottom: a } = n, { backdropColor: o } = t;
  if (!Qe(o)) {
    const l = h7(t.borderRadius), c = cr(t.backdropPadding);
    e.fillStyle = o;
    const u = r - c.left, f = i - c.top, d = s - r + c.width, h = a - i + c.height;
    Object.values(l).some((p) => p !== 0) ? (e.beginPath(), o7(e, {
      x: u,
      y: f,
      w: d,
      h,
      radius: l
    }), e.fill()) : e.fillRect(u, f, d, h);
  }
}
function Zz(e, t) {
  const { ctx: n, options: { pointLabels: r } } = e;
  for (let i = t - 1; i >= 0; i--) {
    const s = e._pointLabelItems[i];
    if (!s.visible)
      continue;
    const a = r.setContext(e.getPointLabelContext(i));
    Xz(n, a, s);
    const o = _s(a.font), { x: l, y: c, textAlign: u } = s;
    bc(n, e._pointLabels[i], l, c + o.lineHeight / 2, o, {
      color: a.color,
      textAlign: u,
      textBaseline: "middle"
    });
  }
}
function n2(e, t, n, r) {
  const { ctx: i } = e;
  if (n)
    i.arc(e.xCenter, e.yCenter, t, 0, tt);
  else {
    let s = e.getPointPosition(0, t);
    i.moveTo(s.x, s.y);
    for (let a = 1; a < r; a++)
      s = e.getPointPosition(a, t), i.lineTo(s.x, s.y);
  }
}
function Kz(e, t, n, r, i) {
  const s = e.ctx, a = t.circular, { color: o, lineWidth: l } = t;
  !a && !r || !o || !l || n < 0 || (s.save(), s.strokeStyle = o, s.lineWidth = l, s.setLineDash(i.dash), s.lineDashOffset = i.dashOffset, s.beginPath(), n2(e, n, a, r), s.closePath(), s.stroke(), s.restore());
}
function Jz(e, t, n) {
  return Di(e, {
    label: n,
    index: t,
    type: "pointLabel"
  });
}
class al extends Ec {
  constructor(t) {
    super(t), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = [];
  }
  setDimensions() {
    const t = this._padding = cr(Gd(this.options) / 2), n = this.width = this.maxWidth - t.width, r = this.height = this.maxHeight - t.height;
    this.xCenter = Math.floor(this.left + n / 2 + t.left), this.yCenter = Math.floor(this.top + r / 2 + t.top), this.drawingArea = Math.floor(Math.min(n, r) / 2);
  }
  determineDataLimits() {
    const { min: t, max: n } = this.getMinMax(!1);
    this.min = kt(t) && !isNaN(t) ? t : 0, this.max = kt(n) && !isNaN(n) ? n : 0, this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / Gd(this.options));
  }
  generateTickLabels(t) {
    Ec.prototype.generateTickLabels.call(this, t), this._pointLabels = this.getLabels().map((n, r) => {
      const i = ot(this.options.pointLabels.callback, [
        n,
        r
      ], this);
      return i || i === 0 ? i : "";
    }).filter((n, r) => this.chart.getDataVisibility(r));
  }
  fit() {
    const t = this.options;
    t.display && t.pointLabels.display ? zz(this) : this.setCenterPoint(0, 0, 0, 0);
  }
  setCenterPoint(t, n, r, i) {
    this.xCenter += Math.floor((t - n) / 2), this.yCenter += Math.floor((r - i) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(t, n, r, i));
  }
  getIndexAngle(t) {
    const n = tt / (this._pointLabels.length || 1), r = this.options.startAngle || 0;
    return En(t * n + Rn(r));
  }
  getDistanceFromCenterForValue(t) {
    if (Qe(t))
      return NaN;
    const n = this.drawingArea / (this.max - this.min);
    return this.options.reverse ? (this.max - t) * n : (t - this.min) * n;
  }
  getValueForDistanceFromCenter(t) {
    if (Qe(t))
      return NaN;
    const n = t / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - n : this.min + n;
  }
  getPointLabelContext(t) {
    const n = this._pointLabels || [];
    if (t >= 0 && t < n.length) {
      const r = n[t];
      return Jz(this.getContext(), t, r);
    }
  }
  getPointPosition(t, n, r = 0) {
    const i = this.getIndexAngle(t) - vt + r;
    return {
      x: Math.cos(i) * n + this.xCenter,
      y: Math.sin(i) * n + this.yCenter,
      angle: i
    };
  }
  getPointPositionForValue(t, n) {
    return this.getPointPosition(t, this.getDistanceFromCenterForValue(n));
  }
  getBasePosition(t) {
    return this.getPointPositionForValue(t || 0, this.getBaseValue());
  }
  getPointLabelPosition(t) {
    const { left: n, top: r, right: i, bottom: s } = this._pointLabelItems[t];
    return {
      left: n,
      top: r,
      right: i,
      bottom: s
    };
  }
  drawBackground() {
    const { backgroundColor: t, grid: { circular: n } } = this.options;
    if (t) {
      const r = this.ctx;
      r.save(), r.beginPath(), n2(this, this.getDistanceFromCenterForValue(this._endValue), n, this._pointLabels.length), r.closePath(), r.fillStyle = t, r.fill(), r.restore();
    }
  }
  drawGrid() {
    const t = this.ctx, n = this.options, { angleLines: r, grid: i, border: s } = n, a = this._pointLabels.length;
    let o, l, c;
    if (n.pointLabels.display && Zz(this, a), i.display && this.ticks.forEach((u, f) => {
      if (f !== 0) {
        l = this.getDistanceFromCenterForValue(u.value);
        const d = this.getContext(f), h = i.setContext(d), p = s.setContext(d);
        Kz(this, h, l, a, p);
      }
    }), r.display) {
      for (t.save(), o = a - 1; o >= 0; o--) {
        const u = r.setContext(this.getPointLabelContext(o)), { color: f, lineWidth: d } = u;
        !d || !f || (t.lineWidth = d, t.strokeStyle = f, t.setLineDash(u.borderDash), t.lineDashOffset = u.borderDashOffset, l = this.getDistanceFromCenterForValue(n.ticks.reverse ? this.min : this.max), c = this.getPointPosition(o, l), t.beginPath(), t.moveTo(this.xCenter, this.yCenter), t.lineTo(c.x, c.y), t.stroke());
      }
      t.restore();
    }
  }
  drawBorder() {
  }
  drawLabels() {
    const t = this.ctx, n = this.options, r = n.ticks;
    if (!r.display)
      return;
    const i = this.getIndexAngle(0);
    let s, a;
    t.save(), t.translate(this.xCenter, this.yCenter), t.rotate(i), t.textAlign = "center", t.textBaseline = "middle", this.ticks.forEach((o, l) => {
      if (l === 0 && !n.reverse)
        return;
      const c = r.setContext(this.getContext(l)), u = _s(c.font);
      if (s = this.getDistanceFromCenterForValue(this.ticks[l].value), c.showLabelBackdrop) {
        t.font = u.string, a = t.measureText(o.label).width, t.fillStyle = c.backdropColor;
        const f = cr(c.backdropPadding);
        t.fillRect(-a / 2 - f.left, -s - u.size / 2 - f.top, a + f.width, u.size + f.height);
      }
      bc(t, o.label, 0, -s, u, {
        color: c.color,
        strokeColor: c.textStrokeColor,
        strokeWidth: c.textStrokeWidth
      });
    }), t.restore();
  }
  drawTitle() {
  }
}
V(al, "id", "radialLinear"), V(al, "defaults", {
  display: !0,
  animate: !0,
  position: "chartArea",
  angleLines: {
    display: !0,
    lineWidth: 1,
    borderDash: [],
    borderDashOffset: 0
  },
  grid: {
    circular: !1
  },
  startAngle: 0,
  ticks: {
    showLabelBackdrop: !0,
    callback: mu.formatters.numeric
  },
  pointLabels: {
    backdropColor: void 0,
    backdropPadding: 2,
    display: !0,
    font: {
      size: 10
    },
    callback(t) {
      return t;
    },
    padding: 5,
    centerPointLabels: !1
  }
}), V(al, "defaultRoutes", {
  "angleLines.color": "borderColor",
  "pointLabels.color": "color",
  "ticks.color": "color"
}), V(al, "descriptors", {
  angleLines: {
    _fallback: "grid"
  }
});
const xu = {
  millisecond: {
    common: !0,
    size: 1,
    steps: 1e3
  },
  second: {
    common: !0,
    size: 1e3,
    steps: 60
  },
  minute: {
    common: !0,
    size: 6e4,
    steps: 60
  },
  hour: {
    common: !0,
    size: 36e5,
    steps: 24
  },
  day: {
    common: !0,
    size: 864e5,
    steps: 30
  },
  week: {
    common: !1,
    size: 6048e5,
    steps: 4
  },
  month: {
    common: !0,
    size: 2628e6,
    steps: 12
  },
  quarter: {
    common: !1,
    size: 7884e6,
    steps: 4
  },
  year: {
    common: !0,
    size: 3154e7
  }
}, Xt = /* @__PURE__ */ Object.keys(xu);
function Sm(e, t) {
  return e - t;
}
function Tm(e, t) {
  if (Qe(t))
    return null;
  const n = e._adapter, { parser: r, round: i, isoWeekday: s } = e._parseOpts;
  let a = t;
  return typeof r == "function" && (a = r(a)), kt(a) || (a = typeof r == "string" ? n.parse(a, r) : n.parse(a)), a === null ? null : (i && (a = i === "week" && (Qa(s) || s === !0) ? n.startOf(a, "isoWeek", s) : n.startOf(a, i)), +a);
}
function Om(e, t, n, r) {
  const i = Xt.length;
  for (let s = Xt.indexOf(e); s < i - 1; ++s) {
    const a = xu[Xt[s]], o = a.steps ? a.steps : Number.MAX_SAFE_INTEGER;
    if (a.common && Math.ceil((n - t) / (o * a.size)) <= r)
      return Xt[s];
  }
  return Xt[i - 1];
}
function Qz(e, t, n, r, i) {
  for (let s = Xt.length - 1; s >= Xt.indexOf(n); s--) {
    const a = Xt[s];
    if (xu[a].common && e._adapter.diff(i, r, a) >= t - 1)
      return a;
  }
  return Xt[n ? Xt.indexOf(n) : 0];
}
function eV(e) {
  for (let t = Xt.indexOf(e) + 1, n = Xt.length; t < n; ++t)
    if (xu[Xt[t]].common)
      return Xt[t];
}
function Mm(e, t, n) {
  if (!n)
    e[t] = !0;
  else if (n.length) {
    const { lo: r, hi: i } = Sh(n, t), s = n[r] >= t ? n[r] : n[i];
    e[s] = !0;
  }
}
function tV(e, t, n, r) {
  const i = e._adapter, s = +i.startOf(t[0].value, r), a = t[t.length - 1].value;
  let o, l;
  for (o = s; o <= a; o = +i.add(o, 1, r))
    l = n[o], l >= 0 && (t[l].major = !0);
  return t;
}
function Fm(e, t, n) {
  const r = [], i = {}, s = t.length;
  let a, o;
  for (a = 0; a < s; ++a)
    o = t[a], i[o] = a, r.push({
      value: o,
      major: !1
    });
  return s === 0 || !n ? r : tV(e, r, i, n);
}
class Ac extends Si {
  constructor(t) {
    super(t), this._cache = {
      data: [],
      labels: [],
      all: []
    }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0;
  }
  init(t, n = {}) {
    const r = t.time || (t.time = {}), i = this._adapter = new uj._date(t.adapters.date);
    i.init(n), Da(r.displayFormats, i.formats()), this._parseOpts = {
      parser: r.parser,
      round: r.round,
      isoWeekday: r.isoWeekday
    }, super.init(t), this._normalized = n.normalized;
  }
  parse(t, n) {
    return t === void 0 ? null : Tm(this, t);
  }
  beforeLayout() {
    super.beforeLayout(), this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const t = this.options, n = this._adapter, r = t.time.unit || "day";
    let { min: i, max: s, minDefined: a, maxDefined: o } = this.getUserBounds();
    function l(c) {
      !a && !isNaN(c.min) && (i = Math.min(i, c.min)), !o && !isNaN(c.max) && (s = Math.max(s, c.max));
    }
    (!a || !o) && (l(this._getLabelBounds()), (t.bounds !== "ticks" || t.ticks.source !== "labels") && l(this.getMinMax(!1))), i = kt(i) && !isNaN(i) ? i : +n.startOf(Date.now(), r), s = kt(s) && !isNaN(s) ? s : +n.endOf(Date.now(), r) + 1, this.min = Math.min(i, s - 1), this.max = Math.max(i + 1, s);
  }
  _getLabelBounds() {
    const t = this.getLabelTimestamps();
    let n = Number.POSITIVE_INFINITY, r = Number.NEGATIVE_INFINITY;
    return t.length && (n = t[0], r = t[t.length - 1]), {
      min: n,
      max: r
    };
  }
  buildTicks() {
    const t = this.options, n = t.time, r = t.ticks, i = r.source === "labels" ? this.getLabelTimestamps() : this._generate();
    t.bounds === "ticks" && i.length && (this.min = this._userMin || i[0], this.max = this._userMax || i[i.length - 1]);
    const s = this.min, a = this.max, o = B9(i, s, a);
    return this._unit = n.unit || (r.autoSkip ? Om(n.minUnit, this.min, this.max, this._getLabelCapacity(s)) : Qz(this, o.length, n.minUnit, this.min, this.max)), this._majorUnit = !r.major.enabled || this._unit === "year" ? void 0 : eV(this._unit), this.initOffsets(i), t.reverse && o.reverse(), Fm(this, o, this._majorUnit);
  }
  afterAutoSkip() {
    this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map((t) => +t.value));
  }
  initOffsets(t = []) {
    let n = 0, r = 0, i, s;
    this.options.offset && t.length && (i = this.getDecimalForValue(t[0]), t.length === 1 ? n = 1 - i : n = (this.getDecimalForValue(t[1]) - i) / 2, s = this.getDecimalForValue(t[t.length - 1]), t.length === 1 ? r = s : r = (s - this.getDecimalForValue(t[t.length - 2])) / 2);
    const a = t.length < 3 ? 0.5 : 0.25;
    n = nn(n, 0, a), r = nn(r, 0, a), this._offsets = {
      start: n,
      end: r,
      factor: 1 / (n + 1 + r)
    };
  }
  _generate() {
    const t = this._adapter, n = this.min, r = this.max, i = this.options, s = i.time, a = s.unit || Om(s.minUnit, n, r, this._getLabelCapacity(n)), o = Re(i.ticks.stepSize, 1), l = a === "week" ? s.isoWeekday : !1, c = Qa(l) || l === !0, u = {};
    let f = n, d, h;
    if (c && (f = +t.startOf(f, "isoWeek", l)), f = +t.startOf(f, c ? "day" : a), t.diff(r, n, a) > 1e5 * o)
      throw new Error(n + " and " + r + " are too far apart with stepSize of " + o + " " + a);
    const p = i.ticks.source === "data" && this.getDataTimestamps();
    for (d = f, h = 0; d < r; d = +t.add(d, o, a), h++)
      Mm(u, d, p);
    return (d === r || i.bounds === "ticks" || h === 1) && Mm(u, d, p), Object.keys(u).sort(Sm).map((g) => +g);
  }
  getLabelForValue(t) {
    const n = this._adapter, r = this.options.time;
    return r.tooltipFormat ? n.format(t, r.tooltipFormat) : n.format(t, r.displayFormats.datetime);
  }
  format(t, n) {
    const i = this.options.time.displayFormats, s = this._unit, a = n || i[s];
    return this._adapter.format(t, a);
  }
  _tickFormatFunction(t, n, r, i) {
    const s = this.options, a = s.ticks.callback;
    if (a)
      return ot(a, [
        t,
        n,
        r
      ], this);
    const o = s.time.displayFormats, l = this._unit, c = this._majorUnit, u = l && o[l], f = c && o[c], d = r[n], h = c && f && d && d.major;
    return this._adapter.format(t, i || (h ? f : u));
  }
  generateTickLabels(t) {
    let n, r, i;
    for (n = 0, r = t.length; n < r; ++n)
      i = t[n], i.label = this._tickFormatFunction(i.value, n, t);
  }
  getDecimalForValue(t) {
    return t === null ? NaN : (t - this.min) / (this.max - this.min);
  }
  getPixelForValue(t) {
    const n = this._offsets, r = this.getDecimalForValue(t);
    return this.getPixelForDecimal((n.start + r) * n.factor);
  }
  getValueForPixel(t) {
    const n = this._offsets, r = this.getDecimalForPixel(t) / n.factor - n.end;
    return this.min + r * (this.max - this.min);
  }
  _getLabelSize(t) {
    const n = this.options.ticks, r = this.ctx.measureText(t).width, i = Rn(this.isHorizontal() ? n.maxRotation : n.minRotation), s = Math.cos(i), a = Math.sin(i), o = this._resolveTickFontOptions(0).size;
    return {
      w: r * s + o * a,
      h: r * a + o * s
    };
  }
  _getLabelCapacity(t) {
    const n = this.options.time, r = n.displayFormats, i = r[n.unit] || r.millisecond, s = this._tickFormatFunction(t, 0, Fm(this, [
      t
    ], this._majorUnit), i), a = this._getLabelSize(s), o = Math.floor(this.isHorizontal() ? this.width / a.w : this.height / a.h) - 1;
    return o > 0 ? o : 1;
  }
  getDataTimestamps() {
    let t = this._cache.data || [], n, r;
    if (t.length)
      return t;
    const i = this.getMatchingVisibleMetas();
    if (this._normalized && i.length)
      return this._cache.data = i[0].controller.getAllParsedValues(this);
    for (n = 0, r = i.length; n < r; ++n)
      t = t.concat(i[n].controller.getAllParsedValues(this));
    return this._cache.data = this.normalize(t);
  }
  getLabelTimestamps() {
    const t = this._cache.labels || [];
    let n, r;
    if (t.length)
      return t;
    const i = this.getLabels();
    for (n = 0, r = i.length; n < r; ++n)
      t.push(Tm(this, i[n]));
    return this._cache.labels = this._normalized ? t : this.normalize(t);
  }
  normalize(t) {
    return L9(t.sort(Sm));
  }
}
V(Ac, "id", "time"), V(Ac, "defaults", {
  bounds: "data",
  adapters: {},
  time: {
    parser: !1,
    unit: !1,
    round: !1,
    isoWeekday: !1,
    minUnit: "millisecond",
    displayFormats: {}
  },
  ticks: {
    source: "auto",
    callback: !1,
    major: {
      enabled: !1
    }
  }
});
function ol(e, t, n) {
  let r = 0, i = e.length - 1, s, a, o, l;
  n ? (t >= e[r].pos && t <= e[i].pos && ({ lo: r, hi: i } = oi(e, "pos", t)), { pos: s, time: o } = e[r], { pos: a, time: l } = e[i]) : (t >= e[r].time && t <= e[i].time && ({ lo: r, hi: i } = oi(e, "time", t)), { time: s, pos: o } = e[r], { time: a, pos: l } = e[i]);
  const c = a - s;
  return c ? o + (l - o) * (t - s) / c : o;
}
class Pm extends Ac {
  constructor(t) {
    super(t), this._table = [], this._minPos = void 0, this._tableRange = void 0;
  }
  initOffsets() {
    const t = this._getTimestampsForTable(), n = this._table = this.buildLookupTable(t);
    this._minPos = ol(n, this.min), this._tableRange = ol(n, this.max) - this._minPos, super.initOffsets(t);
  }
  buildLookupTable(t) {
    const { min: n, max: r } = this, i = [], s = [];
    let a, o, l, c, u;
    for (a = 0, o = t.length; a < o; ++a)
      c = t[a], c >= n && c <= r && i.push(c);
    if (i.length < 2)
      return [
        {
          time: n,
          pos: 0
        },
        {
          time: r,
          pos: 1
        }
      ];
    for (a = 0, o = i.length; a < o; ++a)
      u = i[a + 1], l = i[a - 1], c = i[a], Math.round((u + l) / 2) !== c && s.push({
        time: c,
        pos: a / (o - 1)
      });
    return s;
  }
  _generate() {
    const t = this.min, n = this.max;
    let r = super.getDataTimestamps();
    return (!r.includes(t) || !r.length) && r.splice(0, 0, t), (!r.includes(n) || r.length === 1) && r.push(n), r.sort((i, s) => i - s);
  }
  _getTimestampsForTable() {
    let t = this._cache.all || [];
    if (t.length)
      return t;
    const n = this.getDataTimestamps(), r = this.getLabelTimestamps();
    return n.length && r.length ? t = this.normalize(n.concat(r)) : t = n.length ? n : r, t = this._cache.all = t, t;
  }
  getDecimalForValue(t) {
    return (ol(this._table, t) - this._minPos) / this._tableRange;
  }
  getValueForPixel(t) {
    const n = this._offsets, r = this.getDecimalForPixel(t) / n.factor - n.end;
    return ol(this._table, r * this._tableRange + this._minPos, !0);
  }
}
V(Pm, "id", "timeseries"), V(Pm, "defaults", Ac.defaults);
var r2 = typeof global == "object" && global && global.Object === Object && global, nV = typeof self == "object" && self && self.Object === Object && self, Un = r2 || nV || Function("return this")(), Nr = Un.Symbol, i2 = Object.prototype, rV = i2.hasOwnProperty, iV = i2.toString, la = Nr ? Nr.toStringTag : void 0;
function sV(e) {
  var t = rV.call(e, la), n = e[la];
  try {
    e[la] = void 0;
    var r = !0;
  } catch {
  }
  var i = iV.call(e);
  return r && (t ? e[la] = n : delete e[la]), i;
}
var aV = Object.prototype, oV = aV.toString;
function lV(e) {
  return oV.call(e);
}
var cV = "[object Null]", uV = "[object Undefined]", Im = Nr ? Nr.toStringTag : void 0;
function ko(e) {
  return e == null ? e === void 0 ? uV : cV : Im && Im in Object(e) ? sV(e) : lV(e);
}
function xi(e) {
  return e != null && typeof e == "object";
}
var Es = Array.isArray;
function Co(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var fV = "[object AsyncFunction]", dV = "[object Function]", hV = "[object GeneratorFunction]", pV = "[object Proxy]";
function s2(e) {
  if (!Co(e))
    return !1;
  var t = ko(e);
  return t == dV || t == hV || t == fV || t == pV;
}
var of = Un["__core-js_shared__"], Rm = function() {
  var e = /[^.]+$/.exec(of && of.keys && of.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
}();
function gV(e) {
  return !!Rm && Rm in e;
}
var vV = Function.prototype, mV = vV.toString;
function Ti(e) {
  if (e != null) {
    try {
      return mV.call(e);
    } catch {
    }
    try {
      return e + "";
    } catch {
    }
  }
  return "";
}
var yV = /[\\^$.*+?()[\]{}|]/g, xV = /^\[object .+?Constructor\]$/, bV = Function.prototype, _V = Object.prototype, wV = bV.toString, $V = _V.hasOwnProperty, EV = RegExp(
  "^" + wV.call($V).replace(yV, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function AV(e) {
  if (!Co(e) || gV(e))
    return !1;
  var t = s2(e) ? EV : xV;
  return t.test(Ti(e));
}
function kV(e, t) {
  return e == null ? void 0 : e[t];
}
function Oi(e, t) {
  var n = kV(e, t);
  return AV(n) ? n : void 0;
}
var Xd = Oi(Un, "WeakMap"), Bm = Object.create, CV = /* @__PURE__ */ function() {
  function e() {
  }
  return function(t) {
    if (!Co(t))
      return {};
    if (Bm)
      return Bm(t);
    e.prototype = t;
    var n = new e();
    return e.prototype = void 0, n;
  };
}();
function DV(e, t) {
  var n = -1, r = e.length;
  for (t || (t = Array(r)); ++n < r; )
    t[n] = e[n];
  return t;
}
var Nm = function() {
  try {
    var e = Oi(Object, "defineProperty");
    return e({}, "", {}), e;
  } catch {
  }
}();
function SV(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length; ++n < r && t(e[n], n, e) !== !1; )
    ;
  return e;
}
var TV = 9007199254740991, OV = /^(?:0|[1-9]\d*)$/;
function MV(e, t) {
  var n = typeof e;
  return t = t ?? TV, !!t && (n == "number" || n != "symbol" && OV.test(e)) && e > -1 && e % 1 == 0 && e < t;
}
function a2(e, t, n) {
  t == "__proto__" && Nm ? Nm(e, t, {
    configurable: !0,
    enumerable: !0,
    value: n,
    writable: !0
  }) : e[t] = n;
}
function Nh(e, t) {
  return e === t || e !== e && t !== t;
}
var FV = Object.prototype, PV = FV.hasOwnProperty;
function o2(e, t, n) {
  var r = e[t];
  (!(PV.call(e, t) && Nh(r, n)) || n === void 0 && !(t in e)) && a2(e, t, n);
}
function bu(e, t, n, r) {
  var i = !n;
  n || (n = {});
  for (var s = -1, a = t.length; ++s < a; ) {
    var o = t[s], l = r ? r(n[o], e[o], o, n, e) : void 0;
    l === void 0 && (l = e[o]), i ? a2(n, o, l) : o2(n, o, l);
  }
  return n;
}
var IV = 9007199254740991;
function l2(e) {
  return typeof e == "number" && e > -1 && e % 1 == 0 && e <= IV;
}
function Lh(e) {
  return e != null && l2(e.length) && !s2(e);
}
var RV = Object.prototype;
function _u(e) {
  var t = e && e.constructor, n = typeof t == "function" && t.prototype || RV;
  return e === n;
}
function BV(e, t) {
  for (var n = -1, r = Array(e); ++n < e; )
    r[n] = t(n);
  return r;
}
var NV = "[object Arguments]";
function Lm(e) {
  return xi(e) && ko(e) == NV;
}
var c2 = Object.prototype, LV = c2.hasOwnProperty, jV = c2.propertyIsEnumerable, zV = Lm(/* @__PURE__ */ function() {
  return arguments;
}()) ? Lm : function(e) {
  return xi(e) && LV.call(e, "callee") && !jV.call(e, "callee");
};
const u2 = zV;
function VV() {
  return !1;
}
var f2 = typeof exports == "object" && exports && !exports.nodeType && exports, jm = f2 && typeof module == "object" && module && !module.nodeType && module, HV = jm && jm.exports === f2, zm = HV ? Un.Buffer : void 0, WV = zm ? zm.isBuffer : void 0, UV = WV || VV;
const ro = UV;
var YV = "[object Arguments]", qV = "[object Array]", GV = "[object Boolean]", XV = "[object Date]", ZV = "[object Error]", KV = "[object Function]", JV = "[object Map]", QV = "[object Number]", eH = "[object Object]", tH = "[object RegExp]", nH = "[object Set]", rH = "[object String]", iH = "[object WeakMap]", sH = "[object ArrayBuffer]", aH = "[object DataView]", oH = "[object Float32Array]", lH = "[object Float64Array]", cH = "[object Int8Array]", uH = "[object Int16Array]", fH = "[object Int32Array]", dH = "[object Uint8Array]", hH = "[object Uint8ClampedArray]", pH = "[object Uint16Array]", gH = "[object Uint32Array]", Ge = {};
Ge[oH] = Ge[lH] = Ge[cH] = Ge[uH] = Ge[fH] = Ge[dH] = Ge[hH] = Ge[pH] = Ge[gH] = !0;
Ge[YV] = Ge[qV] = Ge[sH] = Ge[GV] = Ge[aH] = Ge[XV] = Ge[ZV] = Ge[KV] = Ge[JV] = Ge[QV] = Ge[eH] = Ge[tH] = Ge[nH] = Ge[rH] = Ge[iH] = !1;
function vH(e) {
  return xi(e) && l2(e.length) && !!Ge[ko(e)];
}
function jh(e) {
  return function(t) {
    return e(t);
  };
}
var d2 = typeof exports == "object" && exports && !exports.nodeType && exports, Ma = d2 && typeof module == "object" && module && !module.nodeType && module, mH = Ma && Ma.exports === d2, lf = mH && r2.process, As = function() {
  try {
    var e = Ma && Ma.require && Ma.require("util").types;
    return e || lf && lf.binding && lf.binding("util");
  } catch {
  }
}(), Vm = As && As.isTypedArray, yH = Vm ? jh(Vm) : vH;
const zh = yH;
var xH = Object.prototype, bH = xH.hasOwnProperty;
function h2(e, t) {
  var n = Es(e), r = !n && u2(e), i = !n && !r && ro(e), s = !n && !r && !i && zh(e), a = n || r || i || s, o = a ? BV(e.length, String) : [], l = o.length;
  for (var c in e)
    (t || bH.call(e, c)) && !(a && // Safari 9 has enumerable `arguments.length` in strict mode.
    (c == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    i && (c == "offset" || c == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    s && (c == "buffer" || c == "byteLength" || c == "byteOffset") || // Skip index properties.
    MV(c, l))) && o.push(c);
  return o;
}
function p2(e, t) {
  return function(n) {
    return e(t(n));
  };
}
var _H = p2(Object.keys, Object), wH = Object.prototype, $H = wH.hasOwnProperty;
function g2(e) {
  if (!_u(e))
    return _H(e);
  var t = [];
  for (var n in Object(e))
    $H.call(e, n) && n != "constructor" && t.push(n);
  return t;
}
function Vh(e) {
  return Lh(e) ? h2(e) : g2(e);
}
function EH(e) {
  var t = [];
  if (e != null)
    for (var n in Object(e))
      t.push(n);
  return t;
}
var AH = Object.prototype, kH = AH.hasOwnProperty;
function CH(e) {
  if (!Co(e))
    return EH(e);
  var t = _u(e), n = [];
  for (var r in e)
    r == "constructor" && (t || !kH.call(e, r)) || n.push(r);
  return n;
}
function Hh(e) {
  return Lh(e) ? h2(e, !0) : CH(e);
}
var io = Oi(Object, "create");
function DH() {
  this.__data__ = io ? io(null) : {}, this.size = 0;
}
function SH(e) {
  var t = this.has(e) && delete this.__data__[e];
  return this.size -= t ? 1 : 0, t;
}
var TH = "__lodash_hash_undefined__", OH = Object.prototype, MH = OH.hasOwnProperty;
function FH(e) {
  var t = this.__data__;
  if (io) {
    var n = t[e];
    return n === TH ? void 0 : n;
  }
  return MH.call(t, e) ? t[e] : void 0;
}
var PH = Object.prototype, IH = PH.hasOwnProperty;
function RH(e) {
  var t = this.__data__;
  return io ? t[e] !== void 0 : IH.call(t, e);
}
var BH = "__lodash_hash_undefined__";
function NH(e, t) {
  var n = this.__data__;
  return this.size += this.has(e) ? 0 : 1, n[e] = io && t === void 0 ? BH : t, this;
}
function bi(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
bi.prototype.clear = DH;
bi.prototype.delete = SH;
bi.prototype.get = FH;
bi.prototype.has = RH;
bi.prototype.set = NH;
function LH() {
  this.__data__ = [], this.size = 0;
}
function wu(e, t) {
  for (var n = e.length; n--; )
    if (Nh(e[n][0], t))
      return n;
  return -1;
}
var jH = Array.prototype, zH = jH.splice;
function VH(e) {
  var t = this.__data__, n = wu(t, e);
  if (n < 0)
    return !1;
  var r = t.length - 1;
  return n == r ? t.pop() : zH.call(t, n, 1), --this.size, !0;
}
function HH(e) {
  var t = this.__data__, n = wu(t, e);
  return n < 0 ? void 0 : t[n][1];
}
function WH(e) {
  return wu(this.__data__, e) > -1;
}
function UH(e, t) {
  var n = this.__data__, r = wu(n, e);
  return r < 0 ? (++this.size, n.push([e, t])) : n[r][1] = t, this;
}
function gr(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
gr.prototype.clear = LH;
gr.prototype.delete = VH;
gr.prototype.get = HH;
gr.prototype.has = WH;
gr.prototype.set = UH;
var so = Oi(Un, "Map");
function YH() {
  this.size = 0, this.__data__ = {
    hash: new bi(),
    map: new (so || gr)(),
    string: new bi()
  };
}
function qH(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
function $u(e, t) {
  var n = e.__data__;
  return qH(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map;
}
function GH(e) {
  var t = $u(this, e).delete(e);
  return this.size -= t ? 1 : 0, t;
}
function XH(e) {
  return $u(this, e).get(e);
}
function ZH(e) {
  return $u(this, e).has(e);
}
function KH(e, t) {
  var n = $u(this, e), r = n.size;
  return n.set(e, t), this.size += n.size == r ? 0 : 1, this;
}
function Mi(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
Mi.prototype.clear = YH;
Mi.prototype.delete = GH;
Mi.prototype.get = XH;
Mi.prototype.has = ZH;
Mi.prototype.set = KH;
function v2(e, t) {
  for (var n = -1, r = t.length, i = e.length; ++n < r; )
    e[i + n] = t[n];
  return e;
}
var JH = p2(Object.getPrototypeOf, Object);
const m2 = JH;
function QH() {
  this.__data__ = new gr(), this.size = 0;
}
function eW(e) {
  var t = this.__data__, n = t.delete(e);
  return this.size = t.size, n;
}
function tW(e) {
  return this.__data__.get(e);
}
function nW(e) {
  return this.__data__.has(e);
}
var rW = 200;
function iW(e, t) {
  var n = this.__data__;
  if (n instanceof gr) {
    var r = n.__data__;
    if (!so || r.length < rW - 1)
      return r.push([e, t]), this.size = ++n.size, this;
    n = this.__data__ = new Mi(r);
  }
  return n.set(e, t), this.size = n.size, this;
}
function rr(e) {
  var t = this.__data__ = new gr(e);
  this.size = t.size;
}
rr.prototype.clear = QH;
rr.prototype.delete = eW;
rr.prototype.get = tW;
rr.prototype.has = nW;
rr.prototype.set = iW;
function sW(e, t) {
  return e && bu(t, Vh(t), e);
}
function aW(e, t) {
  return e && bu(t, Hh(t), e);
}
var y2 = typeof exports == "object" && exports && !exports.nodeType && exports, Hm = y2 && typeof module == "object" && module && !module.nodeType && module, oW = Hm && Hm.exports === y2, Wm = oW ? Un.Buffer : void 0, Um = Wm ? Wm.allocUnsafe : void 0;
function lW(e, t) {
  if (t)
    return e.slice();
  var n = e.length, r = Um ? Um(n) : new e.constructor(n);
  return e.copy(r), r;
}
function cW(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length, i = 0, s = []; ++n < r; ) {
    var a = e[n];
    t(a, n, e) && (s[i++] = a);
  }
  return s;
}
function x2() {
  return [];
}
var uW = Object.prototype, fW = uW.propertyIsEnumerable, Ym = Object.getOwnPropertySymbols, Wh = Ym ? function(e) {
  return e == null ? [] : (e = Object(e), cW(Ym(e), function(t) {
    return fW.call(e, t);
  }));
} : x2;
function dW(e, t) {
  return bu(e, Wh(e), t);
}
var hW = Object.getOwnPropertySymbols, b2 = hW ? function(e) {
  for (var t = []; e; )
    v2(t, Wh(e)), e = m2(e);
  return t;
} : x2;
function pW(e, t) {
  return bu(e, b2(e), t);
}
function _2(e, t, n) {
  var r = t(e);
  return Es(e) ? r : v2(r, n(e));
}
function Zd(e) {
  return _2(e, Vh, Wh);
}
function gW(e) {
  return _2(e, Hh, b2);
}
var Kd = Oi(Un, "DataView"), Jd = Oi(Un, "Promise"), Qd = Oi(Un, "Set"), qm = "[object Map]", vW = "[object Object]", Gm = "[object Promise]", Xm = "[object Set]", Zm = "[object WeakMap]", Km = "[object DataView]", mW = Ti(Kd), yW = Ti(so), xW = Ti(Jd), bW = Ti(Qd), _W = Ti(Xd), ni = ko;
(Kd && ni(new Kd(new ArrayBuffer(1))) != Km || so && ni(new so()) != qm || Jd && ni(Jd.resolve()) != Gm || Qd && ni(new Qd()) != Xm || Xd && ni(new Xd()) != Zm) && (ni = function(e) {
  var t = ko(e), n = t == vW ? e.constructor : void 0, r = n ? Ti(n) : "";
  if (r)
    switch (r) {
      case mW:
        return Km;
      case yW:
        return qm;
      case xW:
        return Gm;
      case bW:
        return Xm;
      case _W:
        return Zm;
    }
  return t;
});
const ks = ni;
var wW = Object.prototype, $W = wW.hasOwnProperty;
function EW(e) {
  var t = e.length, n = new e.constructor(t);
  return t && typeof e[0] == "string" && $W.call(e, "index") && (n.index = e.index, n.input = e.input), n;
}
var kc = Un.Uint8Array;
function Uh(e) {
  var t = new e.constructor(e.byteLength);
  return new kc(t).set(new kc(e)), t;
}
function AW(e, t) {
  var n = t ? Uh(e.buffer) : e.buffer;
  return new e.constructor(n, e.byteOffset, e.byteLength);
}
var kW = /\w*$/;
function CW(e) {
  var t = new e.constructor(e.source, kW.exec(e));
  return t.lastIndex = e.lastIndex, t;
}
var Jm = Nr ? Nr.prototype : void 0, Qm = Jm ? Jm.valueOf : void 0;
function DW(e) {
  return Qm ? Object(Qm.call(e)) : {};
}
function SW(e, t) {
  var n = t ? Uh(e.buffer) : e.buffer;
  return new e.constructor(n, e.byteOffset, e.length);
}
var TW = "[object Boolean]", OW = "[object Date]", MW = "[object Map]", FW = "[object Number]", PW = "[object RegExp]", IW = "[object Set]", RW = "[object String]", BW = "[object Symbol]", NW = "[object ArrayBuffer]", LW = "[object DataView]", jW = "[object Float32Array]", zW = "[object Float64Array]", VW = "[object Int8Array]", HW = "[object Int16Array]", WW = "[object Int32Array]", UW = "[object Uint8Array]", YW = "[object Uint8ClampedArray]", qW = "[object Uint16Array]", GW = "[object Uint32Array]";
function XW(e, t, n) {
  var r = e.constructor;
  switch (t) {
    case NW:
      return Uh(e);
    case TW:
    case OW:
      return new r(+e);
    case LW:
      return AW(e, n);
    case jW:
    case zW:
    case VW:
    case HW:
    case WW:
    case UW:
    case YW:
    case qW:
    case GW:
      return SW(e, n);
    case MW:
      return new r();
    case FW:
    case RW:
      return new r(e);
    case PW:
      return CW(e);
    case IW:
      return new r();
    case BW:
      return DW(e);
  }
}
function ZW(e) {
  return typeof e.constructor == "function" && !_u(e) ? CV(m2(e)) : {};
}
var KW = "[object Map]";
function JW(e) {
  return xi(e) && ks(e) == KW;
}
var ey = As && As.isMap, QW = ey ? jh(ey) : JW, eU = "[object Set]";
function tU(e) {
  return xi(e) && ks(e) == eU;
}
var ty = As && As.isSet, nU = ty ? jh(ty) : tU, rU = 1, iU = 2, sU = 4, w2 = "[object Arguments]", aU = "[object Array]", oU = "[object Boolean]", lU = "[object Date]", cU = "[object Error]", $2 = "[object Function]", uU = "[object GeneratorFunction]", fU = "[object Map]", dU = "[object Number]", E2 = "[object Object]", hU = "[object RegExp]", pU = "[object Set]", gU = "[object String]", vU = "[object Symbol]", mU = "[object WeakMap]", yU = "[object ArrayBuffer]", xU = "[object DataView]", bU = "[object Float32Array]", _U = "[object Float64Array]", wU = "[object Int8Array]", $U = "[object Int16Array]", EU = "[object Int32Array]", AU = "[object Uint8Array]", kU = "[object Uint8ClampedArray]", CU = "[object Uint16Array]", DU = "[object Uint32Array]", Ue = {};
Ue[w2] = Ue[aU] = Ue[yU] = Ue[xU] = Ue[oU] = Ue[lU] = Ue[bU] = Ue[_U] = Ue[wU] = Ue[$U] = Ue[EU] = Ue[fU] = Ue[dU] = Ue[E2] = Ue[hU] = Ue[pU] = Ue[gU] = Ue[vU] = Ue[AU] = Ue[kU] = Ue[CU] = Ue[DU] = !0;
Ue[cU] = Ue[$2] = Ue[mU] = !1;
function Rl(e, t, n, r, i, s) {
  var a, o = t & rU, l = t & iU, c = t & sU;
  if (n && (a = i ? n(e, r, i, s) : n(e)), a !== void 0)
    return a;
  if (!Co(e))
    return e;
  var u = Es(e);
  if (u) {
    if (a = EW(e), !o)
      return DV(e, a);
  } else {
    var f = ks(e), d = f == $2 || f == uU;
    if (ro(e))
      return lW(e, o);
    if (f == E2 || f == w2 || d && !i) {
      if (a = l || d ? {} : ZW(e), !o)
        return l ? pW(e, aW(a, e)) : dW(e, sW(a, e));
    } else {
      if (!Ue[f])
        return i ? e : {};
      a = XW(e, f, o);
    }
  }
  s || (s = new rr());
  var h = s.get(e);
  if (h)
    return h;
  s.set(e, a), nU(e) ? e.forEach(function(v) {
    a.add(Rl(v, t, n, v, e, s));
  }) : QW(e) && e.forEach(function(v, m) {
    a.set(m, Rl(v, t, n, m, e, s));
  });
  var p = c ? l ? gW : Zd : l ? Hh : Vh, g = u ? void 0 : p(e);
  return SV(g || e, function(v, m) {
    g && (m = v, v = e[m]), o2(a, m, Rl(v, t, n, m, e, s));
  }), a;
}
var SU = 1, TU = 4;
function ca(e) {
  return Rl(e, SU | TU);
}
var OU = "__lodash_hash_undefined__";
function MU(e) {
  return this.__data__.set(e, OU), this;
}
function FU(e) {
  return this.__data__.has(e);
}
function Cc(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.__data__ = new Mi(); ++t < n; )
    this.add(e[t]);
}
Cc.prototype.add = Cc.prototype.push = MU;
Cc.prototype.has = FU;
function PU(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length; ++n < r; )
    if (t(e[n], n, e))
      return !0;
  return !1;
}
function IU(e, t) {
  return e.has(t);
}
var RU = 1, BU = 2;
function A2(e, t, n, r, i, s) {
  var a = n & RU, o = e.length, l = t.length;
  if (o != l && !(a && l > o))
    return !1;
  var c = s.get(e), u = s.get(t);
  if (c && u)
    return c == t && u == e;
  var f = -1, d = !0, h = n & BU ? new Cc() : void 0;
  for (s.set(e, t), s.set(t, e); ++f < o; ) {
    var p = e[f], g = t[f];
    if (r)
      var v = a ? r(g, p, f, t, e, s) : r(p, g, f, e, t, s);
    if (v !== void 0) {
      if (v)
        continue;
      d = !1;
      break;
    }
    if (h) {
      if (!PU(t, function(m, x) {
        if (!IU(h, x) && (p === m || i(p, m, n, r, s)))
          return h.push(x);
      })) {
        d = !1;
        break;
      }
    } else if (!(p === g || i(p, g, n, r, s))) {
      d = !1;
      break;
    }
  }
  return s.delete(e), s.delete(t), d;
}
function NU(e) {
  var t = -1, n = Array(e.size);
  return e.forEach(function(r, i) {
    n[++t] = [i, r];
  }), n;
}
function LU(e) {
  var t = -1, n = Array(e.size);
  return e.forEach(function(r) {
    n[++t] = r;
  }), n;
}
var jU = 1, zU = 2, VU = "[object Boolean]", HU = "[object Date]", WU = "[object Error]", UU = "[object Map]", YU = "[object Number]", qU = "[object RegExp]", GU = "[object Set]", XU = "[object String]", ZU = "[object Symbol]", KU = "[object ArrayBuffer]", JU = "[object DataView]", ny = Nr ? Nr.prototype : void 0, cf = ny ? ny.valueOf : void 0;
function QU(e, t, n, r, i, s, a) {
  switch (n) {
    case JU:
      if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
        return !1;
      e = e.buffer, t = t.buffer;
    case KU:
      return !(e.byteLength != t.byteLength || !s(new kc(e), new kc(t)));
    case VU:
    case HU:
    case YU:
      return Nh(+e, +t);
    case WU:
      return e.name == t.name && e.message == t.message;
    case qU:
    case XU:
      return e == t + "";
    case UU:
      var o = NU;
    case GU:
      var l = r & jU;
      if (o || (o = LU), e.size != t.size && !l)
        return !1;
      var c = a.get(e);
      if (c)
        return c == t;
      r |= zU, a.set(e, t);
      var u = A2(o(e), o(t), r, i, s, a);
      return a.delete(e), u;
    case ZU:
      if (cf)
        return cf.call(e) == cf.call(t);
  }
  return !1;
}
var eY = 1, tY = Object.prototype, nY = tY.hasOwnProperty;
function rY(e, t, n, r, i, s) {
  var a = n & eY, o = Zd(e), l = o.length, c = Zd(t), u = c.length;
  if (l != u && !a)
    return !1;
  for (var f = l; f--; ) {
    var d = o[f];
    if (!(a ? d in t : nY.call(t, d)))
      return !1;
  }
  var h = s.get(e), p = s.get(t);
  if (h && p)
    return h == t && p == e;
  var g = !0;
  s.set(e, t), s.set(t, e);
  for (var v = a; ++f < l; ) {
    d = o[f];
    var m = e[d], x = t[d];
    if (r)
      var _ = a ? r(x, m, d, t, e, s) : r(m, x, d, e, t, s);
    if (!(_ === void 0 ? m === x || i(m, x, n, r, s) : _)) {
      g = !1;
      break;
    }
    v || (v = d == "constructor");
  }
  if (g && !v) {
    var y = e.constructor, b = t.constructor;
    y != b && "constructor" in e && "constructor" in t && !(typeof y == "function" && y instanceof y && typeof b == "function" && b instanceof b) && (g = !1);
  }
  return s.delete(e), s.delete(t), g;
}
var iY = 1, ry = "[object Arguments]", iy = "[object Array]", ll = "[object Object]", sY = Object.prototype, sy = sY.hasOwnProperty;
function aY(e, t, n, r, i, s) {
  var a = Es(e), o = Es(t), l = a ? iy : ks(e), c = o ? iy : ks(t);
  l = l == ry ? ll : l, c = c == ry ? ll : c;
  var u = l == ll, f = c == ll, d = l == c;
  if (d && ro(e)) {
    if (!ro(t))
      return !1;
    a = !0, u = !1;
  }
  if (d && !u)
    return s || (s = new rr()), a || zh(e) ? A2(e, t, n, r, i, s) : QU(e, t, l, n, r, i, s);
  if (!(n & iY)) {
    var h = u && sy.call(e, "__wrapped__"), p = f && sy.call(t, "__wrapped__");
    if (h || p) {
      var g = h ? e.value() : e, v = p ? t.value() : t;
      return s || (s = new rr()), i(g, v, n, r, s);
    }
  }
  return d ? (s || (s = new rr()), rY(e, t, n, r, i, s)) : !1;
}
function k2(e, t, n, r, i) {
  return e === t ? !0 : e == null || t == null || !xi(e) && !xi(t) ? e !== e && t !== t : aY(e, t, n, r, k2, i);
}
var oY = "[object Map]", lY = "[object Set]", cY = Object.prototype, uY = cY.hasOwnProperty;
function fY(e) {
  if (e == null)
    return !0;
  if (Lh(e) && (Es(e) || typeof e == "string" || typeof e.splice == "function" || ro(e) || zh(e) || u2(e)))
    return !e.length;
  var t = ks(e);
  if (t == oY || t == lY)
    return !e.size;
  if (_u(e))
    return !g2(e).length;
  for (var n in e)
    if (uY.call(e, n))
      return !1;
  return !0;
}
function ay(e, t) {
  return k2(e, t);
}
var dY = Object.defineProperty, hY = Object.defineProperties, pY = Object.getOwnPropertyDescriptors, oy = Object.getOwnPropertySymbols, gY = Object.prototype.hasOwnProperty, vY = Object.prototype.propertyIsEnumerable, ly = (e, t, n) => t in e ? dY(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, mY = (e, t) => {
  for (var n in t || (t = {}))
    gY.call(t, n) && ly(e, n, t[n]);
  if (oy)
    for (var n of oy(t))
      vY.call(t, n) && ly(e, n, t[n]);
  return e;
}, yY = (e, t) => hY(e, pY(t));
function xY(e) {
  return (e.match(/[a-zA-Z0-9]+/g) || []).map((t) => `${t.charAt(0).toUpperCase()}${t.slice(1)}`).join("");
}
var zr = (e, t) => {
  const n = {
    chartData: { type: Object, required: !0 },
    options: { type: Object, required: !1 },
    chartId: { default: e, type: String },
    width: { default: 400, type: Number },
    height: { default: 400, type: Number },
    cssClasses: { type: String, default: "" },
    styles: { type: Object },
    plugins: { type: Array, default: () => [] },
    onLabelsUpdate: { type: Function },
    onChartUpdate: { type: Function },
    onChartDestroy: { type: Function },
    onChartRender: { type: Function }
  }, r = xY(e);
  return be({
    name: r,
    props: n,
    emits: {
      "labels:update": () => !0,
      "chart:update": (i) => !0,
      "chart:destroy": () => !0,
      "chart:render": (i) => !0
    },
    setup(i, { emit: s, expose: a }) {
      const o = oe(null), l = `${i.chartId}`;
      let c = gi(null);
      fe(() => i.chartData, u, { deep: !0 }), fe(() => i.options, (v) => {
        c.value && v && (c.value.options = ca(v), p());
      }, { deep: !0 });
      function u(v) {
        if (c.value) {
          let m = c.value;
          ay(v.labels, c.value.data.labels) || (m.data.labels = v.labels, d()), ay(v.datasets, c.value.data.datasets) || v.datasets.forEach((x, _) => {
            var y, b;
            if (fY(x))
              m.data.datasets = [];
            else {
              const w = ca(m.data), E = Object.keys((b = (y = w.datasets) == null ? void 0 : y[_]) != null ? b : {}), $ = Object.keys(x);
              E.filter((A) => A !== "_meta" && $.indexOf(A) === -1).forEach((A) => {
                m.data.datasets[_] && delete m.data.datasets[_][A];
              });
              for (const A in x) {
                const k = ca(x[A]);
                m.data.datasets[_] || (m.data.datasets[_] = {}), x.hasOwnProperty(A) && k != null && m && (m.data.datasets[_][A] = k);
              }
            }
          }), p();
        } else
          c.value && g(), f();
      }
      function f() {
        o.value ? (c.value = new Kn(o.value, {
          data: ca(i.chartData),
          type: t,
          options: ca(i.options),
          plugins: i.plugins
        }), h()) : console.error(`Error on component ${r}, canvas cannot be rendered. Check if the render appends server-side`);
      }
      function d() {
        s("labels:update"), i.onLabelsUpdate && i.onLabelsUpdate();
      }
      function h() {
        c.value && (s("chart:render", c.value), i.onChartRender && i.onChartRender(c.value));
      }
      function p() {
        c.value && (c.value.update(), s("chart:update", c.value), i.onChartUpdate && i.onChartUpdate(c.value));
      }
      function g() {
        c.value && c.value.destroy(), s("chart:destroy"), i.onChartDestroy && i.onChartDestroy();
      }
      return ct(f), Kc(() => {
        c.value && c.value.destroy();
      }), a({
        canvasRef: o,
        renderChart: f,
        chartInstance: c,
        canvasId: l,
        update: p
      }), () => er("div", {
        style: yY(mY({
          maxWidth: "100%"
        }, i.styles), {
          position: "relative"
        }),
        class: i.cssClasses
      }, [
        er("canvas", {
          style: {
            maxWidth: "100%",
            maxHeight: "100%"
          },
          id: l,
          width: i.width,
          height: i.height,
          ref: o
        })
      ]);
    }
  });
};
zr("bar-chart", "bar");
var bY = zr("doughnut-chart", "doughnut"), _Y = zr("line-chart", "line"), wY = zr("pie-chart", "pie");
zr("polar-chart", "polarArea");
zr("radar-chart", "radar");
zr("bubble-chart", "bubble");
zr("scatter-chart", "scatter");
const $Y = /* @__PURE__ */ be({
  __name: "doughnut",
  props: {
    items: {
      required: !0,
      type: Array
    },
    width: {
      type: Number,
      default: 600
    },
    height: {
      type: Number,
      default: 300
    }
  },
  setup(e) {
    const t = e, n = Oe({
      labels: t.items.map((i) => i.label()),
      datasets: [
        {
          backgroundColor: [
            "#FF595E",
            "#36949D",
            "#FF924C",
            "#1982C4",
            "#FFCA3A",
            "#4267AC",
            "#C5CA30",
            "#565AA0",
            "#8AC926",
            "#6A4C93",
            "#001219",
            "#EE9B00",
            "#CA6702",
            "#0A9396",
            "#BB3E03",
            "#94D2BD",
            "#AE2012",
            "#E9D8A6",
            "#9B2226"
          ],
          data: t.items.map((i) => i.value)
        }
      ]
    }), r = Oe({
      responsive: !0,
      maintainAspectRatio: !1,
      plugins: {
        tooltip: {
          enabled: !1
        },
        legend: {
          position: "right",
          labels: {
            padding: 20
          }
        }
      }
    });
    return (i, s) => (j(), ke(X(bY), {
      "chart-options": r,
      "chart-data": n,
      width: e.width,
      height: e.height
    }, null, 8, ["chart-options", "chart-data", "width", "height"]));
  }
}), EY = /* @__PURE__ */ be({
  __name: "line",
  props: {
    labels: {
      required: !0,
      type: Array
    },
    items: {
      required: !0,
      type: Array
    },
    width: {
      type: Number,
      default: 600
    },
    height: {
      type: Number,
      default: 300
    }
  },
  setup(e) {
    const t = e, n = Oe({
      labels: t.labels,
      datasets: t.items.map((i) => ({
        label: i.label(),
        backgroundColor: i.color || void 0,
        borderColor: i.color || void 0,
        data: i.values
      }))
    }), r = Oe({
      responsive: !0,
      maintainAspectRatio: !1,
      plugins: {
        tooltip: {
          enabled: !1
        },
        legend: {
          position: "right",
          labels: {
            padding: 20
          }
        }
      }
    });
    return (i, s) => (j(), ke(X(_Y), {
      "chart-options": r,
      "chart-data": n,
      width: e.width,
      height: e.height
    }, null, 8, ["chart-options", "chart-data", "width", "height"]));
  }
}), AY = /* @__PURE__ */ be({
  __name: "pie",
  props: {
    items: {
      required: !0,
      type: Array
    },
    colors: {
      required: !1,
      type: Array,
      default: null
    },
    width: {
      type: Number,
      default: 600
    },
    height: {
      type: Number,
      default: 300
    }
  },
  setup(e) {
    const t = e, n = Oe({
      labels: t.items.map((i) => i.label()),
      datasets: [
        {
          backgroundColor: t.colors ? t.colors : [
            "#FF595E",
            "#36949D",
            "#FF924C",
            "#1982C4",
            "#FFCA3A",
            "#4267AC",
            "#C5CA30",
            "#565AA0",
            "#8AC926",
            "#6A4C93",
            "#001219",
            "#EE9B00",
            "#CA6702",
            "#0A9396",
            "#BB3E03",
            "#94D2BD",
            "#AE2012",
            "#E9D8A6",
            "#9B2226"
          ],
          data: t.items.map((i) => i.value)
        }
      ]
    }), r = Oe({
      responsive: !0,
      maintainAspectRatio: !1,
      plugins: {
        tooltip: {
          enabled: !1
        },
        legend: {
          position: "right",
          labels: {
            padding: 20
          }
        }
      }
    });
    return (i, s) => (j(), ke(X(wY), {
      "chart-options": r,
      "chart-data": n,
      width: e.width,
      height: e.height
    }, null, 8, ["chart-options", "chart-data", "width", "height"]));
  }
});
var ye = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Vr(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function kY(e) {
  if (e.__esModule)
    return e;
  var t = e.default;
  if (typeof t == "function") {
    var n = function r() {
      return this instanceof r ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    n.prototype = t.prototype;
  } else
    n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(e).forEach(function(r) {
    var i = Object.getOwnPropertyDescriptor(e, r);
    Object.defineProperty(n, r, i.get ? i : {
      enumerable: !0,
      get: function() {
        return e[r];
      }
    });
  }), n;
}
var e0 = { exports: {} }, it = {}, t0 = { exports: {} }, Fi = {};
function C2() {
  var e = {};
  return e["align-content"] = !1, e["align-items"] = !1, e["align-self"] = !1, e["alignment-adjust"] = !1, e["alignment-baseline"] = !1, e.all = !1, e["anchor-point"] = !1, e.animation = !1, e["animation-delay"] = !1, e["animation-direction"] = !1, e["animation-duration"] = !1, e["animation-fill-mode"] = !1, e["animation-iteration-count"] = !1, e["animation-name"] = !1, e["animation-play-state"] = !1, e["animation-timing-function"] = !1, e.azimuth = !1, e["backface-visibility"] = !1, e.background = !0, e["background-attachment"] = !0, e["background-clip"] = !0, e["background-color"] = !0, e["background-image"] = !0, e["background-origin"] = !0, e["background-position"] = !0, e["background-repeat"] = !0, e["background-size"] = !0, e["baseline-shift"] = !1, e.binding = !1, e.bleed = !1, e["bookmark-label"] = !1, e["bookmark-level"] = !1, e["bookmark-state"] = !1, e.border = !0, e["border-bottom"] = !0, e["border-bottom-color"] = !0, e["border-bottom-left-radius"] = !0, e["border-bottom-right-radius"] = !0, e["border-bottom-style"] = !0, e["border-bottom-width"] = !0, e["border-collapse"] = !0, e["border-color"] = !0, e["border-image"] = !0, e["border-image-outset"] = !0, e["border-image-repeat"] = !0, e["border-image-slice"] = !0, e["border-image-source"] = !0, e["border-image-width"] = !0, e["border-left"] = !0, e["border-left-color"] = !0, e["border-left-style"] = !0, e["border-left-width"] = !0, e["border-radius"] = !0, e["border-right"] = !0, e["border-right-color"] = !0, e["border-right-style"] = !0, e["border-right-width"] = !0, e["border-spacing"] = !0, e["border-style"] = !0, e["border-top"] = !0, e["border-top-color"] = !0, e["border-top-left-radius"] = !0, e["border-top-right-radius"] = !0, e["border-top-style"] = !0, e["border-top-width"] = !0, e["border-width"] = !0, e.bottom = !1, e["box-decoration-break"] = !0, e["box-shadow"] = !0, e["box-sizing"] = !0, e["box-snap"] = !0, e["box-suppress"] = !0, e["break-after"] = !0, e["break-before"] = !0, e["break-inside"] = !0, e["caption-side"] = !1, e.chains = !1, e.clear = !0, e.clip = !1, e["clip-path"] = !1, e["clip-rule"] = !1, e.color = !0, e["color-interpolation-filters"] = !0, e["column-count"] = !1, e["column-fill"] = !1, e["column-gap"] = !1, e["column-rule"] = !1, e["column-rule-color"] = !1, e["column-rule-style"] = !1, e["column-rule-width"] = !1, e["column-span"] = !1, e["column-width"] = !1, e.columns = !1, e.contain = !1, e.content = !1, e["counter-increment"] = !1, e["counter-reset"] = !1, e["counter-set"] = !1, e.crop = !1, e.cue = !1, e["cue-after"] = !1, e["cue-before"] = !1, e.cursor = !1, e.direction = !1, e.display = !0, e["display-inside"] = !0, e["display-list"] = !0, e["display-outside"] = !0, e["dominant-baseline"] = !1, e.elevation = !1, e["empty-cells"] = !1, e.filter = !1, e.flex = !1, e["flex-basis"] = !1, e["flex-direction"] = !1, e["flex-flow"] = !1, e["flex-grow"] = !1, e["flex-shrink"] = !1, e["flex-wrap"] = !1, e.float = !1, e["float-offset"] = !1, e["flood-color"] = !1, e["flood-opacity"] = !1, e["flow-from"] = !1, e["flow-into"] = !1, e.font = !0, e["font-family"] = !0, e["font-feature-settings"] = !0, e["font-kerning"] = !0, e["font-language-override"] = !0, e["font-size"] = !0, e["font-size-adjust"] = !0, e["font-stretch"] = !0, e["font-style"] = !0, e["font-synthesis"] = !0, e["font-variant"] = !0, e["font-variant-alternates"] = !0, e["font-variant-caps"] = !0, e["font-variant-east-asian"] = !0, e["font-variant-ligatures"] = !0, e["font-variant-numeric"] = !0, e["font-variant-position"] = !0, e["font-weight"] = !0, e.grid = !1, e["grid-area"] = !1, e["grid-auto-columns"] = !1, e["grid-auto-flow"] = !1, e["grid-auto-rows"] = !1, e["grid-column"] = !1, e["grid-column-end"] = !1, e["grid-column-start"] = !1, e["grid-row"] = !1, e["grid-row-end"] = !1, e["grid-row-start"] = !1, e["grid-template"] = !1, e["grid-template-areas"] = !1, e["grid-template-columns"] = !1, e["grid-template-rows"] = !1, e["hanging-punctuation"] = !1, e.height = !0, e.hyphens = !1, e.icon = !1, e["image-orientation"] = !1, e["image-resolution"] = !1, e["ime-mode"] = !1, e["initial-letters"] = !1, e["inline-box-align"] = !1, e["justify-content"] = !1, e["justify-items"] = !1, e["justify-self"] = !1, e.left = !1, e["letter-spacing"] = !0, e["lighting-color"] = !0, e["line-box-contain"] = !1, e["line-break"] = !1, e["line-grid"] = !1, e["line-height"] = !1, e["line-snap"] = !1, e["line-stacking"] = !1, e["line-stacking-ruby"] = !1, e["line-stacking-shift"] = !1, e["line-stacking-strategy"] = !1, e["list-style"] = !0, e["list-style-image"] = !0, e["list-style-position"] = !0, e["list-style-type"] = !0, e.margin = !0, e["margin-bottom"] = !0, e["margin-left"] = !0, e["margin-right"] = !0, e["margin-top"] = !0, e["marker-offset"] = !1, e["marker-side"] = !1, e.marks = !1, e.mask = !1, e["mask-box"] = !1, e["mask-box-outset"] = !1, e["mask-box-repeat"] = !1, e["mask-box-slice"] = !1, e["mask-box-source"] = !1, e["mask-box-width"] = !1, e["mask-clip"] = !1, e["mask-image"] = !1, e["mask-origin"] = !1, e["mask-position"] = !1, e["mask-repeat"] = !1, e["mask-size"] = !1, e["mask-source-type"] = !1, e["mask-type"] = !1, e["max-height"] = !0, e["max-lines"] = !1, e["max-width"] = !0, e["min-height"] = !0, e["min-width"] = !0, e["move-to"] = !1, e["nav-down"] = !1, e["nav-index"] = !1, e["nav-left"] = !1, e["nav-right"] = !1, e["nav-up"] = !1, e["object-fit"] = !1, e["object-position"] = !1, e.opacity = !1, e.order = !1, e.orphans = !1, e.outline = !1, e["outline-color"] = !1, e["outline-offset"] = !1, e["outline-style"] = !1, e["outline-width"] = !1, e.overflow = !1, e["overflow-wrap"] = !1, e["overflow-x"] = !1, e["overflow-y"] = !1, e.padding = !0, e["padding-bottom"] = !0, e["padding-left"] = !0, e["padding-right"] = !0, e["padding-top"] = !0, e.page = !1, e["page-break-after"] = !1, e["page-break-before"] = !1, e["page-break-inside"] = !1, e["page-policy"] = !1, e.pause = !1, e["pause-after"] = !1, e["pause-before"] = !1, e.perspective = !1, e["perspective-origin"] = !1, e.pitch = !1, e["pitch-range"] = !1, e["play-during"] = !1, e.position = !1, e["presentation-level"] = !1, e.quotes = !1, e["region-fragment"] = !1, e.resize = !1, e.rest = !1, e["rest-after"] = !1, e["rest-before"] = !1, e.richness = !1, e.right = !1, e.rotation = !1, e["rotation-point"] = !1, e["ruby-align"] = !1, e["ruby-merge"] = !1, e["ruby-position"] = !1, e["shape-image-threshold"] = !1, e["shape-outside"] = !1, e["shape-margin"] = !1, e.size = !1, e.speak = !1, e["speak-as"] = !1, e["speak-header"] = !1, e["speak-numeral"] = !1, e["speak-punctuation"] = !1, e["speech-rate"] = !1, e.stress = !1, e["string-set"] = !1, e["tab-size"] = !1, e["table-layout"] = !1, e["text-align"] = !0, e["text-align-last"] = !0, e["text-combine-upright"] = !0, e["text-decoration"] = !0, e["text-decoration-color"] = !0, e["text-decoration-line"] = !0, e["text-decoration-skip"] = !0, e["text-decoration-style"] = !0, e["text-emphasis"] = !0, e["text-emphasis-color"] = !0, e["text-emphasis-position"] = !0, e["text-emphasis-style"] = !0, e["text-height"] = !0, e["text-indent"] = !0, e["text-justify"] = !0, e["text-orientation"] = !0, e["text-overflow"] = !0, e["text-shadow"] = !0, e["text-space-collapse"] = !0, e["text-transform"] = !0, e["text-underline-position"] = !0, e["text-wrap"] = !0, e.top = !1, e.transform = !1, e["transform-origin"] = !1, e["transform-style"] = !1, e.transition = !1, e["transition-delay"] = !1, e["transition-duration"] = !1, e["transition-property"] = !1, e["transition-timing-function"] = !1, e["unicode-bidi"] = !1, e["vertical-align"] = !1, e.visibility = !1, e["voice-balance"] = !1, e["voice-duration"] = !1, e["voice-family"] = !1, e["voice-pitch"] = !1, e["voice-range"] = !1, e["voice-rate"] = !1, e["voice-stress"] = !1, e["voice-volume"] = !1, e.volume = !1, e["white-space"] = !1, e.widows = !1, e.width = !0, e["will-change"] = !1, e["word-break"] = !0, e["word-spacing"] = !0, e["word-wrap"] = !0, e["wrap-flow"] = !1, e["wrap-through"] = !1, e["writing-mode"] = !1, e["z-index"] = !1, e;
}
function CY(e, t, n) {
}
function DY(e, t, n) {
}
var SY = /javascript\s*\:/img;
function TY(e, t) {
  return SY.test(t) ? "" : t;
}
Fi.whiteList = C2();
Fi.getDefaultWhiteList = C2;
Fi.onAttr = CY;
Fi.onIgnoreAttr = DY;
Fi.safeAttrValue = TY;
var OY = {
  indexOf: function(e, t) {
    var n, r;
    if (Array.prototype.indexOf)
      return e.indexOf(t);
    for (n = 0, r = e.length; n < r; n++)
      if (e[n] === t)
        return n;
    return -1;
  },
  forEach: function(e, t, n) {
    var r, i;
    if (Array.prototype.forEach)
      return e.forEach(t, n);
    for (r = 0, i = e.length; r < i; r++)
      t.call(n, e[r], r, e);
  },
  trim: function(e) {
    return String.prototype.trim ? e.trim() : e.replace(/(^\s*)|(\s*$)/g, "");
  },
  trimRight: function(e) {
    return String.prototype.trimRight ? e.trimRight() : e.replace(/(\s*$)/g, "");
  }
}, ua = OY;
function MY(e, t) {
  e = ua.trimRight(e), e[e.length - 1] !== ";" && (e += ";");
  var n = e.length, r = !1, i = 0, s = 0, a = "";
  function o() {
    if (!r) {
      var u = ua.trim(e.slice(i, s)), f = u.indexOf(":");
      if (f !== -1) {
        var d = ua.trim(u.slice(0, f)), h = ua.trim(u.slice(f + 1));
        if (d) {
          var p = t(i, a.length, d, h, u);
          p && (a += p + "; ");
        }
      }
    }
    i = s + 1;
  }
  for (; s < n; s++) {
    var l = e[s];
    if (l === "/" && e[s + 1] === "*") {
      var c = e.indexOf("*/", s + 2);
      if (c === -1)
        break;
      s = c + 1, i = s + 1, r = !1;
    } else
      l === "(" ? r = !0 : l === ")" ? r = !1 : l === ";" ? r || o() : l === `
` && o();
  }
  return ua.trim(a);
}
var FY = MY, cl = Fi, PY = FY;
function cy(e) {
  return e == null;
}
function IY(e) {
  var t = {};
  for (var n in e)
    t[n] = e[n];
  return t;
}
function D2(e) {
  e = IY(e || {}), e.whiteList = e.whiteList || cl.whiteList, e.onAttr = e.onAttr || cl.onAttr, e.onIgnoreAttr = e.onIgnoreAttr || cl.onIgnoreAttr, e.safeAttrValue = e.safeAttrValue || cl.safeAttrValue, this.options = e;
}
D2.prototype.process = function(e) {
  if (e = e || "", e = e.toString(), !e)
    return "";
  var t = this, n = t.options, r = n.whiteList, i = n.onAttr, s = n.onIgnoreAttr, a = n.safeAttrValue, o = PY(e, function(l, c, u, f, d) {
    var h = r[u], p = !1;
    if (h === !0 ? p = h : typeof h == "function" ? p = h(f) : h instanceof RegExp && (p = h.test(f)), p !== !0 && (p = !1), f = a(u, f), !!f) {
      var g = {
        position: c,
        sourcePosition: l,
        source: d,
        isWhite: p
      };
      if (p) {
        var v = i(u, f, g);
        return cy(v) ? u + ":" + f : v;
      } else {
        var v = s(u, f, g);
        if (!cy(v))
          return v;
      }
    }
  });
  return o;
};
var RY = D2;
(function(e, t) {
  var n = Fi, r = RY;
  function i(a, o) {
    var l = new r(o);
    return l.process(a);
  }
  t = e.exports = i, t.FilterCSS = r;
  for (var s in n)
    t[s] = n[s];
  typeof window < "u" && (window.filterCSS = e.exports);
})(t0, t0.exports);
var Yh = t0.exports, qh = {
  indexOf: function(e, t) {
    var n, r;
    if (Array.prototype.indexOf)
      return e.indexOf(t);
    for (n = 0, r = e.length; n < r; n++)
      if (e[n] === t)
        return n;
    return -1;
  },
  forEach: function(e, t, n) {
    var r, i;
    if (Array.prototype.forEach)
      return e.forEach(t, n);
    for (r = 0, i = e.length; r < i; r++)
      t.call(n, e[r], r, e);
  },
  trim: function(e) {
    return String.prototype.trim ? e.trim() : e.replace(/(^\s*)|(\s*$)/g, "");
  },
  spaceIndex: function(e) {
    var t = /\s|\n|\t/, n = t.exec(e);
    return n ? n.index : -1;
  }
}, BY = Yh.FilterCSS, NY = Yh.getDefaultWhiteList, Dc = qh;
function S2() {
  return {
    a: ["target", "href", "title"],
    abbr: ["title"],
    address: [],
    area: ["shape", "coords", "href", "alt"],
    article: [],
    aside: [],
    audio: [
      "autoplay",
      "controls",
      "crossorigin",
      "loop",
      "muted",
      "preload",
      "src"
    ],
    b: [],
    bdi: ["dir"],
    bdo: ["dir"],
    big: [],
    blockquote: ["cite"],
    br: [],
    caption: [],
    center: [],
    cite: [],
    code: [],
    col: ["align", "valign", "span", "width"],
    colgroup: ["align", "valign", "span", "width"],
    dd: [],
    del: ["datetime"],
    details: ["open"],
    div: [],
    dl: [],
    dt: [],
    em: [],
    figcaption: [],
    figure: [],
    font: ["color", "size", "face"],
    footer: [],
    h1: [],
    h2: [],
    h3: [],
    h4: [],
    h5: [],
    h6: [],
    header: [],
    hr: [],
    i: [],
    img: ["src", "alt", "title", "width", "height"],
    ins: ["datetime"],
    li: [],
    mark: [],
    nav: [],
    ol: [],
    p: [],
    pre: [],
    s: [],
    section: [],
    small: [],
    span: [],
    sub: [],
    summary: [],
    sup: [],
    strong: [],
    strike: [],
    table: ["width", "border", "align", "valign"],
    tbody: ["align", "valign"],
    td: ["width", "rowspan", "colspan", "align", "valign"],
    tfoot: ["align", "valign"],
    th: ["width", "rowspan", "colspan", "align", "valign"],
    thead: ["align", "valign"],
    tr: ["rowspan", "align", "valign"],
    tt: [],
    u: [],
    ul: [],
    video: [
      "autoplay",
      "controls",
      "crossorigin",
      "loop",
      "muted",
      "playsinline",
      "poster",
      "preload",
      "src",
      "height",
      "width"
    ]
  };
}
var T2 = new BY();
function LY(e, t, n) {
}
function jY(e, t, n) {
}
function zY(e, t, n) {
}
function VY(e, t, n) {
}
function O2(e) {
  return e.replace(WY, "&lt;").replace(UY, "&gt;");
}
function HY(e, t, n, r) {
  if (n = B2(n), t === "href" || t === "src") {
    if (n = Dc.trim(n), n === "#")
      return "#";
    if (!(n.substr(0, 7) === "http://" || n.substr(0, 8) === "https://" || n.substr(0, 7) === "mailto:" || n.substr(0, 4) === "tel:" || n.substr(0, 11) === "data:image/" || n.substr(0, 6) === "ftp://" || n.substr(0, 2) === "./" || n.substr(0, 3) === "../" || n[0] === "#" || n[0] === "/"))
      return "";
  } else if (t === "background") {
    if (ul.lastIndex = 0, ul.test(n))
      return "";
  } else if (t === "style") {
    if (uy.lastIndex = 0, uy.test(n) || (fy.lastIndex = 0, fy.test(n) && (ul.lastIndex = 0, ul.test(n))))
      return "";
    r !== !1 && (r = r || T2, n = r.process(n));
  }
  return n = N2(n), n;
}
var WY = /</g, UY = />/g, YY = /"/g, qY = /&quot;/g, GY = /&#([a-zA-Z0-9]*);?/gim, XY = /&colon;?/gim, ZY = /&newline;?/gim, ul = /((j\s*a\s*v\s*a|v\s*b|l\s*i\s*v\s*e)\s*s\s*c\s*r\s*i\s*p\s*t\s*|m\s*o\s*c\s*h\s*a):/gi, uy = /e\s*x\s*p\s*r\s*e\s*s\s*s\s*i\s*o\s*n\s*\(.*/gi, fy = /u\s*r\s*l\s*\(.*/gi;
function M2(e) {
  return e.replace(YY, "&quot;");
}
function F2(e) {
  return e.replace(qY, '"');
}
function P2(e) {
  return e.replace(GY, function(n, r) {
    return r[0] === "x" || r[0] === "X" ? String.fromCharCode(parseInt(r.substr(1), 16)) : String.fromCharCode(parseInt(r, 10));
  });
}
function I2(e) {
  return e.replace(XY, ":").replace(ZY, " ");
}
function R2(e) {
  for (var t = "", n = 0, r = e.length; n < r; n++)
    t += e.charCodeAt(n) < 32 ? " " : e.charAt(n);
  return Dc.trim(t);
}
function B2(e) {
  return e = F2(e), e = P2(e), e = I2(e), e = R2(e), e;
}
function N2(e) {
  return e = M2(e), e = O2(e), e;
}
function KY() {
  return "";
}
function JY(e, t) {
  typeof t != "function" && (t = function() {
  });
  var n = !Array.isArray(e);
  function r(a) {
    return n ? !0 : Dc.indexOf(e, a) !== -1;
  }
  var i = [], s = !1;
  return {
    onIgnoreTag: function(a, o, l) {
      if (r(a))
        if (l.isClosing) {
          var c = "[/removed]", u = l.position + c.length;
          return i.push([
            s !== !1 ? s : l.position,
            u
          ]), s = !1, c;
        } else
          return s || (s = l.position), "[removed]";
      else
        return t(a, o, l);
    },
    remove: function(a) {
      var o = "", l = 0;
      return Dc.forEach(i, function(c) {
        o += a.slice(l, c[0]), l = c[1];
      }), o += a.slice(l), o;
    }
  };
}
function QY(e) {
  for (var t = "", n = 0; n < e.length; ) {
    var r = e.indexOf("<!--", n);
    if (r === -1) {
      t += e.slice(n);
      break;
    }
    t += e.slice(n, r);
    var i = e.indexOf("-->", r);
    if (i === -1)
      break;
    n = i + 3;
  }
  return t;
}
function eq(e) {
  var t = e.split("");
  return t = t.filter(function(n) {
    var r = n.charCodeAt(0);
    return r === 127 ? !1 : r <= 31 ? r === 10 || r === 13 : !0;
  }), t.join("");
}
it.whiteList = S2();
it.getDefaultWhiteList = S2;
it.onTag = LY;
it.onIgnoreTag = jY;
it.onTagAttr = zY;
it.onIgnoreTagAttr = VY;
it.safeAttrValue = HY;
it.escapeHtml = O2;
it.escapeQuote = M2;
it.unescapeQuote = F2;
it.escapeHtmlEntities = P2;
it.escapeDangerHtml5Entities = I2;
it.clearNonPrintableCharacter = R2;
it.friendlyAttrValue = B2;
it.escapeAttrValue = N2;
it.onIgnoreTagStripAll = KY;
it.StripTagBody = JY;
it.stripCommentTag = QY;
it.stripBlankChar = eq;
it.cssFilter = T2;
it.getDefaultCSSWhiteList = NY;
var Eu = {}, Ar = qh;
function tq(e) {
  var t = Ar.spaceIndex(e), n;
  return t === -1 ? n = e.slice(1, -1) : n = e.slice(1, t + 1), n = Ar.trim(n).toLowerCase(), n.slice(0, 1) === "/" && (n = n.slice(1)), n.slice(-1) === "/" && (n = n.slice(0, -1)), n;
}
function nq(e) {
  return e.slice(0, 2) === "</";
}
function rq(e, t, n) {
  var r = "", i = 0, s = !1, a = !1, o = 0, l = e.length, c = "", u = "";
  e:
    for (o = 0; o < l; o++) {
      var f = e.charAt(o);
      if (s === !1) {
        if (f === "<") {
          s = o;
          continue;
        }
      } else if (a === !1) {
        if (f === "<") {
          r += n(e.slice(i, o)), s = o, i = o;
          continue;
        }
        if (f === ">" || o === l - 1) {
          r += n(e.slice(i, s)), u = e.slice(s, o + 1), c = tq(u), r += t(
            s,
            r.length,
            c,
            u,
            nq(u)
          ), i = o + 1, s = !1;
          continue;
        }
        if (f === '"' || f === "'")
          for (var d = 1, h = e.charAt(o - d); h.trim() === "" || h === "="; ) {
            if (h === "=") {
              a = f;
              continue e;
            }
            h = e.charAt(o - ++d);
          }
      } else if (f === a) {
        a = !1;
        continue;
      }
    }
  return i < l && (r += n(e.substr(i))), r;
}
var iq = /[^a-zA-Z0-9\\_:.-]/gim;
function sq(e, t) {
  var n = 0, r = 0, i = [], s = !1, a = e.length;
  function o(d, h) {
    if (d = Ar.trim(d), d = d.replace(iq, "").toLowerCase(), !(d.length < 1)) {
      var p = t(d, h || "");
      p && i.push(p);
    }
  }
  for (var l = 0; l < a; l++) {
    var c = e.charAt(l), u, f;
    if (s === !1 && c === "=") {
      s = e.slice(n, l), n = l + 1, r = e.charAt(n) === '"' || e.charAt(n) === "'" ? n : oq(e, l + 1);
      continue;
    }
    if (s !== !1 && l === r) {
      if (f = e.indexOf(c, l + 1), f === -1)
        break;
      u = Ar.trim(e.slice(r + 1, f)), o(s, u), s = !1, l = f, n = l + 1;
      continue;
    }
    if (/\s|\n|\t/.test(c))
      if (e = e.replace(/\s|\n|\t/g, " "), s === !1)
        if (f = aq(e, l), f === -1) {
          u = Ar.trim(e.slice(n, l)), o(u), s = !1, n = l + 1;
          continue;
        } else {
          l = f - 1;
          continue;
        }
      else if (f = lq(e, l - 1), f === -1) {
        u = Ar.trim(e.slice(n, l)), u = dy(u), o(s, u), s = !1, n = l + 1;
        continue;
      } else
        continue;
  }
  return n < e.length && (s === !1 ? o(e.slice(n)) : o(s, dy(Ar.trim(e.slice(n))))), Ar.trim(i.join(" "));
}
function aq(e, t) {
  for (; t < e.length; t++) {
    var n = e[t];
    if (n !== " ")
      return n === "=" ? t : -1;
  }
}
function oq(e, t) {
  for (; t < e.length; t++) {
    var n = e[t];
    if (n !== " ")
      return n === "'" || n === '"' ? t : -1;
  }
}
function lq(e, t) {
  for (; t > 0; t--) {
    var n = e[t];
    if (n !== " ")
      return n === "=" ? t : -1;
  }
}
function cq(e) {
  return e[0] === '"' && e[e.length - 1] === '"' || e[0] === "'" && e[e.length - 1] === "'";
}
function dy(e) {
  return cq(e) ? e.substr(1, e.length - 2) : e;
}
Eu.parseTag = rq;
Eu.parseAttr = sq;
var uq = Yh.FilterCSS, wn = it, L2 = Eu, fq = L2.parseTag, dq = L2.parseAttr, Bl = qh;
function fl(e) {
  return e == null;
}
function hq(e) {
  var t = Bl.spaceIndex(e);
  if (t === -1)
    return {
      html: "",
      closing: e[e.length - 2] === "/"
    };
  e = Bl.trim(e.slice(t + 1, -1));
  var n = e[e.length - 1] === "/";
  return n && (e = Bl.trim(e.slice(0, -1))), {
    html: e,
    closing: n
  };
}
function pq(e) {
  var t = {};
  for (var n in e)
    t[n] = e[n];
  return t;
}
function gq(e) {
  var t = {};
  for (var n in e)
    Array.isArray(e[n]) ? t[n.toLowerCase()] = e[n].map(function(r) {
      return r.toLowerCase();
    }) : t[n.toLowerCase()] = e[n];
  return t;
}
function j2(e) {
  e = pq(e || {}), e.stripIgnoreTag && (e.onIgnoreTag && console.error(
    'Notes: cannot use these two options "stripIgnoreTag" and "onIgnoreTag" at the same time'
  ), e.onIgnoreTag = wn.onIgnoreTagStripAll), e.whiteList || e.allowList ? e.whiteList = gq(e.whiteList || e.allowList) : e.whiteList = wn.whiteList, e.onTag = e.onTag || wn.onTag, e.onTagAttr = e.onTagAttr || wn.onTagAttr, e.onIgnoreTag = e.onIgnoreTag || wn.onIgnoreTag, e.onIgnoreTagAttr = e.onIgnoreTagAttr || wn.onIgnoreTagAttr, e.safeAttrValue = e.safeAttrValue || wn.safeAttrValue, e.escapeHtml = e.escapeHtml || wn.escapeHtml, this.options = e, e.css === !1 ? this.cssFilter = !1 : (e.css = e.css || {}, this.cssFilter = new uq(e.css));
}
j2.prototype.process = function(e) {
  if (e = e || "", e = e.toString(), !e)
    return "";
  var t = this, n = t.options, r = n.whiteList, i = n.onTag, s = n.onIgnoreTag, a = n.onTagAttr, o = n.onIgnoreTagAttr, l = n.safeAttrValue, c = n.escapeHtml, u = t.cssFilter;
  n.stripBlankChar && (e = wn.stripBlankChar(e)), n.allowCommentTag || (e = wn.stripCommentTag(e));
  var f = !1;
  n.stripIgnoreTagBody && (f = wn.StripTagBody(
    n.stripIgnoreTagBody,
    s
  ), s = f.onIgnoreTag);
  var d = fq(
    e,
    function(h, p, g, v, m) {
      var x = {
        sourcePosition: h,
        position: p,
        isClosing: m,
        isWhite: Object.prototype.hasOwnProperty.call(r, g)
      }, _ = i(g, v, x);
      if (!fl(_))
        return _;
      if (x.isWhite) {
        if (x.isClosing)
          return "</" + g + ">";
        var y = hq(v), b = r[g], w = dq(y.html, function(E, $) {
          var C = Bl.indexOf(b, E) !== -1, A = a(g, E, $, C);
          return fl(A) ? C ? ($ = l(g, E, $, u), $ ? E + '="' + $ + '"' : E) : (A = o(g, E, $, C), fl(A) ? void 0 : A) : A;
        });
        return v = "<" + g, w && (v += " " + w), y.closing && (v += " /"), v += ">", v;
      } else
        return _ = s(g, v, x), fl(_) ? c(v) : _;
    },
    c
  );
  return f && (d = f.remove(d)), d;
};
var vq = j2;
(function(e, t) {
  var n = it, r = Eu, i = vq;
  function s(o, l) {
    var c = new i(l);
    return c.process(o);
  }
  t = e.exports = s, t.filterXSS = s, t.FilterXSS = i, function() {
    for (var o in n)
      t[o] = n[o];
    for (var l in r)
      t[l] = r[l];
  }(), typeof window < "u" && (window.filterXSS = e.exports);
  function a() {
    return typeof self < "u" && typeof DedicatedWorkerGlobalScope < "u" && self instanceof DedicatedWorkerGlobalScope;
  }
  a() && (self.filterXSS = e.exports);
})(e0, e0.exports);
var z2 = e0.exports;
const hy = /* @__PURE__ */ Vr(z2);
function V2(e) {
  return e instanceof Map ? e.clear = e.delete = e.set = function() {
    throw new Error("map is read-only");
  } : e instanceof Set && (e.add = e.clear = e.delete = function() {
    throw new Error("set is read-only");
  }), Object.freeze(e), Object.getOwnPropertyNames(e).forEach((t) => {
    const n = e[t], r = typeof n;
    (r === "object" || r === "function") && !Object.isFrozen(n) && V2(n);
  }), e;
}
class py {
  /**
   * @param {CompiledMode} mode
   */
  constructor(t) {
    t.data === void 0 && (t.data = {}), this.data = t.data, this.isMatchIgnored = !1;
  }
  ignoreMatch() {
    this.isMatchIgnored = !0;
  }
}
function H2(e) {
  return e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
}
function Mr(e, ...t) {
  const n = /* @__PURE__ */ Object.create(null);
  for (const r in e)
    n[r] = e[r];
  return t.forEach(function(r) {
    for (const i in r)
      n[i] = r[i];
  }), /** @type {T} */
  n;
}
const mq = "</span>", gy = (e) => !!e.scope, yq = (e, { prefix: t }) => {
  if (e.startsWith("language:"))
    return e.replace("language:", "language-");
  if (e.includes(".")) {
    const n = e.split(".");
    return [
      `${t}${n.shift()}`,
      ...n.map((r, i) => `${r}${"_".repeat(i + 1)}`)
    ].join(" ");
  }
  return `${t}${e}`;
};
class xq {
  /**
   * Creates a new HTMLRenderer
   *
   * @param {Tree} parseTree - the parse tree (must support `walk` API)
   * @param {{classPrefix: string}} options
   */
  constructor(t, n) {
    this.buffer = "", this.classPrefix = n.classPrefix, t.walk(this);
  }
  /**
   * Adds texts to the output stream
   *
   * @param {string} text */
  addText(t) {
    this.buffer += H2(t);
  }
  /**
   * Adds a node open to the output stream (if needed)
   *
   * @param {Node} node */
  openNode(t) {
    if (!gy(t))
      return;
    const n = yq(
      t.scope,
      { prefix: this.classPrefix }
    );
    this.span(n);
  }
  /**
   * Adds a node close to the output stream (if needed)
   *
   * @param {Node} node */
  closeNode(t) {
    gy(t) && (this.buffer += mq);
  }
  /**
   * returns the accumulated buffer
  */
  value() {
    return this.buffer;
  }
  // helpers
  /**
   * Builds a span element
   *
   * @param {string} className */
  span(t) {
    this.buffer += `<span class="${t}">`;
  }
}
const vy = (e = {}) => {
  const t = { children: [] };
  return Object.assign(t, e), t;
};
class Gh {
  constructor() {
    this.rootNode = vy(), this.stack = [this.rootNode];
  }
  get top() {
    return this.stack[this.stack.length - 1];
  }
  get root() {
    return this.rootNode;
  }
  /** @param {Node} node */
  add(t) {
    this.top.children.push(t);
  }
  /** @param {string} scope */
  openNode(t) {
    const n = vy({ scope: t });
    this.add(n), this.stack.push(n);
  }
  closeNode() {
    if (this.stack.length > 1)
      return this.stack.pop();
  }
  closeAllNodes() {
    for (; this.closeNode(); )
      ;
  }
  toJSON() {
    return JSON.stringify(this.rootNode, null, 4);
  }
  /**
   * @typedef { import("./html_renderer").Renderer } Renderer
   * @param {Renderer} builder
   */
  walk(t) {
    return this.constructor._walk(t, this.rootNode);
  }
  /**
   * @param {Renderer} builder
   * @param {Node} node
   */
  static _walk(t, n) {
    return typeof n == "string" ? t.addText(n) : n.children && (t.openNode(n), n.children.forEach((r) => this._walk(t, r)), t.closeNode(n)), t;
  }
  /**
   * @param {Node} node
   */
  static _collapse(t) {
    typeof t != "string" && t.children && (t.children.every((n) => typeof n == "string") ? t.children = [t.children.join("")] : t.children.forEach((n) => {
      Gh._collapse(n);
    }));
  }
}
class bq extends Gh {
  /**
   * @param {*} options
   */
  constructor(t) {
    super(), this.options = t;
  }
  /**
   * @param {string} text
   */
  addText(t) {
    t !== "" && this.add(t);
  }
  /** @param {string} scope */
  startScope(t) {
    this.openNode(t);
  }
  endScope() {
    this.closeNode();
  }
  /**
   * @param {Emitter & {root: DataNode}} emitter
   * @param {string} name
   */
  __addSublanguage(t, n) {
    const r = t.root;
    n && (r.scope = `language:${n}`), this.add(r);
  }
  toHTML() {
    return new xq(this, this.options).value();
  }
  finalize() {
    return this.closeAllNodes(), !0;
  }
}
function ao(e) {
  return e ? typeof e == "string" ? e : e.source : null;
}
function W2(e) {
  return Pi("(?=", e, ")");
}
function _q(e) {
  return Pi("(?:", e, ")*");
}
function wq(e) {
  return Pi("(?:", e, ")?");
}
function Pi(...e) {
  return e.map((n) => ao(n)).join("");
}
function $q(e) {
  const t = e[e.length - 1];
  return typeof t == "object" && t.constructor === Object ? (e.splice(e.length - 1, 1), t) : {};
}
function Xh(...e) {
  return "(" + ($q(e).capture ? "" : "?:") + e.map((r) => ao(r)).join("|") + ")";
}
function U2(e) {
  return new RegExp(e.toString() + "|").exec("").length - 1;
}
function Eq(e, t) {
  const n = e && e.exec(t);
  return n && n.index === 0;
}
const Aq = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
function Zh(e, { joinWith: t }) {
  let n = 0;
  return e.map((r) => {
    n += 1;
    const i = n;
    let s = ao(r), a = "";
    for (; s.length > 0; ) {
      const o = Aq.exec(s);
      if (!o) {
        a += s;
        break;
      }
      a += s.substring(0, o.index), s = s.substring(o.index + o[0].length), o[0][0] === "\\" && o[1] ? a += "\\" + String(Number(o[1]) + i) : (a += o[0], o[0] === "(" && n++);
    }
    return a;
  }).map((r) => `(${r})`).join(t);
}
const kq = /\b\B/, Y2 = "[a-zA-Z]\\w*", Kh = "[a-zA-Z_]\\w*", q2 = "\\b\\d+(\\.\\d+)?", G2 = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", X2 = "\\b(0b[01]+)", Cq = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~", Dq = (e = {}) => {
  const t = /^#![ ]*\//;
  return e.binary && (e.begin = Pi(
    t,
    /.*\b/,
    e.binary,
    /\b.*/
  )), Mr({
    scope: "meta",
    begin: t,
    end: /$/,
    relevance: 0,
    /** @type {ModeCallback} */
    "on:begin": (n, r) => {
      n.index !== 0 && r.ignoreMatch();
    }
  }, e);
}, oo = {
  begin: "\\\\[\\s\\S]",
  relevance: 0
}, Sq = {
  scope: "string",
  begin: "'",
  end: "'",
  illegal: "\\n",
  contains: [oo]
}, Tq = {
  scope: "string",
  begin: '"',
  end: '"',
  illegal: "\\n",
  contains: [oo]
}, Oq = {
  begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
}, Au = function(e, t, n = {}) {
  const r = Mr(
    {
      scope: "comment",
      begin: e,
      end: t,
      contains: []
    },
    n
  );
  r.contains.push({
    scope: "doctag",
    // hack to avoid the space from being included. the space is necessary to
    // match here to prevent the plain text rule below from gobbling up doctags
    begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
    end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
    excludeBegin: !0,
    relevance: 0
  });
  const i = Xh(
    // list of common 1 and 2 letter words in English
    "I",
    "a",
    "is",
    "so",
    "us",
    "to",
    "at",
    "if",
    "in",
    "it",
    "on",
    // note: this is not an exhaustive list of contractions, just popular ones
    /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
    // contractions - can't we'd they're let's, etc
    /[A-Za-z]+[-][a-z]+/,
    // `no-way`, etc.
    /[A-Za-z][a-z]{2,}/
    // allow capitalized words at beginning of sentences
  );
  return r.contains.push(
    {
      // TODO: how to include ", (, ) without breaking grammars that use these for
      // comment delimiters?
      // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
      // ---
      // this tries to find sequences of 3 english words in a row (without any
      // "programming" type syntax) this gives us a strong signal that we've
      // TRULY found a comment - vs perhaps scanning with the wrong language.
      // It's possible to find something that LOOKS like the start of the
      // comment - but then if there is no readable text - good chance it is a
      // false match and not a comment.
      //
      // for a visual example please see:
      // https://github.com/highlightjs/highlight.js/issues/2827
      begin: Pi(
        /[ ]+/,
        // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
        "(",
        i,
        /[.]?[:]?([.][ ]|[ ])/,
        "){3}"
      )
      // look for 3 words in a row
    }
  ), r;
}, Mq = Au("//", "$"), Fq = Au("/\\*", "\\*/"), Pq = Au("#", "$"), Iq = {
  scope: "number",
  begin: q2,
  relevance: 0
}, Rq = {
  scope: "number",
  begin: G2,
  relevance: 0
}, Bq = {
  scope: "number",
  begin: X2,
  relevance: 0
}, Nq = {
  scope: "regexp",
  begin: /\/(?=[^/\n]*\/)/,
  end: /\/[gimuy]*/,
  contains: [
    oo,
    {
      begin: /\[/,
      end: /\]/,
      relevance: 0,
      contains: [oo]
    }
  ]
}, Lq = {
  scope: "title",
  begin: Y2,
  relevance: 0
}, jq = {
  scope: "title",
  begin: Kh,
  relevance: 0
}, zq = {
  // excludes method names from keyword processing
  begin: "\\.\\s*" + Kh,
  relevance: 0
}, Vq = function(e) {
  return Object.assign(
    e,
    {
      /** @type {ModeCallback} */
      "on:begin": (t, n) => {
        n.data._beginMatch = t[1];
      },
      /** @type {ModeCallback} */
      "on:end": (t, n) => {
        n.data._beginMatch !== t[1] && n.ignoreMatch();
      }
    }
  );
};
var dl = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  APOS_STRING_MODE: Sq,
  BACKSLASH_ESCAPE: oo,
  BINARY_NUMBER_MODE: Bq,
  BINARY_NUMBER_RE: X2,
  COMMENT: Au,
  C_BLOCK_COMMENT_MODE: Fq,
  C_LINE_COMMENT_MODE: Mq,
  C_NUMBER_MODE: Rq,
  C_NUMBER_RE: G2,
  END_SAME_AS_BEGIN: Vq,
  HASH_COMMENT_MODE: Pq,
  IDENT_RE: Y2,
  MATCH_NOTHING_RE: kq,
  METHOD_GUARD: zq,
  NUMBER_MODE: Iq,
  NUMBER_RE: q2,
  PHRASAL_WORDS_MODE: Oq,
  QUOTE_STRING_MODE: Tq,
  REGEXP_MODE: Nq,
  RE_STARTERS_RE: Cq,
  SHEBANG: Dq,
  TITLE_MODE: Lq,
  UNDERSCORE_IDENT_RE: Kh,
  UNDERSCORE_TITLE_MODE: jq
});
function Hq(e, t) {
  e.input[e.index - 1] === "." && t.ignoreMatch();
}
function Wq(e, t) {
  e.className !== void 0 && (e.scope = e.className, delete e.className);
}
function Uq(e, t) {
  t && e.beginKeywords && (e.begin = "\\b(" + e.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", e.__beforeBegin = Hq, e.keywords = e.keywords || e.beginKeywords, delete e.beginKeywords, e.relevance === void 0 && (e.relevance = 0));
}
function Yq(e, t) {
  Array.isArray(e.illegal) && (e.illegal = Xh(...e.illegal));
}
function qq(e, t) {
  if (e.match) {
    if (e.begin || e.end)
      throw new Error("begin & end are not supported with match");
    e.begin = e.match, delete e.match;
  }
}
function Gq(e, t) {
  e.relevance === void 0 && (e.relevance = 1);
}
const Xq = (e, t) => {
  if (!e.beforeMatch)
    return;
  if (e.starts)
    throw new Error("beforeMatch cannot be used with starts");
  const n = Object.assign({}, e);
  Object.keys(e).forEach((r) => {
    delete e[r];
  }), e.keywords = n.keywords, e.begin = Pi(n.beforeMatch, W2(n.begin)), e.starts = {
    relevance: 0,
    contains: [
      Object.assign(n, { endsParent: !0 })
    ]
  }, e.relevance = 0, delete n.beforeMatch;
}, Zq = [
  "of",
  "and",
  "for",
  "in",
  "not",
  "or",
  "if",
  "then",
  "parent",
  // common variable name
  "list",
  // common variable name
  "value"
  // common variable name
], Kq = "keyword";
function Z2(e, t, n = Kq) {
  const r = /* @__PURE__ */ Object.create(null);
  return typeof e == "string" ? i(n, e.split(" ")) : Array.isArray(e) ? i(n, e) : Object.keys(e).forEach(function(s) {
    Object.assign(
      r,
      Z2(e[s], t, s)
    );
  }), r;
  function i(s, a) {
    t && (a = a.map((o) => o.toLowerCase())), a.forEach(function(o) {
      const l = o.split("|");
      r[l[0]] = [s, Jq(l[0], l[1])];
    });
  }
}
function Jq(e, t) {
  return t ? Number(t) : Qq(e) ? 0 : 1;
}
function Qq(e) {
  return Zq.includes(e.toLowerCase());
}
const my = {}, di = (e) => {
  console.error(e);
}, yy = (e, ...t) => {
  console.log(`WARN: ${e}`, ...t);
}, Yi = (e, t) => {
  my[`${e}/${t}`] || (console.log(`Deprecated as of ${e}. ${t}`), my[`${e}/${t}`] = !0);
}, Sc = new Error();
function K2(e, t, { key: n }) {
  let r = 0;
  const i = e[n], s = {}, a = {};
  for (let o = 1; o <= t.length; o++)
    a[o + r] = i[o], s[o + r] = !0, r += U2(t[o - 1]);
  e[n] = a, e[n]._emit = s, e[n]._multi = !0;
}
function eG(e) {
  if (Array.isArray(e.begin)) {
    if (e.skip || e.excludeBegin || e.returnBegin)
      throw di("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), Sc;
    if (typeof e.beginScope != "object" || e.beginScope === null)
      throw di("beginScope must be object"), Sc;
    K2(e, e.begin, { key: "beginScope" }), e.begin = Zh(e.begin, { joinWith: "" });
  }
}
function tG(e) {
  if (Array.isArray(e.end)) {
    if (e.skip || e.excludeEnd || e.returnEnd)
      throw di("skip, excludeEnd, returnEnd not compatible with endScope: {}"), Sc;
    if (typeof e.endScope != "object" || e.endScope === null)
      throw di("endScope must be object"), Sc;
    K2(e, e.end, { key: "endScope" }), e.end = Zh(e.end, { joinWith: "" });
  }
}
function nG(e) {
  e.scope && typeof e.scope == "object" && e.scope !== null && (e.beginScope = e.scope, delete e.scope);
}
function rG(e) {
  nG(e), typeof e.beginScope == "string" && (e.beginScope = { _wrap: e.beginScope }), typeof e.endScope == "string" && (e.endScope = { _wrap: e.endScope }), eG(e), tG(e);
}
function iG(e) {
  function t(a, o) {
    return new RegExp(
      ao(a),
      "m" + (e.case_insensitive ? "i" : "") + (e.unicodeRegex ? "u" : "") + (o ? "g" : "")
    );
  }
  class n {
    constructor() {
      this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0;
    }
    // @ts-ignore
    addRule(o, l) {
      l.position = this.position++, this.matchIndexes[this.matchAt] = l, this.regexes.push([l, o]), this.matchAt += U2(o) + 1;
    }
    compile() {
      this.regexes.length === 0 && (this.exec = () => null);
      const o = this.regexes.map((l) => l[1]);
      this.matcherRe = t(Zh(o, { joinWith: "|" }), !0), this.lastIndex = 0;
    }
    /** @param {string} s */
    exec(o) {
      this.matcherRe.lastIndex = this.lastIndex;
      const l = this.matcherRe.exec(o);
      if (!l)
        return null;
      const c = l.findIndex((f, d) => d > 0 && f !== void 0), u = this.matchIndexes[c];
      return l.splice(0, c), Object.assign(l, u);
    }
  }
  class r {
    constructor() {
      this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0;
    }
    // @ts-ignore
    getMatcher(o) {
      if (this.multiRegexes[o])
        return this.multiRegexes[o];
      const l = new n();
      return this.rules.slice(o).forEach(([c, u]) => l.addRule(c, u)), l.compile(), this.multiRegexes[o] = l, l;
    }
    resumingScanAtSamePosition() {
      return this.regexIndex !== 0;
    }
    considerAll() {
      this.regexIndex = 0;
    }
    // @ts-ignore
    addRule(o, l) {
      this.rules.push([o, l]), l.type === "begin" && this.count++;
    }
    /** @param {string} s */
    exec(o) {
      const l = this.getMatcher(this.regexIndex);
      l.lastIndex = this.lastIndex;
      let c = l.exec(o);
      if (this.resumingScanAtSamePosition() && !(c && c.index === this.lastIndex)) {
        const u = this.getMatcher(0);
        u.lastIndex = this.lastIndex + 1, c = u.exec(o);
      }
      return c && (this.regexIndex += c.position + 1, this.regexIndex === this.count && this.considerAll()), c;
    }
  }
  function i(a) {
    const o = new r();
    return a.contains.forEach((l) => o.addRule(l.begin, { rule: l, type: "begin" })), a.terminatorEnd && o.addRule(a.terminatorEnd, { type: "end" }), a.illegal && o.addRule(a.illegal, { type: "illegal" }), o;
  }
  function s(a, o) {
    const l = (
      /** @type CompiledMode */
      a
    );
    if (a.isCompiled)
      return l;
    [
      Wq,
      // do this early so compiler extensions generally don't have to worry about
      // the distinction between match/begin
      qq,
      rG,
      Xq
    ].forEach((u) => u(a, o)), e.compilerExtensions.forEach((u) => u(a, o)), a.__beforeBegin = null, [
      Uq,
      // do this later so compiler extensions that come earlier have access to the
      // raw array if they wanted to perhaps manipulate it, etc.
      Yq,
      // default to 1 relevance if not specified
      Gq
    ].forEach((u) => u(a, o)), a.isCompiled = !0;
    let c = null;
    return typeof a.keywords == "object" && a.keywords.$pattern && (a.keywords = Object.assign({}, a.keywords), c = a.keywords.$pattern, delete a.keywords.$pattern), c = c || /\w+/, a.keywords && (a.keywords = Z2(a.keywords, e.case_insensitive)), l.keywordPatternRe = t(c, !0), o && (a.begin || (a.begin = /\B|\b/), l.beginRe = t(l.begin), !a.end && !a.endsWithParent && (a.end = /\B|\b/), a.end && (l.endRe = t(l.end)), l.terminatorEnd = ao(l.end) || "", a.endsWithParent && o.terminatorEnd && (l.terminatorEnd += (a.end ? "|" : "") + o.terminatorEnd)), a.illegal && (l.illegalRe = t(
      /** @type {RegExp | string} */
      a.illegal
    )), a.contains || (a.contains = []), a.contains = [].concat(...a.contains.map(function(u) {
      return sG(u === "self" ? a : u);
    })), a.contains.forEach(function(u) {
      s(
        /** @type Mode */
        u,
        l
      );
    }), a.starts && s(a.starts, o), l.matcher = i(l), l;
  }
  if (e.compilerExtensions || (e.compilerExtensions = []), e.contains && e.contains.includes("self"))
    throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
  return e.classNameAliases = Mr(e.classNameAliases || {}), s(
    /** @type Mode */
    e
  );
}
function J2(e) {
  return e ? e.endsWithParent || J2(e.starts) : !1;
}
function sG(e) {
  return e.variants && !e.cachedVariants && (e.cachedVariants = e.variants.map(function(t) {
    return Mr(e, { variants: null }, t);
  })), e.cachedVariants ? e.cachedVariants : J2(e) ? Mr(e, { starts: e.starts ? Mr(e.starts) : null }) : Object.isFrozen(e) ? Mr(e) : e;
}
var aG = "11.9.0";
class oG extends Error {
  constructor(t, n) {
    super(t), this.name = "HTMLInjectionError", this.html = n;
  }
}
const uf = H2, xy = Mr, by = Symbol("nomatch"), lG = 7, Q2 = function(e) {
  const t = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null), r = [];
  let i = !0;
  const s = "Could not find the language '{}', did you forget to load/include a language module?", a = { disableAutodetect: !0, name: "Plain text", contains: [] };
  let o = {
    ignoreUnescapedHTML: !1,
    throwUnescapedHTML: !1,
    noHighlightRe: /^(no-?highlight)$/i,
    languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
    classPrefix: "hljs-",
    cssSelector: "pre code",
    languages: null,
    // beta configuration options, subject to change, welcome to discuss
    // https://github.com/highlightjs/highlight.js/issues/1086
    __emitter: bq
  };
  function l(M) {
    return o.noHighlightRe.test(M);
  }
  function c(M) {
    let B = M.className + " ";
    B += M.parentNode ? M.parentNode.className : "";
    const W = o.languageDetectRe.exec(B);
    if (W) {
      const R = C(W[1]);
      return R || (yy(s.replace("{}", W[1])), yy("Falling back to no-highlight mode for this block.", M)), R ? W[1] : "no-highlight";
    }
    return B.split(/\s+/).find((R) => l(R) || C(R));
  }
  function u(M, B, W) {
    let R = "", O = "";
    typeof B == "object" ? (R = M, W = B.ignoreIllegals, O = B.language) : (Yi("10.7.0", "highlight(lang, code, ...args) has been deprecated."), Yi("10.7.0", `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`), O = M, R = B), W === void 0 && (W = !0);
    const N = {
      code: R,
      language: O
    };
    P("before:highlight", N);
    const z = N.result ? N.result : f(N.language, N.code, W);
    return z.code = N.code, P("after:highlight", z), z;
  }
  function f(M, B, W, R) {
    const O = /* @__PURE__ */ Object.create(null);
    function N(J, ne) {
      return J.keywords[ne];
    }
    function z() {
      if (!ce.keywords) {
        xe.addText(he);
        return;
      }
      let J = 0;
      ce.keywordPatternRe.lastIndex = 0;
      let ne = ce.keywordPatternRe.exec(he), me = "";
      for (; ne; ) {
        me += he.substring(J, ne.index);
        const we = Ke.case_insensitive ? ne[0].toLowerCase() : ne[0], ze = N(ce, we);
        if (ze) {
          const [ht, Yr] = ze;
          if (xe.addText(me), me = "", O[we] = (O[we] || 0) + 1, O[we] <= lG && (ft += Yr), ht.startsWith("_"))
            me += ne[0];
          else {
            const xr = Ke.classNameAliases[ht] || ht;
            ee(ne[0], xr);
          }
        } else
          me += ne[0];
        J = ce.keywordPatternRe.lastIndex, ne = ce.keywordPatternRe.exec(he);
      }
      me += he.substring(J), xe.addText(me);
    }
    function I() {
      if (he === "")
        return;
      let J = null;
      if (typeof ce.subLanguage == "string") {
        if (!t[ce.subLanguage]) {
          xe.addText(he);
          return;
        }
        J = f(ce.subLanguage, he, !0, xt[ce.subLanguage]), xt[ce.subLanguage] = /** @type {CompiledMode} */
        J._top;
      } else
        J = h(he, ce.subLanguage.length ? ce.subLanguage : null);
      ce.relevance > 0 && (ft += J.relevance), xe.__addSublanguage(J._emitter, J.language);
    }
    function te() {
      ce.subLanguage != null ? I() : z(), he = "";
    }
    function ee(J, ne) {
      J !== "" && (xe.startScope(ne), xe.addText(J), xe.endScope());
    }
    function _e(J, ne) {
      let me = 1;
      const we = ne.length - 1;
      for (; me <= we; ) {
        if (!J._emit[me]) {
          me++;
          continue;
        }
        const ze = Ke.classNameAliases[J[me]] || J[me], ht = ne[me];
        ze ? ee(ht, ze) : (he = ht, z(), he = ""), me++;
      }
    }
    function re(J, ne) {
      return J.scope && typeof J.scope == "string" && xe.openNode(Ke.classNameAliases[J.scope] || J.scope), J.beginScope && (J.beginScope._wrap ? (ee(he, Ke.classNameAliases[J.beginScope._wrap] || J.beginScope._wrap), he = "") : J.beginScope._multi && (_e(J.beginScope, ne), he = "")), ce = Object.create(J, { parent: { value: ce } }), ce;
    }
    function Ae(J, ne, me) {
      let we = Eq(J.endRe, me);
      if (we) {
        if (J["on:end"]) {
          const ze = new py(J);
          J["on:end"](ne, ze), ze.isMatchIgnored && (we = !1);
        }
        if (we) {
          for (; J.endsParent && J.parent; )
            J = J.parent;
          return J;
        }
      }
      if (J.endsWithParent)
        return Ae(J.parent, ne, me);
    }
    function st(J) {
      return ce.matcher.regexIndex === 0 ? (he += J[0], 1) : ($t = !0, 0);
    }
    function ut(J) {
      const ne = J[0], me = J.rule, we = new py(me), ze = [me.__beforeBegin, me["on:begin"]];
      for (const ht of ze)
        if (ht && (ht(J, we), we.isMatchIgnored))
          return st(ne);
      return me.skip ? he += ne : (me.excludeBegin && (he += ne), te(), !me.returnBegin && !me.excludeBegin && (he = ne)), re(me, J), me.returnBegin ? 0 : ne.length;
    }
    function yt(J) {
      const ne = J[0], me = B.substring(J.index), we = Ae(ce, J, me);
      if (!we)
        return by;
      const ze = ce;
      ce.endScope && ce.endScope._wrap ? (te(), ee(ne, ce.endScope._wrap)) : ce.endScope && ce.endScope._multi ? (te(), _e(ce.endScope, J)) : ze.skip ? he += ne : (ze.returnEnd || ze.excludeEnd || (he += ne), te(), ze.excludeEnd && (he = ne));
      do
        ce.scope && xe.closeNode(), !ce.skip && !ce.subLanguage && (ft += ce.relevance), ce = ce.parent;
      while (ce !== we.parent);
      return we.starts && re(we.starts, J), ze.returnEnd ? 0 : ne.length;
    }
    function He() {
      const J = [];
      for (let ne = ce; ne !== Ke; ne = ne.parent)
        ne.scope && J.unshift(ne.scope);
      J.forEach((ne) => xe.openNode(ne));
    }
    let We = {};
    function wt(J, ne) {
      const me = ne && ne[0];
      if (he += J, me == null)
        return te(), 0;
      if (We.type === "begin" && ne.type === "end" && We.index === ne.index && me === "") {
        if (he += B.slice(ne.index, ne.index + 1), !i) {
          const we = new Error(`0 width match regex (${M})`);
          throw we.languageName = M, we.badRule = We.rule, we;
        }
        return 1;
      }
      if (We = ne, ne.type === "begin")
        return ut(ne);
      if (ne.type === "illegal" && !W) {
        const we = new Error('Illegal lexeme "' + me + '" for mode "' + (ce.scope || "<unnamed>") + '"');
        throw we.mode = ce, we;
      } else if (ne.type === "end") {
        const we = yt(ne);
        if (we !== by)
          return we;
      }
      if (ne.type === "illegal" && me === "")
        return 1;
      if (Ft > 1e5 && Ft > ne.index * 3)
        throw new Error("potential infinite loop, way more iterations than matches");
      return he += me, me.length;
    }
    const Ke = C(M);
    if (!Ke)
      throw di(s.replace("{}", M)), new Error('Unknown language: "' + M + '"');
    const Ht = iG(Ke);
    let Tt = "", ce = R || Ht;
    const xt = {}, xe = new o.__emitter(o);
    He();
    let he = "", ft = 0, dt = 0, Ft = 0, $t = !1;
    try {
      if (Ke.__emitTokens)
        Ke.__emitTokens(B, xe);
      else {
        for (ce.matcher.considerAll(); ; ) {
          Ft++, $t ? $t = !1 : ce.matcher.considerAll(), ce.matcher.lastIndex = dt;
          const J = ce.matcher.exec(B);
          if (!J)
            break;
          const ne = B.substring(dt, J.index), me = wt(ne, J);
          dt = J.index + me;
        }
        wt(B.substring(dt));
      }
      return xe.finalize(), Tt = xe.toHTML(), {
        language: M,
        value: Tt,
        relevance: ft,
        illegal: !1,
        _emitter: xe,
        _top: ce
      };
    } catch (J) {
      if (J.message && J.message.includes("Illegal"))
        return {
          language: M,
          value: uf(B),
          illegal: !0,
          relevance: 0,
          _illegalBy: {
            message: J.message,
            index: dt,
            context: B.slice(dt - 100, dt + 100),
            mode: J.mode,
            resultSoFar: Tt
          },
          _emitter: xe
        };
      if (i)
        return {
          language: M,
          value: uf(B),
          illegal: !1,
          relevance: 0,
          errorRaised: J,
          _emitter: xe,
          _top: ce
        };
      throw J;
    }
  }
  function d(M) {
    const B = {
      value: uf(M),
      illegal: !1,
      relevance: 0,
      _top: a,
      _emitter: new o.__emitter(o)
    };
    return B._emitter.addText(M), B;
  }
  function h(M, B) {
    B = B || o.languages || Object.keys(t);
    const W = d(M), R = B.filter(C).filter(k).map(
      (te) => f(te, M, !1)
    );
    R.unshift(W);
    const O = R.sort((te, ee) => {
      if (te.relevance !== ee.relevance)
        return ee.relevance - te.relevance;
      if (te.language && ee.language) {
        if (C(te.language).supersetOf === ee.language)
          return 1;
        if (C(ee.language).supersetOf === te.language)
          return -1;
      }
      return 0;
    }), [N, z] = O, I = N;
    return I.secondBest = z, I;
  }
  function p(M, B, W) {
    const R = B && n[B] || W;
    M.classList.add("hljs"), M.classList.add(`language-${R}`);
  }
  function g(M) {
    let B = null;
    const W = c(M);
    if (l(W))
      return;
    if (P(
      "before:highlightElement",
      { el: M, language: W }
    ), M.dataset.highlighted) {
      console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.", M);
      return;
    }
    if (M.children.length > 0 && (o.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."), console.warn("https://github.com/highlightjs/highlight.js/wiki/security"), console.warn("The element with unescaped HTML:"), console.warn(M)), o.throwUnescapedHTML))
      throw new oG(
        "One of your code blocks includes unescaped HTML.",
        M.innerHTML
      );
    B = M;
    const R = B.textContent, O = W ? u(R, { language: W, ignoreIllegals: !0 }) : h(R);
    M.innerHTML = O.value, M.dataset.highlighted = "yes", p(M, W, O.language), M.result = {
      language: O.language,
      // TODO: remove with version 11.0
      re: O.relevance,
      relevance: O.relevance
    }, O.secondBest && (M.secondBest = {
      language: O.secondBest.language,
      relevance: O.secondBest.relevance
    }), P("after:highlightElement", { el: M, result: O, text: R });
  }
  function v(M) {
    o = xy(o, M);
  }
  const m = () => {
    y(), Yi("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
  };
  function x() {
    y(), Yi("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
  }
  let _ = !1;
  function y() {
    if (document.readyState === "loading") {
      _ = !0;
      return;
    }
    document.querySelectorAll(o.cssSelector).forEach(g);
  }
  function b() {
    _ && y();
  }
  typeof window < "u" && window.addEventListener && window.addEventListener("DOMContentLoaded", b, !1);
  function w(M, B) {
    let W = null;
    try {
      W = B(e);
    } catch (R) {
      if (di("Language definition for '{}' could not be registered.".replace("{}", M)), i)
        di(R);
      else
        throw R;
      W = a;
    }
    W.name || (W.name = M), t[M] = W, W.rawDefinition = B.bind(null, e), W.aliases && A(W.aliases, { languageName: M });
  }
  function E(M) {
    delete t[M];
    for (const B of Object.keys(n))
      n[B] === M && delete n[B];
  }
  function $() {
    return Object.keys(t);
  }
  function C(M) {
    return M = (M || "").toLowerCase(), t[M] || t[n[M]];
  }
  function A(M, { languageName: B }) {
    typeof M == "string" && (M = [M]), M.forEach((W) => {
      n[W.toLowerCase()] = B;
    });
  }
  function k(M) {
    const B = C(M);
    return B && !B.disableAutodetect;
  }
  function D(M) {
    M["before:highlightBlock"] && !M["before:highlightElement"] && (M["before:highlightElement"] = (B) => {
      M["before:highlightBlock"](
        Object.assign({ block: B.el }, B)
      );
    }), M["after:highlightBlock"] && !M["after:highlightElement"] && (M["after:highlightElement"] = (B) => {
      M["after:highlightBlock"](
        Object.assign({ block: B.el }, B)
      );
    });
  }
  function S(M) {
    D(M), r.push(M);
  }
  function L(M) {
    const B = r.indexOf(M);
    B !== -1 && r.splice(B, 1);
  }
  function P(M, B) {
    const W = M;
    r.forEach(function(R) {
      R[W] && R[W](B);
    });
  }
  function H(M) {
    return Yi("10.7.0", "highlightBlock will be removed entirely in v12.0"), Yi("10.7.0", "Please use highlightElement now."), g(M);
  }
  Object.assign(e, {
    highlight: u,
    highlightAuto: h,
    highlightAll: y,
    highlightElement: g,
    // TODO: Remove with v12 API
    highlightBlock: H,
    configure: v,
    initHighlighting: m,
    initHighlightingOnLoad: x,
    registerLanguage: w,
    unregisterLanguage: E,
    listLanguages: $,
    getLanguage: C,
    registerAliases: A,
    autoDetection: k,
    inherit: xy,
    addPlugin: S,
    removePlugin: L
  }), e.debugMode = function() {
    i = !1;
  }, e.safeMode = function() {
    i = !0;
  }, e.versionString = aG, e.regex = {
    concat: Pi,
    lookahead: W2,
    either: Xh,
    optional: wq,
    anyNumberOfTimes: _q
  };
  for (const M in dl)
    typeof dl[M] == "object" && V2(dl[M]);
  return Object.assign(e, dl), e;
}, Cs = Q2({});
Cs.newInstance = () => Q2({});
var cG = Cs;
Cs.HighlightJS = Cs;
Cs.default = Cs;
const fa = /* @__PURE__ */ Vr(cG);
function uG(e) {
  const t = e.regex, n = t.concat(/[\p{L}_]/u, t.optional(/[\p{L}0-9_.-]*:/u), /[\p{L}0-9_.-]*/u), r = /[\p{L}0-9._:-]+/u, i = {
    className: "symbol",
    begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
  }, s = {
    begin: /\s/,
    contains: [
      {
        className: "keyword",
        begin: /#?[a-z_][a-z1-9_-]+/,
        illegal: /\n/
      }
    ]
  }, a = e.inherit(s, {
    begin: /\(/,
    end: /\)/
  }), o = e.inherit(e.APOS_STRING_MODE, { className: "string" }), l = e.inherit(e.QUOTE_STRING_MODE, { className: "string" }), c = {
    endsWithParent: !0,
    illegal: /</,
    relevance: 0,
    contains: [
      {
        className: "attr",
        begin: r,
        relevance: 0
      },
      {
        begin: /=\s*/,
        relevance: 0,
        contains: [
          {
            className: "string",
            endsParent: !0,
            variants: [
              {
                begin: /"/,
                end: /"/,
                contains: [i]
              },
              {
                begin: /'/,
                end: /'/,
                contains: [i]
              },
              { begin: /[^\s"'=<>`]+/ }
            ]
          }
        ]
      }
    ]
  };
  return {
    name: "HTML, XML",
    aliases: [
      "html",
      "xhtml",
      "rss",
      "atom",
      "xjb",
      "xsd",
      "xsl",
      "plist",
      "wsf",
      "svg"
    ],
    case_insensitive: !0,
    unicodeRegex: !0,
    contains: [
      {
        className: "meta",
        begin: /<![a-z]/,
        end: />/,
        relevance: 10,
        contains: [
          s,
          l,
          o,
          a,
          {
            begin: /\[/,
            end: /\]/,
            contains: [
              {
                className: "meta",
                begin: /<![a-z]/,
                end: />/,
                contains: [
                  s,
                  a,
                  l,
                  o
                ]
              }
            ]
          }
        ]
      },
      e.COMMENT(
        /<!--/,
        /-->/,
        { relevance: 10 }
      ),
      {
        begin: /<!\[CDATA\[/,
        end: /\]\]>/,
        relevance: 10
      },
      i,
      // xml processing instructions
      {
        className: "meta",
        end: /\?>/,
        variants: [
          {
            begin: /<\?xml/,
            relevance: 10,
            contains: [
              l
            ]
          },
          {
            begin: /<\?[a-z][a-z0-9]+/
          }
        ]
      },
      {
        className: "tag",
        /*
        The lookahead pattern (?=...) ensures that 'begin' only matches
        '<style' as a single word, followed by a whitespace or an
        ending bracket.
        */
        begin: /<style(?=\s|>)/,
        end: />/,
        keywords: { name: "style" },
        contains: [c],
        starts: {
          end: /<\/style>/,
          returnEnd: !0,
          subLanguage: [
            "css",
            "xml"
          ]
        }
      },
      {
        className: "tag",
        // See the comment in the <style tag about the lookahead pattern
        begin: /<script(?=\s|>)/,
        end: />/,
        keywords: { name: "script" },
        contains: [c],
        starts: {
          end: /<\/script>/,
          returnEnd: !0,
          subLanguage: [
            "javascript",
            "handlebars",
            "xml"
          ]
        }
      },
      // we need this for now for jSX
      {
        className: "tag",
        begin: /<>|<\/>/
      },
      // open tag
      {
        className: "tag",
        begin: t.concat(
          /</,
          t.lookahead(t.concat(
            n,
            // <tag/>
            // <tag>
            // <tag ...
            t.either(/\/>/, />/, /\s/)
          ))
        ),
        end: /\/?>/,
        contains: [
          {
            className: "name",
            begin: n,
            relevance: 0,
            starts: c
          }
        ]
      },
      // close tag
      {
        className: "tag",
        begin: t.concat(
          /<\//,
          t.lookahead(t.concat(
            n,
            />/
          ))
        ),
        contains: [
          {
            className: "name",
            begin: n,
            relevance: 0
          },
          {
            begin: />/,
            relevance: 0,
            endsParent: !0
          }
        ]
      }
    ]
  };
}
const _y = "[A-Za-z$_][0-9A-Za-z$_]*", fG = [
  "as",
  // for exports
  "in",
  "of",
  "if",
  "for",
  "while",
  "finally",
  "var",
  "new",
  "function",
  "do",
  "return",
  "void",
  "else",
  "break",
  "catch",
  "instanceof",
  "with",
  "throw",
  "case",
  "default",
  "try",
  "switch",
  "continue",
  "typeof",
  "delete",
  "let",
  "yield",
  "const",
  "class",
  // JS handles these with a special rule
  // "get",
  // "set",
  "debugger",
  "async",
  "await",
  "static",
  "import",
  "from",
  "export",
  "extends"
], dG = [
  "true",
  "false",
  "null",
  "undefined",
  "NaN",
  "Infinity"
], e$ = [
  // Fundamental objects
  "Object",
  "Function",
  "Boolean",
  "Symbol",
  // numbers and dates
  "Math",
  "Date",
  "Number",
  "BigInt",
  // text
  "String",
  "RegExp",
  // Indexed collections
  "Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Int32Array",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array",
  // Keyed collections
  "Set",
  "Map",
  "WeakSet",
  "WeakMap",
  // Structured data
  "ArrayBuffer",
  "SharedArrayBuffer",
  "Atomics",
  "DataView",
  "JSON",
  // Control abstraction objects
  "Promise",
  "Generator",
  "GeneratorFunction",
  "AsyncFunction",
  // Reflection
  "Reflect",
  "Proxy",
  // Internationalization
  "Intl",
  // WebAssembly
  "WebAssembly"
], t$ = [
  "Error",
  "EvalError",
  "InternalError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "TypeError",
  "URIError"
], n$ = [
  "setInterval",
  "setTimeout",
  "clearInterval",
  "clearTimeout",
  "require",
  "exports",
  "eval",
  "isFinite",
  "isNaN",
  "parseFloat",
  "parseInt",
  "decodeURI",
  "decodeURIComponent",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "unescape"
], hG = [
  "arguments",
  "this",
  "super",
  "console",
  "window",
  "document",
  "localStorage",
  "sessionStorage",
  "module",
  "global"
  // Node.js
], pG = [].concat(
  n$,
  e$,
  t$
);
function gG(e) {
  const t = e.regex, n = (B, { after: W }) => {
    const R = "</" + B[0].slice(1);
    return B.input.indexOf(R, W) !== -1;
  }, r = _y, i = {
    begin: "<>",
    end: "</>"
  }, s = /<[A-Za-z0-9\\._:-]+\s*\/>/, a = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    /**
     * @param {RegExpMatchArray} match
     * @param {CallbackResponse} response
     */
    isTrulyOpeningTag: (B, W) => {
      const R = B[0].length + B.index, O = B.input[R];
      if (
        // HTML should not include another raw `<` inside a tag
        // nested type?
        // `<Array<Array<number>>`, etc.
        O === "<" || // the , gives away that this is not HTML
        // `<T, A extends keyof T, V>`
        O === ","
      ) {
        W.ignoreMatch();
        return;
      }
      O === ">" && (n(B, { after: R }) || W.ignoreMatch());
      let N;
      const z = B.input.substring(R);
      if (N = z.match(/^\s*=/)) {
        W.ignoreMatch();
        return;
      }
      if ((N = z.match(/^\s+extends\s+/)) && N.index === 0) {
        W.ignoreMatch();
        return;
      }
    }
  }, o = {
    $pattern: _y,
    keyword: fG,
    literal: dG,
    built_in: pG,
    "variable.language": hG
  }, l = "[0-9](_?[0-9])*", c = `\\.(${l})`, u = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", f = {
    className: "number",
    variants: [
      // DecimalLiteral
      { begin: `(\\b(${u})((${c})|\\.)?|(${c}))[eE][+-]?(${l})\\b` },
      { begin: `\\b(${u})\\b((${c})\\b|\\.)?|(${c})\\b` },
      // DecimalBigIntegerLiteral
      { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
      // NonDecimalIntegerLiteral
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
      // LegacyOctalIntegerLiteral (does not include underscore separators)
      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
      { begin: "\\b0[0-7]+n?\\b" }
    ],
    relevance: 0
  }, d = {
    className: "subst",
    begin: "\\$\\{",
    end: "\\}",
    keywords: o,
    contains: []
    // defined later
  }, h = {
    begin: "html`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        e.BACKSLASH_ESCAPE,
        d
      ],
      subLanguage: "xml"
    }
  }, p = {
    begin: "css`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        e.BACKSLASH_ESCAPE,
        d
      ],
      subLanguage: "css"
    }
  }, g = {
    begin: "gql`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        e.BACKSLASH_ESCAPE,
        d
      ],
      subLanguage: "graphql"
    }
  }, v = {
    className: "string",
    begin: "`",
    end: "`",
    contains: [
      e.BACKSLASH_ESCAPE,
      d
    ]
  }, x = {
    className: "comment",
    variants: [
      e.COMMENT(
        /\/\*\*(?!\/)/,
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              begin: "(?=@[A-Za-z]+)",
              relevance: 0,
              contains: [
                {
                  className: "doctag",
                  begin: "@[A-Za-z]+"
                },
                {
                  className: "type",
                  begin: "\\{",
                  end: "\\}",
                  excludeEnd: !0,
                  excludeBegin: !0,
                  relevance: 0
                },
                {
                  className: "variable",
                  begin: r + "(?=\\s*(-)|$)",
                  endsParent: !0,
                  relevance: 0
                },
                // eat spaces (not newlines) so we can find
                // types or variables
                {
                  begin: /(?=[^\n])\s/,
                  relevance: 0
                }
              ]
            }
          ]
        }
      ),
      e.C_BLOCK_COMMENT_MODE,
      e.C_LINE_COMMENT_MODE
    ]
  }, _ = [
    e.APOS_STRING_MODE,
    e.QUOTE_STRING_MODE,
    h,
    p,
    g,
    v,
    // Skip numbers when they are part of a variable name
    { match: /\$\d+/ },
    f
    // This is intentional:
    // See https://github.com/highlightjs/highlight.js/issues/3288
    // hljs.REGEXP_MODE
  ];
  d.contains = _.concat({
    // we need to pair up {} inside our subst to prevent
    // it from ending too early by matching another }
    begin: /\{/,
    end: /\}/,
    keywords: o,
    contains: [
      "self"
    ].concat(_)
  });
  const y = [].concat(x, d.contains), b = y.concat([
    // eat recursive parens in sub expressions
    {
      begin: /\(/,
      end: /\)/,
      keywords: o,
      contains: ["self"].concat(y)
    }
  ]), w = {
    className: "params",
    begin: /\(/,
    end: /\)/,
    excludeBegin: !0,
    excludeEnd: !0,
    keywords: o,
    contains: b
  }, E = {
    variants: [
      // class Car extends vehicle
      {
        match: [
          /class/,
          /\s+/,
          r,
          /\s+/,
          /extends/,
          /\s+/,
          t.concat(r, "(", t.concat(/\./, r), ")*")
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          5: "keyword",
          7: "title.class.inherited"
        }
      },
      // class Car
      {
        match: [
          /class/,
          /\s+/,
          r
        ],
        scope: {
          1: "keyword",
          3: "title.class"
        }
      }
    ]
  }, $ = {
    relevance: 0,
    match: t.either(
      // Hard coded exceptions
      /\bJSON/,
      // Float32Array, OutT
      /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
      // CSSFactory, CSSFactoryT
      /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
      // FPs, FPsT
      /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
      // P
      // single letters are not highlighted
      // BLAH
      // this will be flagged as a UPPER_CASE_CONSTANT instead
    ),
    className: "title.class",
    keywords: {
      _: [
        // se we still get relevance credit for JS library classes
        ...e$,
        ...t$
      ]
    }
  }, C = {
    label: "use_strict",
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use (strict|asm)['"]/
  }, A = {
    variants: [
      {
        match: [
          /function/,
          /\s+/,
          r,
          /(?=\s*\()/
        ]
      },
      // anonymous function
      {
        match: [
          /function/,
          /\s*(?=\()/
        ]
      }
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    label: "func.def",
    contains: [w],
    illegal: /%/
  }, k = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: "variable.constant"
  };
  function D(B) {
    return t.concat("(?!", B.join("|"), ")");
  }
  const S = {
    match: t.concat(
      /\b/,
      D([
        ...n$,
        "super",
        "import"
      ]),
      r,
      t.lookahead(/\(/)
    ),
    className: "title.function",
    relevance: 0
  }, L = {
    begin: t.concat(/\./, t.lookahead(
      t.concat(r, /(?![0-9A-Za-z$_(])/)
    )),
    end: r,
    excludeBegin: !0,
    keywords: "prototype",
    className: "property",
    relevance: 0
  }, P = {
    match: [
      /get|set/,
      /\s+/,
      r,
      /(?=\()/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      {
        // eat to avoid empty params
        begin: /\(\)/
      },
      w
    ]
  }, H = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + e.UNDERSCORE_IDENT_RE + ")\\s*=>", M = {
    match: [
      /const|var|let/,
      /\s+/,
      r,
      /\s*/,
      /=\s*/,
      /(async\s*)?/,
      // async is optional
      t.lookahead(H)
    ],
    keywords: "async",
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      w
    ]
  };
  return {
    name: "JavaScript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: o,
    // this will be extended by TypeScript
    exports: { PARAMS_CONTAINS: b, CLASS_REFERENCE: $ },
    illegal: /#(?![$_A-z])/,
    contains: [
      e.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }),
      C,
      e.APOS_STRING_MODE,
      e.QUOTE_STRING_MODE,
      h,
      p,
      g,
      v,
      x,
      // Skip numbers when they are part of a variable name
      { match: /\$\d+/ },
      f,
      $,
      {
        className: "attr",
        begin: r + t.lookahead(":"),
        relevance: 0
      },
      M,
      {
        // "value" container
        begin: "(" + e.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [
          x,
          e.REGEXP_MODE,
          {
            className: "function",
            // we have to count the parens to make sure we actually have the
            // correct bounding ( ) before the =>.  There could be any number of
            // sub-expressions inside also surrounded by parens.
            begin: H,
            returnBegin: !0,
            end: "\\s*=>",
            contains: [
              {
                className: "params",
                variants: [
                  {
                    begin: e.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: !0
                  },
                  {
                    begin: /\(/,
                    end: /\)/,
                    excludeBegin: !0,
                    excludeEnd: !0,
                    keywords: o,
                    contains: b
                  }
                ]
              }
            ]
          },
          {
            // could be a comma delimited list of params to a function call
            begin: /,/,
            relevance: 0
          },
          {
            match: /\s+/,
            relevance: 0
          },
          {
            // JSX
            variants: [
              { begin: i.begin, end: i.end },
              { match: s },
              {
                begin: a.begin,
                // we carefully check the opening tag to see if it truly
                // is a tag and not a false positive
                "on:begin": a.isTrulyOpeningTag,
                end: a.end
              }
            ],
            subLanguage: "xml",
            contains: [
              {
                begin: a.begin,
                end: a.end,
                skip: !0,
                contains: ["self"]
              }
            ]
          }
        ]
      },
      A,
      {
        // prevent this from getting swallowed up by function
        // since they appear "function like"
        beginKeywords: "while if switch catch for"
      },
      {
        // we have to count the parens to make sure we actually have the correct
        // bounding ( ).  There could be any number of sub-expressions inside
        // also surrounded by parens.
        begin: "\\b(?!function)" + e.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        // end parens
        returnBegin: !0,
        label: "func.def",
        contains: [
          w,
          e.inherit(e.TITLE_MODE, { begin: r, className: "title.function" })
        ]
      },
      // catch ... so it won't trigger the property rule below
      {
        match: /\.\.\./,
        relevance: 0
      },
      L,
      // hack: prevents detection of keywords in some circumstances
      // .keyword()
      // $keyword = x
      {
        match: "\\$" + r,
        relevance: 0
      },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: "title.function" },
        contains: [w]
      },
      S,
      k,
      E,
      P,
      {
        match: /\$[(.]/
        // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
      }
    ]
  };
}
function Jh() {
  return {
    async: !1,
    breaks: !1,
    extensions: null,
    gfm: !0,
    hooks: null,
    pedantic: !1,
    renderer: null,
    silent: !1,
    tokenizer: null,
    walkTokens: null
  };
}
let Ii = Jh();
function r$(e) {
  Ii = e;
}
const i$ = /[&<>"']/, vG = new RegExp(i$.source, "g"), s$ = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/, mG = new RegExp(s$.source, "g"), yG = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
}, wy = (e) => yG[e];
function tn(e, t) {
  if (t) {
    if (i$.test(e))
      return e.replace(vG, wy);
  } else if (s$.test(e))
    return e.replace(mG, wy);
  return e;
}
const xG = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
function bG(e) {
  return e.replace(xG, (t, n) => (n = n.toLowerCase(), n === "colon" ? ":" : n.charAt(0) === "#" ? n.charAt(1) === "x" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1)) : ""));
}
const _G = /(^|[^\[])\^/g;
function je(e, t) {
  let n = typeof e == "string" ? e : e.source;
  t = t || "";
  const r = {
    replace: (i, s) => {
      let a = typeof s == "string" ? s : s.source;
      return a = a.replace(_G, "$1"), n = n.replace(i, a), r;
    },
    getRegex: () => new RegExp(n, t)
  };
  return r;
}
function $y(e) {
  try {
    e = encodeURI(e).replace(/%25/g, "%");
  } catch {
    return null;
  }
  return e;
}
const Fa = { exec: () => null };
function Ey(e, t) {
  const n = e.replace(/\|/g, (s, a, o) => {
    let l = !1, c = a;
    for (; --c >= 0 && o[c] === "\\"; )
      l = !l;
    return l ? "|" : " |";
  }), r = n.split(/ \|/);
  let i = 0;
  if (r[0].trim() || r.shift(), r.length > 0 && !r[r.length - 1].trim() && r.pop(), t)
    if (r.length > t)
      r.splice(t);
    else
      for (; r.length < t; )
        r.push("");
  for (; i < r.length; i++)
    r[i] = r[i].trim().replace(/\\\|/g, "|");
  return r;
}
function hl(e, t, n) {
  const r = e.length;
  if (r === 0)
    return "";
  let i = 0;
  for (; i < r; ) {
    const s = e.charAt(r - i - 1);
    if (s === t && !n)
      i++;
    else if (s !== t && n)
      i++;
    else
      break;
  }
  return e.slice(0, r - i);
}
function wG(e, t) {
  if (e.indexOf(t[1]) === -1)
    return -1;
  let n = 0;
  for (let r = 0; r < e.length; r++)
    if (e[r] === "\\")
      r++;
    else if (e[r] === t[0])
      n++;
    else if (e[r] === t[1] && (n--, n < 0))
      return r;
  return -1;
}
function Ay(e, t, n, r) {
  const i = t.href, s = t.title ? tn(t.title) : null, a = e[1].replace(/\\([\[\]])/g, "$1");
  if (e[0].charAt(0) !== "!") {
    r.state.inLink = !0;
    const o = {
      type: "link",
      raw: n,
      href: i,
      title: s,
      text: a,
      tokens: r.inlineTokens(a)
    };
    return r.state.inLink = !1, o;
  }
  return {
    type: "image",
    raw: n,
    href: i,
    title: s,
    text: tn(a)
  };
}
function $G(e, t) {
  const n = e.match(/^(\s+)(?:```)/);
  if (n === null)
    return t;
  const r = n[1];
  return t.split(`
`).map((i) => {
    const s = i.match(/^\s+/);
    if (s === null)
      return i;
    const [a] = s;
    return a.length >= r.length ? i.slice(r.length) : i;
  }).join(`
`);
}
class Tc {
  // set by the lexer
  constructor(t) {
    V(this, "options");
    V(this, "rules");
    // set by the lexer
    V(this, "lexer");
    this.options = t || Ii;
  }
  space(t) {
    const n = this.rules.block.newline.exec(t);
    if (n && n[0].length > 0)
      return {
        type: "space",
        raw: n[0]
      };
  }
  code(t) {
    const n = this.rules.block.code.exec(t);
    if (n) {
      const r = n[0].replace(/^ {1,4}/gm, "");
      return {
        type: "code",
        raw: n[0],
        codeBlockStyle: "indented",
        text: this.options.pedantic ? r : hl(r, `
`)
      };
    }
  }
  fences(t) {
    const n = this.rules.block.fences.exec(t);
    if (n) {
      const r = n[0], i = $G(r, n[3] || "");
      return {
        type: "code",
        raw: r,
        lang: n[2] ? n[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : n[2],
        text: i
      };
    }
  }
  heading(t) {
    const n = this.rules.block.heading.exec(t);
    if (n) {
      let r = n[2].trim();
      if (/#$/.test(r)) {
        const i = hl(r, "#");
        (this.options.pedantic || !i || / $/.test(i)) && (r = i.trim());
      }
      return {
        type: "heading",
        raw: n[0],
        depth: n[1].length,
        text: r,
        tokens: this.lexer.inline(r)
      };
    }
  }
  hr(t) {
    const n = this.rules.block.hr.exec(t);
    if (n)
      return {
        type: "hr",
        raw: n[0]
      };
  }
  blockquote(t) {
    const n = this.rules.block.blockquote.exec(t);
    if (n) {
      const r = hl(n[0].replace(/^ *>[ \t]?/gm, ""), `
`), i = this.lexer.state.top;
      this.lexer.state.top = !0;
      const s = this.lexer.blockTokens(r);
      return this.lexer.state.top = i, {
        type: "blockquote",
        raw: n[0],
        tokens: s,
        text: r
      };
    }
  }
  list(t) {
    let n = this.rules.block.list.exec(t);
    if (n) {
      let r = n[1].trim();
      const i = r.length > 1, s = {
        type: "list",
        raw: "",
        ordered: i,
        start: i ? +r.slice(0, -1) : "",
        loose: !1,
        items: []
      };
      r = i ? `\\d{1,9}\\${r.slice(-1)}` : `\\${r}`, this.options.pedantic && (r = i ? r : "[*+-]");
      const a = new RegExp(`^( {0,3}${r})((?:[	 ][^\\n]*)?(?:\\n|$))`);
      let o = "", l = "", c = !1;
      for (; t; ) {
        let u = !1;
        if (!(n = a.exec(t)) || this.rules.block.hr.test(t))
          break;
        o = n[0], t = t.substring(o.length);
        let f = n[2].split(`
`, 1)[0].replace(/^\t+/, (m) => " ".repeat(3 * m.length)), d = t.split(`
`, 1)[0], h = 0;
        this.options.pedantic ? (h = 2, l = f.trimStart()) : (h = n[2].search(/[^ ]/), h = h > 4 ? 1 : h, l = f.slice(h), h += n[1].length);
        let p = !1;
        if (!f && /^ *$/.test(d) && (o += d + `
`, t = t.substring(d.length + 1), u = !0), !u) {
          const m = new RegExp(`^ {0,${Math.min(3, h - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`), x = new RegExp(`^ {0,${Math.min(3, h - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`), _ = new RegExp(`^ {0,${Math.min(3, h - 1)}}(?:\`\`\`|~~~)`), y = new RegExp(`^ {0,${Math.min(3, h - 1)}}#`);
          for (; t; ) {
            const b = t.split(`
`, 1)[0];
            if (d = b, this.options.pedantic && (d = d.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ")), _.test(d) || y.test(d) || m.test(d) || x.test(t))
              break;
            if (d.search(/[^ ]/) >= h || !d.trim())
              l += `
` + d.slice(h);
            else {
              if (p || f.search(/[^ ]/) >= 4 || _.test(f) || y.test(f) || x.test(f))
                break;
              l += `
` + d;
            }
            !p && !d.trim() && (p = !0), o += b + `
`, t = t.substring(b.length + 1), f = d.slice(h);
          }
        }
        s.loose || (c ? s.loose = !0 : /\n *\n *$/.test(o) && (c = !0));
        let g = null, v;
        this.options.gfm && (g = /^\[[ xX]\] /.exec(l), g && (v = g[0] !== "[ ] ", l = l.replace(/^\[[ xX]\] +/, ""))), s.items.push({
          type: "list_item",
          raw: o,
          task: !!g,
          checked: v,
          loose: !1,
          text: l,
          tokens: []
        }), s.raw += o;
      }
      s.items[s.items.length - 1].raw = o.trimEnd(), s.items[s.items.length - 1].text = l.trimEnd(), s.raw = s.raw.trimEnd();
      for (let u = 0; u < s.items.length; u++)
        if (this.lexer.state.top = !1, s.items[u].tokens = this.lexer.blockTokens(s.items[u].text, []), !s.loose) {
          const f = s.items[u].tokens.filter((h) => h.type === "space"), d = f.length > 0 && f.some((h) => /\n.*\n/.test(h.raw));
          s.loose = d;
        }
      if (s.loose)
        for (let u = 0; u < s.items.length; u++)
          s.items[u].loose = !0;
      return s;
    }
  }
  html(t) {
    const n = this.rules.block.html.exec(t);
    if (n)
      return {
        type: "html",
        block: !0,
        raw: n[0],
        pre: n[1] === "pre" || n[1] === "script" || n[1] === "style",
        text: n[0]
      };
  }
  def(t) {
    const n = this.rules.block.def.exec(t);
    if (n) {
      const r = n[1].toLowerCase().replace(/\s+/g, " "), i = n[2] ? n[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "", s = n[3] ? n[3].substring(1, n[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : n[3];
      return {
        type: "def",
        tag: r,
        raw: n[0],
        href: i,
        title: s
      };
    }
  }
  table(t) {
    const n = this.rules.block.table.exec(t);
    if (!n || !/[:|]/.test(n[2]))
      return;
    const r = Ey(n[1]), i = n[2].replace(/^\||\| *$/g, "").split("|"), s = n[3] && n[3].trim() ? n[3].replace(/\n[ \t]*$/, "").split(`
`) : [], a = {
      type: "table",
      raw: n[0],
      header: [],
      align: [],
      rows: []
    };
    if (r.length === i.length) {
      for (const o of i)
        /^ *-+: *$/.test(o) ? a.align.push("right") : /^ *:-+: *$/.test(o) ? a.align.push("center") : /^ *:-+ *$/.test(o) ? a.align.push("left") : a.align.push(null);
      for (const o of r)
        a.header.push({
          text: o,
          tokens: this.lexer.inline(o)
        });
      for (const o of s)
        a.rows.push(Ey(o, a.header.length).map((l) => ({
          text: l,
          tokens: this.lexer.inline(l)
        })));
      return a;
    }
  }
  lheading(t) {
    const n = this.rules.block.lheading.exec(t);
    if (n)
      return {
        type: "heading",
        raw: n[0],
        depth: n[2].charAt(0) === "=" ? 1 : 2,
        text: n[1],
        tokens: this.lexer.inline(n[1])
      };
  }
  paragraph(t) {
    const n = this.rules.block.paragraph.exec(t);
    if (n) {
      const r = n[1].charAt(n[1].length - 1) === `
` ? n[1].slice(0, -1) : n[1];
      return {
        type: "paragraph",
        raw: n[0],
        text: r,
        tokens: this.lexer.inline(r)
      };
    }
  }
  text(t) {
    const n = this.rules.block.text.exec(t);
    if (n)
      return {
        type: "text",
        raw: n[0],
        text: n[0],
        tokens: this.lexer.inline(n[0])
      };
  }
  escape(t) {
    const n = this.rules.inline.escape.exec(t);
    if (n)
      return {
        type: "escape",
        raw: n[0],
        text: tn(n[1])
      };
  }
  tag(t) {
    const n = this.rules.inline.tag.exec(t);
    if (n)
      return !this.lexer.state.inLink && /^<a /i.test(n[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && /^<\/a>/i.test(n[0]) && (this.lexer.state.inLink = !1), !this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(n[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(n[0]) && (this.lexer.state.inRawBlock = !1), {
        type: "html",
        raw: n[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        block: !1,
        text: n[0]
      };
  }
  link(t) {
    const n = this.rules.inline.link.exec(t);
    if (n) {
      const r = n[2].trim();
      if (!this.options.pedantic && /^</.test(r)) {
        if (!/>$/.test(r))
          return;
        const a = hl(r.slice(0, -1), "\\");
        if ((r.length - a.length) % 2 === 0)
          return;
      } else {
        const a = wG(n[2], "()");
        if (a > -1) {
          const l = (n[0].indexOf("!") === 0 ? 5 : 4) + n[1].length + a;
          n[2] = n[2].substring(0, a), n[0] = n[0].substring(0, l).trim(), n[3] = "";
        }
      }
      let i = n[2], s = "";
      if (this.options.pedantic) {
        const a = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(i);
        a && (i = a[1], s = a[3]);
      } else
        s = n[3] ? n[3].slice(1, -1) : "";
      return i = i.trim(), /^</.test(i) && (this.options.pedantic && !/>$/.test(r) ? i = i.slice(1) : i = i.slice(1, -1)), Ay(n, {
        href: i && i.replace(this.rules.inline.anyPunctuation, "$1"),
        title: s && s.replace(this.rules.inline.anyPunctuation, "$1")
      }, n[0], this.lexer);
    }
  }
  reflink(t, n) {
    let r;
    if ((r = this.rules.inline.reflink.exec(t)) || (r = this.rules.inline.nolink.exec(t))) {
      const i = (r[2] || r[1]).replace(/\s+/g, " "), s = n[i.toLowerCase()];
      if (!s) {
        const a = r[0].charAt(0);
        return {
          type: "text",
          raw: a,
          text: a
        };
      }
      return Ay(r, s, r[0], this.lexer);
    }
  }
  emStrong(t, n, r = "") {
    let i = this.rules.inline.emStrongLDelim.exec(t);
    if (!i || i[3] && r.match(/[\p{L}\p{N}]/u))
      return;
    if (!(i[1] || i[2] || "") || !r || this.rules.inline.punctuation.exec(r)) {
      const a = [...i[0]].length - 1;
      let o, l, c = a, u = 0;
      const f = i[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
      for (f.lastIndex = 0, n = n.slice(-1 * t.length + a); (i = f.exec(n)) != null; ) {
        if (o = i[1] || i[2] || i[3] || i[4] || i[5] || i[6], !o)
          continue;
        if (l = [...o].length, i[3] || i[4]) {
          c += l;
          continue;
        } else if ((i[5] || i[6]) && a % 3 && !((a + l) % 3)) {
          u += l;
          continue;
        }
        if (c -= l, c > 0)
          continue;
        l = Math.min(l, l + c + u);
        const d = [...i[0]][0].length, h = t.slice(0, a + i.index + d + l);
        if (Math.min(a, l) % 2) {
          const g = h.slice(1, -1);
          return {
            type: "em",
            raw: h,
            text: g,
            tokens: this.lexer.inlineTokens(g)
          };
        }
        const p = h.slice(2, -2);
        return {
          type: "strong",
          raw: h,
          text: p,
          tokens: this.lexer.inlineTokens(p)
        };
      }
    }
  }
  codespan(t) {
    const n = this.rules.inline.code.exec(t);
    if (n) {
      let r = n[2].replace(/\n/g, " ");
      const i = /[^ ]/.test(r), s = /^ /.test(r) && / $/.test(r);
      return i && s && (r = r.substring(1, r.length - 1)), r = tn(r, !0), {
        type: "codespan",
        raw: n[0],
        text: r
      };
    }
  }
  br(t) {
    const n = this.rules.inline.br.exec(t);
    if (n)
      return {
        type: "br",
        raw: n[0]
      };
  }
  del(t) {
    const n = this.rules.inline.del.exec(t);
    if (n)
      return {
        type: "del",
        raw: n[0],
        text: n[2],
        tokens: this.lexer.inlineTokens(n[2])
      };
  }
  autolink(t) {
    const n = this.rules.inline.autolink.exec(t);
    if (n) {
      let r, i;
      return n[2] === "@" ? (r = tn(n[1]), i = "mailto:" + r) : (r = tn(n[1]), i = r), {
        type: "link",
        raw: n[0],
        text: r,
        href: i,
        tokens: [
          {
            type: "text",
            raw: r,
            text: r
          }
        ]
      };
    }
  }
  url(t) {
    var r;
    let n;
    if (n = this.rules.inline.url.exec(t)) {
      let i, s;
      if (n[2] === "@")
        i = tn(n[0]), s = "mailto:" + i;
      else {
        let a;
        do
          a = n[0], n[0] = ((r = this.rules.inline._backpedal.exec(n[0])) == null ? void 0 : r[0]) ?? "";
        while (a !== n[0]);
        i = tn(n[0]), n[1] === "www." ? s = "http://" + n[0] : s = n[0];
      }
      return {
        type: "link",
        raw: n[0],
        text: i,
        href: s,
        tokens: [
          {
            type: "text",
            raw: i,
            text: i
          }
        ]
      };
    }
  }
  inlineText(t) {
    const n = this.rules.inline.text.exec(t);
    if (n) {
      let r;
      return this.lexer.state.inRawBlock ? r = n[0] : r = tn(n[0]), {
        type: "text",
        raw: n[0],
        text: r
      };
    }
  }
}
const EG = /^(?: *(?:\n|$))+/, AG = /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/, kG = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/, Do = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/, CG = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, a$ = /(?:[*+-]|\d{1,9}[.)])/, o$ = je(/^(?!bull )((?:.|\n(?!\s*?\n|bull ))+?)\n {0,3}(=+|-+) *(?:\n+|$)/).replace(/bull/g, a$).getRegex(), Qh = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/, DG = /^[^\n]+/, ep = /(?!\s*\])(?:\\.|[^\[\]\\])+/, SG = je(/^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/).replace("label", ep).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(), TG = je(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, a$).getRegex(), ku = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", tp = /<!--(?!-?>)[\s\S]*?(?:-->|$)/, OG = je("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))", "i").replace("comment", tp).replace("tag", ku).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), l$ = je(Qh).replace("hr", Do).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", ku).getRegex(), MG = je(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", l$).getRegex(), np = {
  blockquote: MG,
  code: AG,
  def: SG,
  fences: kG,
  heading: CG,
  hr: Do,
  html: OG,
  lheading: o$,
  list: TG,
  newline: EG,
  paragraph: l$,
  table: Fa,
  text: DG
}, ky = je("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", Do).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", ku).getRegex(), FG = {
  ...np,
  table: ky,
  paragraph: je(Qh).replace("hr", Do).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", ky).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", ku).getRegex()
}, PG = {
  ...np,
  html: je(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", tp).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: Fa,
  // fences not supported
  lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  paragraph: je(Qh).replace("hr", Do).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", o$).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex()
}, c$ = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, IG = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, u$ = /^( {2,}|\\)\n(?!\s*$)/, RG = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/, So = "\\p{P}$+<=>`^|~", BG = je(/^((?![*_])[\spunctuation])/, "u").replace(/punctuation/g, So).getRegex(), NG = /\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g, LG = je(/^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/, "u").replace(/punct/g, So).getRegex(), jG = je("^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)[punct](\\*+)(?=[\\s]|$)|[^punct\\s](\\*+)(?!\\*)(?=[punct\\s]|$)|(?!\\*)[punct\\s](\\*+)(?=[^punct\\s])|[\\s](\\*+)(?!\\*)(?=[punct])|(?!\\*)[punct](\\*+)(?!\\*)(?=[punct])|[^punct\\s](\\*+)(?=[^punct\\s])", "gu").replace(/punct/g, So).getRegex(), zG = je("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\\s]|$)|[^punct\\s](_+)(?!_)(?=[punct\\s]|$)|(?!_)[punct\\s](_+)(?=[^punct\\s])|[\\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])", "gu").replace(/punct/g, So).getRegex(), VG = je(/\\([punct])/, "gu").replace(/punct/g, So).getRegex(), HG = je(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(), WG = je(tp).replace("(?:-->|$)", "-->").getRegex(), UG = je("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", WG).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(), Oc = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/, YG = je(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/).replace("label", Oc).replace("href", /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(), f$ = je(/^!?\[(label)\]\[(ref)\]/).replace("label", Oc).replace("ref", ep).getRegex(), d$ = je(/^!?\[(ref)\](?:\[\])?/).replace("ref", ep).getRegex(), qG = je("reflink|nolink(?!\\()", "g").replace("reflink", f$).replace("nolink", d$).getRegex(), rp = {
  _backpedal: Fa,
  // only used for GFM url
  anyPunctuation: VG,
  autolink: HG,
  blockSkip: NG,
  br: u$,
  code: IG,
  del: Fa,
  emStrongLDelim: LG,
  emStrongRDelimAst: jG,
  emStrongRDelimUnd: zG,
  escape: c$,
  link: YG,
  nolink: d$,
  punctuation: BG,
  reflink: f$,
  reflinkSearch: qG,
  tag: UG,
  text: RG,
  url: Fa
}, GG = {
  ...rp,
  link: je(/^!?\[(label)\]\((.*?)\)/).replace("label", Oc).getRegex(),
  reflink: je(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", Oc).getRegex()
}, n0 = {
  ...rp,
  escape: je(c$).replace("])", "~|])").getRegex(),
  url: je(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),
  _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
}, XG = {
  ...n0,
  br: je(u$).replace("{2,}", "*").getRegex(),
  text: je(n0.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
}, pl = {
  normal: np,
  gfm: FG,
  pedantic: PG
}, da = {
  normal: rp,
  gfm: n0,
  breaks: XG,
  pedantic: GG
};
class Bn {
  constructor(t) {
    V(this, "tokens");
    V(this, "options");
    V(this, "state");
    V(this, "tokenizer");
    V(this, "inlineQueue");
    this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = t || Ii, this.options.tokenizer = this.options.tokenizer || new Tc(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = {
      inLink: !1,
      inRawBlock: !1,
      top: !0
    };
    const n = {
      block: pl.normal,
      inline: da.normal
    };
    this.options.pedantic ? (n.block = pl.pedantic, n.inline = da.pedantic) : this.options.gfm && (n.block = pl.gfm, this.options.breaks ? n.inline = da.breaks : n.inline = da.gfm), this.tokenizer.rules = n;
  }
  /**
   * Expose Rules
   */
  static get rules() {
    return {
      block: pl,
      inline: da
    };
  }
  /**
   * Static Lex Method
   */
  static lex(t, n) {
    return new Bn(n).lex(t);
  }
  /**
   * Static Lex Inline Method
   */
  static lexInline(t, n) {
    return new Bn(n).inlineTokens(t);
  }
  /**
   * Preprocessing
   */
  lex(t) {
    t = t.replace(/\r\n|\r/g, `
`), this.blockTokens(t, this.tokens);
    for (let n = 0; n < this.inlineQueue.length; n++) {
      const r = this.inlineQueue[n];
      this.inlineTokens(r.src, r.tokens);
    }
    return this.inlineQueue = [], this.tokens;
  }
  blockTokens(t, n = []) {
    this.options.pedantic ? t = t.replace(/\t/g, "    ").replace(/^ +$/gm, "") : t = t.replace(/^( *)(\t+)/gm, (o, l, c) => l + "    ".repeat(c.length));
    let r, i, s, a;
    for (; t; )
      if (!(this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((o) => (r = o.call({ lexer: this }, t, n)) ? (t = t.substring(r.raw.length), n.push(r), !0) : !1))) {
        if (r = this.tokenizer.space(t)) {
          t = t.substring(r.raw.length), r.raw.length === 1 && n.length > 0 ? n[n.length - 1].raw += `
` : n.push(r);
          continue;
        }
        if (r = this.tokenizer.code(t)) {
          t = t.substring(r.raw.length), i = n[n.length - 1], i && (i.type === "paragraph" || i.type === "text") ? (i.raw += `
` + r.raw, i.text += `
` + r.text, this.inlineQueue[this.inlineQueue.length - 1].src = i.text) : n.push(r);
          continue;
        }
        if (r = this.tokenizer.fences(t)) {
          t = t.substring(r.raw.length), n.push(r);
          continue;
        }
        if (r = this.tokenizer.heading(t)) {
          t = t.substring(r.raw.length), n.push(r);
          continue;
        }
        if (r = this.tokenizer.hr(t)) {
          t = t.substring(r.raw.length), n.push(r);
          continue;
        }
        if (r = this.tokenizer.blockquote(t)) {
          t = t.substring(r.raw.length), n.push(r);
          continue;
        }
        if (r = this.tokenizer.list(t)) {
          t = t.substring(r.raw.length), n.push(r);
          continue;
        }
        if (r = this.tokenizer.html(t)) {
          t = t.substring(r.raw.length), n.push(r);
          continue;
        }
        if (r = this.tokenizer.def(t)) {
          t = t.substring(r.raw.length), i = n[n.length - 1], i && (i.type === "paragraph" || i.type === "text") ? (i.raw += `
` + r.raw, i.text += `
` + r.raw, this.inlineQueue[this.inlineQueue.length - 1].src = i.text) : this.tokens.links[r.tag] || (this.tokens.links[r.tag] = {
            href: r.href,
            title: r.title
          });
          continue;
        }
        if (r = this.tokenizer.table(t)) {
          t = t.substring(r.raw.length), n.push(r);
          continue;
        }
        if (r = this.tokenizer.lheading(t)) {
          t = t.substring(r.raw.length), n.push(r);
          continue;
        }
        if (s = t, this.options.extensions && this.options.extensions.startBlock) {
          let o = 1 / 0;
          const l = t.slice(1);
          let c;
          this.options.extensions.startBlock.forEach((u) => {
            c = u.call({ lexer: this }, l), typeof c == "number" && c >= 0 && (o = Math.min(o, c));
          }), o < 1 / 0 && o >= 0 && (s = t.substring(0, o + 1));
        }
        if (this.state.top && (r = this.tokenizer.paragraph(s))) {
          i = n[n.length - 1], a && i.type === "paragraph" ? (i.raw += `
` + r.raw, i.text += `
` + r.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = i.text) : n.push(r), a = s.length !== t.length, t = t.substring(r.raw.length);
          continue;
        }
        if (r = this.tokenizer.text(t)) {
          t = t.substring(r.raw.length), i = n[n.length - 1], i && i.type === "text" ? (i.raw += `
` + r.raw, i.text += `
` + r.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = i.text) : n.push(r);
          continue;
        }
        if (t) {
          const o = "Infinite loop on byte: " + t.charCodeAt(0);
          if (this.options.silent) {
            console.error(o);
            break;
          } else
            throw new Error(o);
        }
      }
    return this.state.top = !0, n;
  }
  inline(t, n = []) {
    return this.inlineQueue.push({ src: t, tokens: n }), n;
  }
  /**
   * Lexing/Compiling
   */
  inlineTokens(t, n = []) {
    let r, i, s, a = t, o, l, c;
    if (this.tokens.links) {
      const u = Object.keys(this.tokens.links);
      if (u.length > 0)
        for (; (o = this.tokenizer.rules.inline.reflinkSearch.exec(a)) != null; )
          u.includes(o[0].slice(o[0].lastIndexOf("[") + 1, -1)) && (a = a.slice(0, o.index) + "[" + "a".repeat(o[0].length - 2) + "]" + a.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
    }
    for (; (o = this.tokenizer.rules.inline.blockSkip.exec(a)) != null; )
      a = a.slice(0, o.index) + "[" + "a".repeat(o[0].length - 2) + "]" + a.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    for (; (o = this.tokenizer.rules.inline.anyPunctuation.exec(a)) != null; )
      a = a.slice(0, o.index) + "++" + a.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
    for (; t; )
      if (l || (c = ""), l = !1, !(this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((u) => (r = u.call({ lexer: this }, t, n)) ? (t = t.substring(r.raw.length), n.push(r), !0) : !1))) {
        if (r = this.tokenizer.escape(t)) {
          t = t.substring(r.raw.length), n.push(r);
          continue;
        }
        if (r = this.tokenizer.tag(t)) {
          t = t.substring(r.raw.length), i = n[n.length - 1], i && r.type === "text" && i.type === "text" ? (i.raw += r.raw, i.text += r.text) : n.push(r);
          continue;
        }
        if (r = this.tokenizer.link(t)) {
          t = t.substring(r.raw.length), n.push(r);
          continue;
        }
        if (r = this.tokenizer.reflink(t, this.tokens.links)) {
          t = t.substring(r.raw.length), i = n[n.length - 1], i && r.type === "text" && i.type === "text" ? (i.raw += r.raw, i.text += r.text) : n.push(r);
          continue;
        }
        if (r = this.tokenizer.emStrong(t, a, c)) {
          t = t.substring(r.raw.length), n.push(r);
          continue;
        }
        if (r = this.tokenizer.codespan(t)) {
          t = t.substring(r.raw.length), n.push(r);
          continue;
        }
        if (r = this.tokenizer.br(t)) {
          t = t.substring(r.raw.length), n.push(r);
          continue;
        }
        if (r = this.tokenizer.del(t)) {
          t = t.substring(r.raw.length), n.push(r);
          continue;
        }
        if (r = this.tokenizer.autolink(t)) {
          t = t.substring(r.raw.length), n.push(r);
          continue;
        }
        if (!this.state.inLink && (r = this.tokenizer.url(t))) {
          t = t.substring(r.raw.length), n.push(r);
          continue;
        }
        if (s = t, this.options.extensions && this.options.extensions.startInline) {
          let u = 1 / 0;
          const f = t.slice(1);
          let d;
          this.options.extensions.startInline.forEach((h) => {
            d = h.call({ lexer: this }, f), typeof d == "number" && d >= 0 && (u = Math.min(u, d));
          }), u < 1 / 0 && u >= 0 && (s = t.substring(0, u + 1));
        }
        if (r = this.tokenizer.inlineText(s)) {
          t = t.substring(r.raw.length), r.raw.slice(-1) !== "_" && (c = r.raw.slice(-1)), l = !0, i = n[n.length - 1], i && i.type === "text" ? (i.raw += r.raw, i.text += r.text) : n.push(r);
          continue;
        }
        if (t) {
          const u = "Infinite loop on byte: " + t.charCodeAt(0);
          if (this.options.silent) {
            console.error(u);
            break;
          } else
            throw new Error(u);
        }
      }
    return n;
  }
}
class lo {
  constructor(t) {
    V(this, "options");
    this.options = t || Ii;
  }
  code(t, n, r) {
    var s;
    const i = (s = (n || "").match(/^\S*/)) == null ? void 0 : s[0];
    return t = t.replace(/\n$/, "") + `
`, i ? '<pre><code class="language-' + tn(i) + '">' + (r ? t : tn(t, !0)) + `</code></pre>
` : "<pre><code>" + (r ? t : tn(t, !0)) + `</code></pre>
`;
  }
  blockquote(t) {
    return `<blockquote>
${t}</blockquote>
`;
  }
  html(t, n) {
    return t;
  }
  heading(t, n, r) {
    return `<h${n}>${t}</h${n}>
`;
  }
  hr() {
    return `<hr>
`;
  }
  list(t, n, r) {
    const i = n ? "ol" : "ul", s = n && r !== 1 ? ' start="' + r + '"' : "";
    return "<" + i + s + `>
` + t + "</" + i + `>
`;
  }
  listitem(t, n, r) {
    return `<li>${t}</li>
`;
  }
  checkbox(t) {
    return "<input " + (t ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
  }
  paragraph(t) {
    return `<p>${t}</p>
`;
  }
  table(t, n) {
    return n && (n = `<tbody>${n}</tbody>`), `<table>
<thead>
` + t + `</thead>
` + n + `</table>
`;
  }
  tablerow(t) {
    return `<tr>
${t}</tr>
`;
  }
  tablecell(t, n) {
    const r = n.header ? "th" : "td";
    return (n.align ? `<${r} align="${n.align}">` : `<${r}>`) + t + `</${r}>
`;
  }
  /**
   * span level renderer
   */
  strong(t) {
    return `<strong>${t}</strong>`;
  }
  em(t) {
    return `<em>${t}</em>`;
  }
  codespan(t) {
    return `<code>${t}</code>`;
  }
  br() {
    return "<br>";
  }
  del(t) {
    return `<del>${t}</del>`;
  }
  link(t, n, r) {
    const i = $y(t);
    if (i === null)
      return r;
    t = i;
    let s = '<a href="' + t + '"';
    return n && (s += ' title="' + n + '"'), s += ">" + r + "</a>", s;
  }
  image(t, n, r) {
    const i = $y(t);
    if (i === null)
      return r;
    t = i;
    let s = `<img src="${t}" alt="${r}"`;
    return n && (s += ` title="${n}"`), s += ">", s;
  }
  text(t) {
    return t;
  }
}
class ip {
  // no need for block level renderers
  strong(t) {
    return t;
  }
  em(t) {
    return t;
  }
  codespan(t) {
    return t;
  }
  del(t) {
    return t;
  }
  html(t) {
    return t;
  }
  text(t) {
    return t;
  }
  link(t, n, r) {
    return "" + r;
  }
  image(t, n, r) {
    return "" + r;
  }
  br() {
    return "";
  }
}
class Nn {
  constructor(t) {
    V(this, "options");
    V(this, "renderer");
    V(this, "textRenderer");
    this.options = t || Ii, this.options.renderer = this.options.renderer || new lo(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.textRenderer = new ip();
  }
  /**
   * Static Parse Method
   */
  static parse(t, n) {
    return new Nn(n).parse(t);
  }
  /**
   * Static Parse Inline Method
   */
  static parseInline(t, n) {
    return new Nn(n).parseInline(t);
  }
  /**
   * Parse Loop
   */
  parse(t, n = !0) {
    let r = "";
    for (let i = 0; i < t.length; i++) {
      const s = t[i];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[s.type]) {
        const a = s, o = this.options.extensions.renderers[a.type].call({ parser: this }, a);
        if (o !== !1 || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(a.type)) {
          r += o || "";
          continue;
        }
      }
      switch (s.type) {
        case "space":
          continue;
        case "hr": {
          r += this.renderer.hr();
          continue;
        }
        case "heading": {
          const a = s;
          r += this.renderer.heading(this.parseInline(a.tokens), a.depth, bG(this.parseInline(a.tokens, this.textRenderer)));
          continue;
        }
        case "code": {
          const a = s;
          r += this.renderer.code(a.text, a.lang, !!a.escaped);
          continue;
        }
        case "table": {
          const a = s;
          let o = "", l = "";
          for (let u = 0; u < a.header.length; u++)
            l += this.renderer.tablecell(this.parseInline(a.header[u].tokens), { header: !0, align: a.align[u] });
          o += this.renderer.tablerow(l);
          let c = "";
          for (let u = 0; u < a.rows.length; u++) {
            const f = a.rows[u];
            l = "";
            for (let d = 0; d < f.length; d++)
              l += this.renderer.tablecell(this.parseInline(f[d].tokens), { header: !1, align: a.align[d] });
            c += this.renderer.tablerow(l);
          }
          r += this.renderer.table(o, c);
          continue;
        }
        case "blockquote": {
          const a = s, o = this.parse(a.tokens);
          r += this.renderer.blockquote(o);
          continue;
        }
        case "list": {
          const a = s, o = a.ordered, l = a.start, c = a.loose;
          let u = "";
          for (let f = 0; f < a.items.length; f++) {
            const d = a.items[f], h = d.checked, p = d.task;
            let g = "";
            if (d.task) {
              const v = this.renderer.checkbox(!!h);
              c ? d.tokens.length > 0 && d.tokens[0].type === "paragraph" ? (d.tokens[0].text = v + " " + d.tokens[0].text, d.tokens[0].tokens && d.tokens[0].tokens.length > 0 && d.tokens[0].tokens[0].type === "text" && (d.tokens[0].tokens[0].text = v + " " + d.tokens[0].tokens[0].text)) : d.tokens.unshift({
                type: "text",
                text: v + " "
              }) : g += v + " ";
            }
            g += this.parse(d.tokens, c), u += this.renderer.listitem(g, p, !!h);
          }
          r += this.renderer.list(u, o, l);
          continue;
        }
        case "html": {
          const a = s;
          r += this.renderer.html(a.text, a.block);
          continue;
        }
        case "paragraph": {
          const a = s;
          r += this.renderer.paragraph(this.parseInline(a.tokens));
          continue;
        }
        case "text": {
          let a = s, o = a.tokens ? this.parseInline(a.tokens) : a.text;
          for (; i + 1 < t.length && t[i + 1].type === "text"; )
            a = t[++i], o += `
` + (a.tokens ? this.parseInline(a.tokens) : a.text);
          r += n ? this.renderer.paragraph(o) : o;
          continue;
        }
        default: {
          const a = 'Token with "' + s.type + '" type was not found.';
          if (this.options.silent)
            return console.error(a), "";
          throw new Error(a);
        }
      }
    }
    return r;
  }
  /**
   * Parse Inline Tokens
   */
  parseInline(t, n) {
    n = n || this.renderer;
    let r = "";
    for (let i = 0; i < t.length; i++) {
      const s = t[i];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[s.type]) {
        const a = this.options.extensions.renderers[s.type].call({ parser: this }, s);
        if (a !== !1 || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(s.type)) {
          r += a || "";
          continue;
        }
      }
      switch (s.type) {
        case "escape": {
          const a = s;
          r += n.text(a.text);
          break;
        }
        case "html": {
          const a = s;
          r += n.html(a.text);
          break;
        }
        case "link": {
          const a = s;
          r += n.link(a.href, a.title, this.parseInline(a.tokens, n));
          break;
        }
        case "image": {
          const a = s;
          r += n.image(a.href, a.title, a.text);
          break;
        }
        case "strong": {
          const a = s;
          r += n.strong(this.parseInline(a.tokens, n));
          break;
        }
        case "em": {
          const a = s;
          r += n.em(this.parseInline(a.tokens, n));
          break;
        }
        case "codespan": {
          const a = s;
          r += n.codespan(a.text);
          break;
        }
        case "br": {
          r += n.br();
          break;
        }
        case "del": {
          const a = s;
          r += n.del(this.parseInline(a.tokens, n));
          break;
        }
        case "text": {
          const a = s;
          r += n.text(a.text);
          break;
        }
        default: {
          const a = 'Token with "' + s.type + '" type was not found.';
          if (this.options.silent)
            return console.error(a), "";
          throw new Error(a);
        }
      }
    }
    return r;
  }
}
class Pa {
  constructor(t) {
    V(this, "options");
    this.options = t || Ii;
  }
  /**
   * Process markdown before marked
   */
  preprocess(t) {
    return t;
  }
  /**
   * Process HTML after marked is finished
   */
  postprocess(t) {
    return t;
  }
  /**
   * Process all tokens before walk tokens
   */
  processAllTokens(t) {
    return t;
  }
}
V(Pa, "passThroughHooks", /* @__PURE__ */ new Set([
  "preprocess",
  "postprocess",
  "processAllTokens"
]));
var mo, r0, Xc, h$;
class ZG {
  constructor(...t) {
    Hu(this, mo);
    Hu(this, Xc);
    V(this, "defaults", Jh());
    V(this, "options", this.setOptions);
    V(this, "parse", Lo(this, mo, r0).call(this, Bn.lex, Nn.parse));
    V(this, "parseInline", Lo(this, mo, r0).call(this, Bn.lexInline, Nn.parseInline));
    V(this, "Parser", Nn);
    V(this, "Renderer", lo);
    V(this, "TextRenderer", ip);
    V(this, "Lexer", Bn);
    V(this, "Tokenizer", Tc);
    V(this, "Hooks", Pa);
    this.use(...t);
  }
  /**
   * Run callback for every token
   */
  walkTokens(t, n) {
    var i, s;
    let r = [];
    for (const a of t)
      switch (r = r.concat(n.call(this, a)), a.type) {
        case "table": {
          const o = a;
          for (const l of o.header)
            r = r.concat(this.walkTokens(l.tokens, n));
          for (const l of o.rows)
            for (const c of l)
              r = r.concat(this.walkTokens(c.tokens, n));
          break;
        }
        case "list": {
          const o = a;
          r = r.concat(this.walkTokens(o.items, n));
          break;
        }
        default: {
          const o = a;
          (s = (i = this.defaults.extensions) == null ? void 0 : i.childTokens) != null && s[o.type] ? this.defaults.extensions.childTokens[o.type].forEach((l) => {
            r = r.concat(this.walkTokens(o[l], n));
          }) : o.tokens && (r = r.concat(this.walkTokens(o.tokens, n)));
        }
      }
    return r;
  }
  use(...t) {
    const n = this.defaults.extensions || { renderers: {}, childTokens: {} };
    return t.forEach((r) => {
      const i = { ...r };
      if (i.async = this.defaults.async || i.async || !1, r.extensions && (r.extensions.forEach((s) => {
        if (!s.name)
          throw new Error("extension name required");
        if ("renderer" in s) {
          const a = n.renderers[s.name];
          a ? n.renderers[s.name] = function(...o) {
            let l = s.renderer.apply(this, o);
            return l === !1 && (l = a.apply(this, o)), l;
          } : n.renderers[s.name] = s.renderer;
        }
        if ("tokenizer" in s) {
          if (!s.level || s.level !== "block" && s.level !== "inline")
            throw new Error("extension level must be 'block' or 'inline'");
          const a = n[s.level];
          a ? a.unshift(s.tokenizer) : n[s.level] = [s.tokenizer], s.start && (s.level === "block" ? n.startBlock ? n.startBlock.push(s.start) : n.startBlock = [s.start] : s.level === "inline" && (n.startInline ? n.startInline.push(s.start) : n.startInline = [s.start]));
        }
        "childTokens" in s && s.childTokens && (n.childTokens[s.name] = s.childTokens);
      }), i.extensions = n), r.renderer) {
        const s = this.defaults.renderer || new lo(this.defaults);
        for (const a in r.renderer) {
          if (!(a in s))
            throw new Error(`renderer '${a}' does not exist`);
          if (a === "options")
            continue;
          const o = a, l = r.renderer[o], c = s[o];
          s[o] = (...u) => {
            let f = l.apply(s, u);
            return f === !1 && (f = c.apply(s, u)), f || "";
          };
        }
        i.renderer = s;
      }
      if (r.tokenizer) {
        const s = this.defaults.tokenizer || new Tc(this.defaults);
        for (const a in r.tokenizer) {
          if (!(a in s))
            throw new Error(`tokenizer '${a}' does not exist`);
          if (["options", "rules", "lexer"].includes(a))
            continue;
          const o = a, l = r.tokenizer[o], c = s[o];
          s[o] = (...u) => {
            let f = l.apply(s, u);
            return f === !1 && (f = c.apply(s, u)), f;
          };
        }
        i.tokenizer = s;
      }
      if (r.hooks) {
        const s = this.defaults.hooks || new Pa();
        for (const a in r.hooks) {
          if (!(a in s))
            throw new Error(`hook '${a}' does not exist`);
          if (a === "options")
            continue;
          const o = a, l = r.hooks[o], c = s[o];
          Pa.passThroughHooks.has(a) ? s[o] = (u) => {
            if (this.defaults.async)
              return Promise.resolve(l.call(s, u)).then((d) => c.call(s, d));
            const f = l.call(s, u);
            return c.call(s, f);
          } : s[o] = (...u) => {
            let f = l.apply(s, u);
            return f === !1 && (f = c.apply(s, u)), f;
          };
        }
        i.hooks = s;
      }
      if (r.walkTokens) {
        const s = this.defaults.walkTokens, a = r.walkTokens;
        i.walkTokens = function(o) {
          let l = [];
          return l.push(a.call(this, o)), s && (l = l.concat(s.call(this, o))), l;
        };
      }
      this.defaults = { ...this.defaults, ...i };
    }), this;
  }
  setOptions(t) {
    return this.defaults = { ...this.defaults, ...t }, this;
  }
  lexer(t, n) {
    return Bn.lex(t, n ?? this.defaults);
  }
  parser(t, n) {
    return Nn.parse(t, n ?? this.defaults);
  }
}
mo = new WeakSet(), r0 = function(t, n) {
  return (r, i) => {
    const s = { ...i }, a = { ...this.defaults, ...s };
    this.defaults.async === !0 && s.async === !1 && (a.silent || console.warn("marked(): The async option was set to true by an extension. The async: false option sent to parse will be ignored."), a.async = !0);
    const o = Lo(this, Xc, h$).call(this, !!a.silent, !!a.async);
    if (typeof r > "u" || r === null)
      return o(new Error("marked(): input parameter is undefined or null"));
    if (typeof r != "string")
      return o(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(r) + ", string expected"));
    if (a.hooks && (a.hooks.options = a), a.async)
      return Promise.resolve(a.hooks ? a.hooks.preprocess(r) : r).then((l) => t(l, a)).then((l) => a.hooks ? a.hooks.processAllTokens(l) : l).then((l) => a.walkTokens ? Promise.all(this.walkTokens(l, a.walkTokens)).then(() => l) : l).then((l) => n(l, a)).then((l) => a.hooks ? a.hooks.postprocess(l) : l).catch(o);
    try {
      a.hooks && (r = a.hooks.preprocess(r));
      let l = t(r, a);
      a.hooks && (l = a.hooks.processAllTokens(l)), a.walkTokens && this.walkTokens(l, a.walkTokens);
      let c = n(l, a);
      return a.hooks && (c = a.hooks.postprocess(c)), c;
    } catch (l) {
      return o(l);
    }
  };
}, Xc = new WeakSet(), h$ = function(t, n) {
  return (r) => {
    if (r.message += `
Please report this to https://github.com/markedjs/marked.`, t) {
      const i = "<p>An error occurred:</p><pre>" + tn(r.message + "", !0) + "</pre>";
      return n ? Promise.resolve(i) : i;
    }
    if (n)
      return Promise.reject(r);
    throw r;
  };
};
const _i = new ZG();
function Ne(e, t) {
  return _i.parse(e, t);
}
Ne.options = Ne.setOptions = function(e) {
  return _i.setOptions(e), Ne.defaults = _i.defaults, r$(Ne.defaults), Ne;
};
Ne.getDefaults = Jh;
Ne.defaults = Ii;
Ne.use = function(...e) {
  return _i.use(...e), Ne.defaults = _i.defaults, r$(Ne.defaults), Ne;
};
Ne.walkTokens = function(e, t) {
  return _i.walkTokens(e, t);
};
Ne.parseInline = _i.parseInline;
Ne.Parser = Nn;
Ne.parser = Nn.parse;
Ne.Renderer = lo;
Ne.TextRenderer = ip;
Ne.Lexer = Bn;
Ne.lexer = Bn.lex;
Ne.Tokenizer = Tc;
Ne.Hooks = Pa;
Ne.parse = Ne;
Ne.options;
Ne.setOptions;
Ne.use;
Ne.walkTokens;
Ne.parseInline;
Nn.parse;
Bn.lex;
const KG = { key: 0 }, JG = ["innerHTML"], QG = ["textContent"], eX = ["innerHTML"], tX = /* @__PURE__ */ be({
  __name: "doc",
  props: {
    content: {
      type: String,
      required: !0
    },
    langRender: {
      type: Function,
      required: !1,
      default: null
    },
    xssWhiteList: {
      type: Object,
      required: !1,
      default: null
    },
    mode: {
      type: String,
      required: !1,
      default: () => "markdown"
    }
  },
  setup(e) {
    fa.registerLanguage("javascript", gG), fa.registerLanguage("html", uG);
    const t = e, n = Oe({
      content: ""
    });
    ct(() => {
      r();
    }), fe([
      () => t.content,
      () => t.mode
    ], () => {
      r();
    });
    const r = async () => {
      const i = {
        ...z2.getDefaultWhiteList(),
        ...t.xssWhiteList || {}
      };
      if (t.mode === "markdown") {
        const s = new lo(), a = (l) => l.toLowerCase().replace(/[\s~`!@#$%^&*()\-_+=[\]{}|\\;:"'<>,.?/]+/g, "-").replace(/^-+|-+$/g, "");
        s.code = (l, c) => {
          const u = c && fa.getLanguage(c), f = u ? fa.highlight(c, l).value : fa.highlightAuto(l).value;
          return `<pre><code class="hljs ${u ? `language-${c}` : ""}">${f}</code></pre>`;
        }, s.heading = (l, c, u) => `<h${c} style="scroll-margin-top: 128px" id="${a(u)}">${l}</h${c}>
`;
        const o = await Ne(t.content, {
          renderer: s
        });
        i.code == null && (i.code = []), i.span == null && (i.span = []), i.code.push("class"), i.span.push("class"), n.content = hy(o, {
          whiteList: i
        });
      } else
        n.content = hy(t.content, {
          whiteList: i
        });
    };
    return (i, s) => n.content ? (j(), G("div", KG, [
      e.mode === "html" ? (j(), G("div", {
        key: 0,
        innerHTML: n.content
      }, null, 8, JG)) : ve("", !0),
      e.mode === "text" ? (j(), G("div", {
        key: 1,
        textContent: Fe(n.content)
      }, null, 8, QG)) : ve("", !0),
      e.mode === "markdown" ? (j(), G("div", {
        key: 2,
        class: "markdown-body bg-transparent",
        innerHTML: n.content
      }, null, 8, eX)) : ve("", !0)
    ])) : ve("", !0);
  }
}), nX = /* @__PURE__ */ Sn(tX, [["__scopeId", "data-v-ecf3a268"]]), rX = { style: { position: "relative" } }, iX = /* @__PURE__ */ be({
  __name: "sug-textarea",
  props: /* @__PURE__ */ ik({
    autocompleteKey: {
      type: String,
      required: !1,
      default: null
    },
    sugTexts: {
      type: Array,
      required: !1,
      default: () => []
    },
    showActions: {
      type: Boolean,
      required: !1,
      default: !1
    },
    textareaProps: {
      type: Object,
      requreid: !1,
      default: () => ({})
    }
  }, {
    modelValue: {
      type: String,
      required: !1,
      default: ""
    },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(e) {
    const t = oe(), n = sk(e, "modelValue"), r = e, i = Oe({
      recommandIndex: 0
    }), s = new eu();
    s.add("keydown", (d) => {
      r.autocompleteKey != null && d.key === r.autocompleteKey && l.value && (d.preventDefault(), c());
    }), ct(() => {
      t.value && s.observe(t.value.$el);
    }), zt(() => {
      s.clear();
    });
    const a = T(() => {
      let d = [];
      if (!n.value)
        return [];
      for (let h of r.sugTexts)
        h !== n.value && h.startsWith(n.value) && d.push(h);
      return d;
    }), o = T(() => a.value[i.recommandIndex] || ""), l = T(() => a.value.length !== 0);
    fe(() => a.value.length, () => {
      i.recommandIndex = 0;
    });
    const c = () => {
      n.value = o.value;
    }, u = () => {
      i.recommandIndex += 1, i.recommandIndex >= a.value.length && (i.recommandIndex = 0);
    }, f = () => {
      i.recommandIndex -= 1, i.recommandIndex < 0 && (i.recommandIndex = a.value.length - 1);
    };
    return (d, h) => {
      const p = ge("VBtn"), g = ge("VCol"), v = ge("VRow"), m = ge("VCard");
      return j(), G("div", rX, [
        e.showActions && l.value ? (j(), ke(m, {
          key: 0,
          position: "absolute",
          class: "pa-1",
          style: { top: "-24px", left: "16px", "z-index": "2" }
        }, {
          default: pe(() => [
            U(v, {
              dense: "",
              class: "flex-nowrap",
              align: "center"
            }, {
              default: pe(() => [
                a.value.length > 1 ? (j(), ke(g, {
                  key: 0,
                  cols: "auto"
                }, {
                  default: pe(() => [
                    U(p, {
                      variant: "text",
                      icon: "mdi-chevron-left",
                      size: "28",
                      onClick: f
                    })
                  ]),
                  _: 1
                })) : ve("", !0),
                a.value.length > 1 ? (j(), ke(g, {
                  key: 1,
                  cols: "auto"
                }, {
                  default: pe(() => [
                    fn(Fe(i.recommandIndex + 1) + " / " + Fe(a.value.length), 1)
                  ]),
                  _: 1
                })) : ve("", !0),
                a.value.length > 1 ? (j(), ke(g, {
                  key: 2,
                  cols: "auto"
                }, {
                  default: pe(() => [
                    U(p, {
                      variant: "text",
                      icon: "mdi-chevron-right",
                      size: "28",
                      onClick: u
                    })
                  ]),
                  _: 1
                })) : ve("", !0),
                a.value.length > 1 ? (j(), ke(g, {
                  key: 3,
                  cols: "auto"
                }, {
                  default: pe(() => [
                    fn(" | ")
                  ]),
                  _: 1
                })) : ve("", !0),
                U(g, { cols: "auto" }, {
                  default: pe(() => [
                    U(p, {
                      variant: "text",
                      icon: "mdi-draw",
                      size: "28",
                      onClick: c
                    })
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        })) : ve("", !0),
        l.value ? (j(), ke(X($v), Gt({ key: 1 }, e.textareaProps, {
          "model-value": o.value + (e.autocompleteKey ? ` (${e.autocompleteKey})` : ""),
          class: "sug-content w-100",
          "hide-details": "",
          counter: void 0,
          readonly: ""
        }), null, 16, ["model-value"])) : ve("", !0),
        U(X($v), Gt({
          ref_key: "textInput",
          ref: t
        }, e.textareaProps, {
          modelValue: n.value,
          "onUpdate:modelValue": h[0] || (h[0] = (x) => n.value = x)
        }), null, 16, ["modelValue"])
      ]);
    };
  }
}), sX = /* @__PURE__ */ Sn(iX, [["__scopeId", "data-v-05001280"]]), Cy = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  NgAni: hk,
  NgDatePicker: W6,
  NgDateRangePicker: U6,
  NgDialog: Y_,
  NgDoc: nX,
  NgDoughnutChart: $Y,
  NgFixedBar: X6,
  NgForm: hL,
  NgImg: vL,
  NgLineChart: EY,
  NgLink: yL,
  NgLoaders: xL,
  NgMap: AL,
  NgOutlineText: TL,
  NgOverlayLoading: xs,
  NgPagination: OL,
  NgPieChart: AY,
  NgSearch: IL,
  NgSkeleton: wh,
  NgSkeletonGroup: RL,
  NgSugTextarea: sX,
  NgTable: VL,
  NgToolbar: WL,
  NgUpload: GL,
  NgVisibleLoad: e9
}, Symbol.toStringTag, { value: "Module" })), aX = /* @__PURE__ */ be({
  __name: "confirm",
  props: {
    title: {
      type: String,
      required: !0
    },
    message: {
      type: String,
      required: !0
    },
    cancelText: {
      type: String,
      required: !0
    },
    confirmText: {
      type: String,
      required: !0
    },
    isOpen: {
      type: Boolean,
      required: !0
    },
    clickCancel: {
      type: Function,
      required: !0
    },
    clickConfirm: {
      type: Function,
      required: !0
    }
  },
  setup(e) {
    const t = e, n = Oe({
      dialog: !1,
      loading: !1,
      doubleCheckText: ""
    }), r = T(() => t.isOpen);
    fe(() => r.value, () => {
      n.dialog = r.value, n.doubleCheckText = "";
    });
    const i = (a = !0) => {
      a && t.clickCancel(), setTimeout(() => {
        n.loading = !1;
      }, 200);
    }, s = async () => {
      n.loading = !0, t.clickConfirm(i);
    };
    return (a, o) => {
      const l = ge("v-card-title"), c = ge("v-card-text"), u = ge("v-spacer"), f = ge("v-btn"), d = ge("v-card-actions"), h = ge("v-card"), p = ge("v-dialog");
      return j(), G("div", null, [
        U(p, {
          modelValue: n.dialog,
          "onUpdate:modelValue": o[0] || (o[0] = (g) => n.dialog = g),
          persistent: "",
          "max-width": "360px"
        }, {
          default: pe(() => [
            U(h, null, {
              default: pe(() => [
                U(l, null, {
                  default: pe(() => [
                    fn(Fe(e.title), 1)
                  ]),
                  _: 1
                }),
                U(c, null, {
                  default: pe(() => [
                    fn(Fe(e.message), 1)
                  ]),
                  _: 1
                }),
                U(d, { class: "pb-4 px-4" }, {
                  default: pe(() => [
                    U(u),
                    U(f, {
                      name: "ng-confirm-close",
                      variant: "text",
                      rounded: "pill",
                      disabled: n.loading,
                      onClick: e.clickCancel
                    }, {
                      default: pe(() => [
                        fn(Fe(e.cancelText), 1)
                      ]),
                      _: 1
                    }, 8, ["disabled", "onClick"]),
                    U(f, {
                      name: "ng-confirm-confirm",
                      color: "primary",
                      rounded: "pill",
                      loading: n.loading,
                      onClick: s
                    }, {
                      default: pe(() => [
                        fn(Fe(e.confirmText), 1)
                      ]),
                      _: 1
                    }, 8, ["loading"])
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["modelValue"])
      ]);
    };
  }
}), oX = { class: "lib-notification" }, lX = {
  class: "ml-3",
  style: { overflow: "auto" }
}, cX = /* @__PURE__ */ be({
  __name: "notification",
  props: {
    onclear: {
      type: Function,
      required: !0
    },
    messages: {
      type: Array,
      required: !0
    }
  },
  setup(e) {
    const t = e, n = Oe({
      dialog: !1,
      ticker: new _b(100)
    }), r = T(() => t.messages.slice(0, 4));
    ct(() => {
      n.ticker.on("next", () => {
        let l = !1;
        r.value.forEach((c) => {
          c.clicked === !1 && (c.duration += 10, c.duration >= 100 && (l = !0));
        }), l && t.onclear();
      });
    }), zt(() => {
      n.ticker.close();
    });
    const i = (l) => {
      if (l === "danger")
        return "error";
      if (l === "info")
        return "info";
      if (l === "success")
        return "success";
      if (l === "warning")
        return "warning";
    }, s = (l) => {
      if (l === "danger")
        return "mdi-alert-circle";
      if (l === "info")
        return "mdi-email";
      if (l === "success")
        return "mdi-check";
      if (l === "warning")
        return "mdi-comment-alert";
    }, a = (l) => {
      l.clicked = !0;
    }, o = (l) => {
      setTimeout(() => {
        l.duration = 120, t.onclear();
      }, 100);
    };
    return (l, c) => {
      const u = ge("v-progress-linear"), f = ge("v-icon"), d = ge("v-spacer"), h = ge("v-btn"), p = ge("v-row"), g = ge("v-card");
      return j(), G("div", oX, [
        U(gb, { name: "lib-notification-list" }, {
          default: pe(() => [
            (j(!0), G(Ie, null, _t(r.value, (v) => (j(), G("div", {
              key: v.id,
              class: "lib-notification-block mt-2 mr-2"
            }, [
              Ee(l.$slots, "default", {
                message: v,
                color: i(v.type),
                close: () => o(v),
                stop: () => a(v)
              }, () => [
                U(g, {
                  rounded: "lg",
                  outlined: "",
                  onClick: (m) => a(v)
                }, {
                  default: pe(() => [
                    v.clicked === !1 ? (j(), ke(u, {
                      key: 0,
                      height: "2",
                      color: i(v.type),
                      "model-value": 100 - v.duration
                    }, null, 8, ["color", "model-value"])) : ve("", !0),
                    U(p, {
                      class: Be(["pa-3 flex-nowrap", `${i(v.type)}--text`]),
                      "no-gutters": "",
                      align: "center"
                    }, {
                      default: pe(() => [
                        U(f, {
                          color: i(v.type)
                        }, {
                          default: pe(() => [
                            fn(Fe(s(v.type)), 1)
                          ]),
                          _: 2
                        }, 1032, ["color"]),
                        de("div", lX, Fe(v.content), 1),
                        U(d),
                        U(h, {
                          variant: "plain",
                          icon: "mdi-close",
                          color: i(v.type),
                          onClick: U0((m) => o(v), ["stop"])
                        }, null, 8, ["color", "onClick"])
                      ]),
                      _: 2
                    }, 1032, ["class"])
                  ]),
                  _: 2
                }, 1032, ["onClick"])
              ], !0)
            ]))), 128))
          ]),
          _: 3
        })
      ]);
    };
  }
}), uX = /* @__PURE__ */ Sn(cX, [["__scopeId", "data-v-73977251"]]), Dy = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  NgConfirmLayout: aX,
  NgNotificationLayout: uX
}, Symbol.toStringTag, { value: "Module" })), Sy = yn.checkout("listener-group"), Yhe = () => {
  let e = !1, t = [], n = () => {
    if (e === !1)
      e = !0, t.forEach((r) => r == null ? void 0 : r.off());
    else
      throw Sy.create("offAll() is failed, because already called.");
  };
  return zt(() => {
    e === !1 && n();
  }), {
    off: () => n(),
    push: (r) => {
      if (e === !1)
        t.push(...r);
      else
        throw Sy.create("push() is failed, because already called offAll().");
    }
  };
}, qhe = () => {
  const e = Oe(new xb());
  return zt(() => {
    e.clear();
  }), e;
}, Ghe = (e) => oe(), Xhe = (e) => Oe(e), fX = () => {
  const e = [];
  return {
    reset: () => {
      for (let { cb: r, data: i } of e)
        Object.assign(i, r());
    },
    create: (r) => {
      const i = Oe(r());
      return e.push({
        cb: r,
        data: i
      }), i;
    }
  };
};
class Mc extends Lt {
  constructor() {
    super(...arguments);
    V(this, "canvas", document.createElement("canvas"));
    V(this, "video");
    V(this, "stream");
    V(this, "mediaRecorder");
    V(this, "options");
  }
  static stopAndRemoveTracks(n) {
    n.getTracks().forEach((r) => r.stop()), n.getAudioTracks().forEach((r) => n.removeTrack(r)), n.getVideoTracks().forEach((r) => n.removeTrack(r));
  }
  /**
   * 如果透過 navigator.permissions.query({ name: 'camera' }) 驗證會出現 Firefox 不支援的問題。
   */
  static async requestPermission() {
    try {
      const n = await navigator.mediaDevices.getUserMedia({
        audio: !0,
        video: !0
      });
      return Mc.stopAndRemoveTracks(n), !0;
    } catch {
      return !1;
    }
  }
  install(n, r) {
    return this.options = {
      record: Kl.ifEmpty(r == null ? void 0 : r.record, !1),
      useRearLens: Kl.ifEmpty(r == null ? void 0 : r.useRearLens, !1)
    }, new Promise(async (i, s) => {
      var o, l;
      const a = () => {
        var c;
        i(null), (c = this.video) == null || c.removeEventListener("loadedmetadata", a);
      };
      try {
        if (this.video = n, this.stream = await navigator.mediaDevices.getUserMedia({
          audio: !0,
          video: {
            width: n.width,
            height: n.height,
            facingMode: ((o = this.options) == null ? void 0 : o.useRearLens) === !1 ? void 0 : {
              exact: "environment"
            }
          }
        }), this.video.srcObject = this.stream, this.video.addEventListener("loadedmetadata", a), (l = this.options) != null && l.record) {
          let c = [
            "video/webm",
            "video/mp4,",
            "video/quicktime",
            "video/x-m4v",
            "video/3gpp",
            "video/3gpp2"
          ], u;
          for (let f of c)
            if (MediaRecorder.isTypeSupported(f)) {
              u = f;
              break;
            }
          this.mediaRecorder = new MediaRecorder(this.stream, {
            mimeType: u
          }), this.mediaRecorder.addEventListener("dataavailable", (f) => {
            this.emit("dataavailable", { event: f });
          });
        }
      } catch (c) {
        s(c);
      }
    });
  }
  async reload() {
    this.close(), this.video && await this.install(this.video, this.options);
  }
  play() {
    this.mediaRecorder && this.mediaRecorder.start(1e3 / 24), this.video && this.video.play();
  }
  /** 獲得一個 base64 截圖 */
  toImage() {
    if (this.video) {
      this.canvas.width = this.video.width, this.canvas.height = this.video.height;
      let n = this.canvas.getContext("2d");
      n && (n.clearRect(0, 0, this.canvas.width, this.canvas.height), n.drawImage(this.video, 0, 0));
    }
    return this.canvas.toDataURL();
  }
  close() {
    this.stream && Mc.stopAndRemoveTracks(this.stream), this.mediaRecorder && this.mediaRecorder.state !== "inactive" && this.mediaRecorder.stop();
  }
}
function Nl(e, t) {
  if (!!!e)
    throw new Error(t);
}
const dX = 10, p$ = 2;
function sp(e) {
  return Cu(e, []);
}
function Cu(e, t) {
  switch (typeof e) {
    case "string":
      return JSON.stringify(e);
    case "function":
      return e.name ? `[function ${e.name}]` : "[function]";
    case "object":
      return hX(e, t);
    default:
      return String(e);
  }
}
function hX(e, t) {
  if (e === null)
    return "null";
  if (t.includes(e))
    return "[Circular]";
  const n = [...t, e];
  if (pX(e)) {
    const r = e.toJSON();
    if (r !== e)
      return typeof r == "string" ? r : Cu(r, n);
  } else if (Array.isArray(e))
    return vX(e, n);
  return gX(e, n);
}
function pX(e) {
  return typeof e.toJSON == "function";
}
function gX(e, t) {
  const n = Object.entries(e);
  return n.length === 0 ? "{}" : t.length > p$ ? "[" + mX(e) + "]" : "{ " + n.map(
    ([i, s]) => i + ": " + Cu(s, t)
  ).join(", ") + " }";
}
function vX(e, t) {
  if (e.length === 0)
    return "[]";
  if (t.length > p$)
    return "[Array]";
  const n = Math.min(dX, e.length), r = e.length - n, i = [];
  for (let s = 0; s < n; ++s)
    i.push(Cu(e[s], t));
  return r === 1 ? i.push("... 1 more item") : r > 1 && i.push(`... ${r} more items`), "[" + i.join(", ") + "]";
}
function mX(e) {
  const t = Object.prototype.toString.call(e).replace(/^\[object /, "").replace(/]$/, "");
  if (t === "Object" && typeof e.constructor == "function") {
    const n = e.constructor.name;
    if (typeof n == "string" && n !== "")
      return n;
  }
  return t;
}
class yX {
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The Token at which this Node begins.
   */
  /**
   * The Token at which this Node ends.
   */
  /**
   * The Source document the AST represents.
   */
  constructor(t, n, r) {
    this.start = t.start, this.end = n.end, this.startToken = t, this.endToken = n, this.source = r;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
}
class g$ {
  /**
   * The kind of Token.
   */
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The 1-indexed line number on which this Token appears.
   */
  /**
   * The 1-indexed column number at which this Token begins.
   */
  /**
   * For non-punctuation tokens, represents the interpreted value of the token.
   *
   * Note: is undefined for punctuation tokens, but typed as string for
   * convenience in the parser.
   */
  /**
   * Tokens exist as nodes in a double-linked-list amongst all tokens
   * including ignored tokens. <SOF> is always the first node and <EOF>
   * the last.
   */
  constructor(t, n, r, i, s, a) {
    this.kind = t, this.start = n, this.end = r, this.line = i, this.column = s, this.value = a, this.prev = null, this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
}
const v$ = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    // Note: fragment variable definitions are deprecated and will removed in v17.0.0
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
}, xX = new Set(Object.keys(v$));
function Ty(e) {
  const t = e == null ? void 0 : e.kind;
  return typeof t == "string" && xX.has(t);
}
let rs;
(function(e) {
  e.QUERY = "query", e.MUTATION = "mutation", e.SUBSCRIPTION = "subscription";
})(rs || (rs = {}));
let le;
(function(e) {
  e.NAME = "Name", e.DOCUMENT = "Document", e.OPERATION_DEFINITION = "OperationDefinition", e.VARIABLE_DEFINITION = "VariableDefinition", e.SELECTION_SET = "SelectionSet", e.FIELD = "Field", e.ARGUMENT = "Argument", e.FRAGMENT_SPREAD = "FragmentSpread", e.INLINE_FRAGMENT = "InlineFragment", e.FRAGMENT_DEFINITION = "FragmentDefinition", e.VARIABLE = "Variable", e.INT = "IntValue", e.FLOAT = "FloatValue", e.STRING = "StringValue", e.BOOLEAN = "BooleanValue", e.NULL = "NullValue", e.ENUM = "EnumValue", e.LIST = "ListValue", e.OBJECT = "ObjectValue", e.OBJECT_FIELD = "ObjectField", e.DIRECTIVE = "Directive", e.NAMED_TYPE = "NamedType", e.LIST_TYPE = "ListType", e.NON_NULL_TYPE = "NonNullType", e.SCHEMA_DEFINITION = "SchemaDefinition", e.OPERATION_TYPE_DEFINITION = "OperationTypeDefinition", e.SCALAR_TYPE_DEFINITION = "ScalarTypeDefinition", e.OBJECT_TYPE_DEFINITION = "ObjectTypeDefinition", e.FIELD_DEFINITION = "FieldDefinition", e.INPUT_VALUE_DEFINITION = "InputValueDefinition", e.INTERFACE_TYPE_DEFINITION = "InterfaceTypeDefinition", e.UNION_TYPE_DEFINITION = "UnionTypeDefinition", e.ENUM_TYPE_DEFINITION = "EnumTypeDefinition", e.ENUM_VALUE_DEFINITION = "EnumValueDefinition", e.INPUT_OBJECT_TYPE_DEFINITION = "InputObjectTypeDefinition", e.DIRECTIVE_DEFINITION = "DirectiveDefinition", e.SCHEMA_EXTENSION = "SchemaExtension", e.SCALAR_TYPE_EXTENSION = "ScalarTypeExtension", e.OBJECT_TYPE_EXTENSION = "ObjectTypeExtension", e.INTERFACE_TYPE_EXTENSION = "InterfaceTypeExtension", e.UNION_TYPE_EXTENSION = "UnionTypeExtension", e.ENUM_TYPE_EXTENSION = "EnumTypeExtension", e.INPUT_OBJECT_TYPE_EXTENSION = "InputObjectTypeExtension";
})(le || (le = {}));
const bX = Object.freeze({});
function m$(e, t, n = v$) {
  const r = /* @__PURE__ */ new Map();
  for (const m of Object.values(le))
    r.set(m, _X(t, m));
  let i, s = Array.isArray(e), a = [e], o = -1, l = [], c = e, u, f;
  const d = [], h = [];
  do {
    o++;
    const m = o === a.length, x = m && l.length !== 0;
    if (m) {
      if (u = h.length === 0 ? void 0 : d[d.length - 1], c = f, f = h.pop(), x)
        if (s) {
          c = c.slice();
          let y = 0;
          for (const [b, w] of l) {
            const E = b - y;
            w === null ? (c.splice(E, 1), y++) : c[E] = w;
          }
        } else {
          c = Object.defineProperties(
            {},
            Object.getOwnPropertyDescriptors(c)
          );
          for (const [y, b] of l)
            c[y] = b;
        }
      o = i.index, a = i.keys, l = i.edits, s = i.inArray, i = i.prev;
    } else if (f) {
      if (u = s ? o : a[o], c = f[u], c == null)
        continue;
      d.push(u);
    }
    let _;
    if (!Array.isArray(c)) {
      var p, g;
      Ty(c) || Nl(!1, `Invalid AST Node: ${sp(c)}.`);
      const y = m ? (p = r.get(c.kind)) === null || p === void 0 ? void 0 : p.leave : (g = r.get(c.kind)) === null || g === void 0 ? void 0 : g.enter;
      if (_ = y == null ? void 0 : y.call(t, c, u, f, d, h), _ === bX)
        break;
      if (_ === !1) {
        if (!m) {
          d.pop();
          continue;
        }
      } else if (_ !== void 0 && (l.push([u, _]), !m))
        if (Ty(_))
          c = _;
        else {
          d.pop();
          continue;
        }
    }
    if (_ === void 0 && x && l.push([u, c]), m)
      d.pop();
    else {
      var v;
      i = {
        inArray: s,
        index: o,
        keys: a,
        edits: l,
        prev: i
      }, s = Array.isArray(c), a = s ? c : (v = n[c.kind]) !== null && v !== void 0 ? v : [], o = -1, l = [], f && h.push(f), f = c;
    }
  } while (i !== void 0);
  return l.length !== 0 ? l[l.length - 1][1] : e;
}
function _X(e, t) {
  const n = e[t];
  return typeof n == "object" ? n : typeof n == "function" ? {
    enter: n,
    leave: void 0
  } : {
    enter: e.enter,
    leave: e.leave
  };
}
function i0(e) {
  return e === 9 || e === 32;
}
function co(e) {
  return e >= 48 && e <= 57;
}
function y$(e) {
  return e >= 97 && e <= 122 || // A-Z
  e >= 65 && e <= 90;
}
function x$(e) {
  return y$(e) || e === 95;
}
function wX(e) {
  return y$(e) || co(e) || e === 95;
}
function $X(e) {
  var t;
  let n = Number.MAX_SAFE_INTEGER, r = null, i = -1;
  for (let a = 0; a < e.length; ++a) {
    var s;
    const o = e[a], l = EX(o);
    l !== o.length && (r = (s = r) !== null && s !== void 0 ? s : a, i = a, a !== 0 && l < n && (n = l));
  }
  return e.map((a, o) => o === 0 ? a : a.slice(n)).slice(
    (t = r) !== null && t !== void 0 ? t : 0,
    i + 1
  );
}
function EX(e) {
  let t = 0;
  for (; t < e.length && i0(e.charCodeAt(t)); )
    ++t;
  return t;
}
function AX(e, t) {
  const n = e.replace(/"""/g, '\\"""'), r = n.split(/\r\n|[\n\r]/g), i = r.length === 1, s = r.length > 1 && r.slice(1).every((h) => h.length === 0 || i0(h.charCodeAt(0))), a = n.endsWith('\\"""'), o = e.endsWith('"') && !a, l = e.endsWith("\\"), c = o || l, u = !(t != null && t.minimize) && // add leading and trailing new lines only if it improves readability
  (!i || e.length > 70 || c || s || a);
  let f = "";
  const d = i && i0(e.charCodeAt(0));
  return (u && !d || s) && (f += `
`), f += n, (u || c) && (f += `
`), '"""' + f + '"""';
}
function kX(e) {
  return `"${e.replace(CX, DX)}"`;
}
const CX = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function DX(e) {
  return SX[e.charCodeAt(0)];
}
const SX = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 2F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 3F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 4F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  // 5F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 6F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
];
function b$(e) {
  return m$(e, OX);
}
const TX = 80, OX = {
  Name: {
    leave: (e) => e.value
  },
  Variable: {
    leave: (e) => "$" + e.name
  },
  // Document
  Document: {
    leave: (e) => ie(e.definitions, `

`)
  },
  OperationDefinition: {
    leave(e) {
      const t = Ce("(", ie(e.variableDefinitions, ", "), ")"), n = ie(
        [
          e.operation,
          ie([e.name, t]),
          ie(e.directives, " ")
        ],
        " "
      );
      return (n === "query" ? "" : n + " ") + e.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable: e, type: t, defaultValue: n, directives: r }) => e + ": " + t + Ce(" = ", n) + Ce(" ", ie(r, " "))
  },
  SelectionSet: {
    leave: ({ selections: e }) => bn(e)
  },
  Field: {
    leave({ alias: e, name: t, arguments: n, directives: r, selectionSet: i }) {
      const s = Ce("", e, ": ") + t;
      let a = s + Ce("(", ie(n, ", "), ")");
      return a.length > TX && (a = s + Ce(`(
`, Ll(ie(n, `
`)), `
)`)), ie([a, ie(r, " "), i], " ");
    }
  },
  Argument: {
    leave: ({ name: e, value: t }) => e + ": " + t
  },
  // Fragments
  FragmentSpread: {
    leave: ({ name: e, directives: t }) => "..." + e + Ce(" ", ie(t, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition: e, directives: t, selectionSet: n }) => ie(
      [
        "...",
        Ce("on ", e),
        ie(t, " "),
        n
      ],
      " "
    )
  },
  FragmentDefinition: {
    leave: ({ name: e, typeCondition: t, variableDefinitions: n, directives: r, selectionSet: i }) => (
      // or removed in the future.
      `fragment ${e}${Ce("(", ie(n, ", "), ")")} on ${t} ${Ce("", ie(r, " "), " ")}` + i
    )
  },
  // Value
  IntValue: {
    leave: ({ value: e }) => e
  },
  FloatValue: {
    leave: ({ value: e }) => e
  },
  StringValue: {
    leave: ({ value: e, block: t }) => t ? AX(e) : kX(e)
  },
  BooleanValue: {
    leave: ({ value: e }) => e ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value: e }) => e
  },
  ListValue: {
    leave: ({ values: e }) => "[" + ie(e, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields: e }) => "{" + ie(e, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name: e, value: t }) => e + ": " + t
  },
  // Directive
  Directive: {
    leave: ({ name: e, arguments: t }) => "@" + e + Ce("(", ie(t, ", "), ")")
  },
  // Type
  NamedType: {
    leave: ({ name: e }) => e
  },
  ListType: {
    leave: ({ type: e }) => "[" + e + "]"
  },
  NonNullType: {
    leave: ({ type: e }) => e + "!"
  },
  // Type System Definitions
  SchemaDefinition: {
    leave: ({ description: e, directives: t, operationTypes: n }) => Ce("", e, `
`) + ie(["schema", ie(t, " "), bn(n)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation: e, type: t }) => e + ": " + t
  },
  ScalarTypeDefinition: {
    leave: ({ description: e, name: t, directives: n }) => Ce("", e, `
`) + ie(["scalar", t, ie(n, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description: e, name: t, interfaces: n, directives: r, fields: i }) => Ce("", e, `
`) + ie(
      [
        "type",
        t,
        Ce("implements ", ie(n, " & ")),
        ie(r, " "),
        bn(i)
      ],
      " "
    )
  },
  FieldDefinition: {
    leave: ({ description: e, name: t, arguments: n, type: r, directives: i }) => Ce("", e, `
`) + t + (Oy(n) ? Ce(`(
`, Ll(ie(n, `
`)), `
)`) : Ce("(", ie(n, ", "), ")")) + ": " + r + Ce(" ", ie(i, " "))
  },
  InputValueDefinition: {
    leave: ({ description: e, name: t, type: n, defaultValue: r, directives: i }) => Ce("", e, `
`) + ie(
      [t + ": " + n, Ce("= ", r), ie(i, " ")],
      " "
    )
  },
  InterfaceTypeDefinition: {
    leave: ({ description: e, name: t, interfaces: n, directives: r, fields: i }) => Ce("", e, `
`) + ie(
      [
        "interface",
        t,
        Ce("implements ", ie(n, " & ")),
        ie(r, " "),
        bn(i)
      ],
      " "
    )
  },
  UnionTypeDefinition: {
    leave: ({ description: e, name: t, directives: n, types: r }) => Ce("", e, `
`) + ie(
      ["union", t, ie(n, " "), Ce("= ", ie(r, " | "))],
      " "
    )
  },
  EnumTypeDefinition: {
    leave: ({ description: e, name: t, directives: n, values: r }) => Ce("", e, `
`) + ie(["enum", t, ie(n, " "), bn(r)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description: e, name: t, directives: n }) => Ce("", e, `
`) + ie([t, ie(n, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description: e, name: t, directives: n, fields: r }) => Ce("", e, `
`) + ie(["input", t, ie(n, " "), bn(r)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description: e, name: t, arguments: n, repeatable: r, locations: i }) => Ce("", e, `
`) + "directive @" + t + (Oy(n) ? Ce(`(
`, Ll(ie(n, `
`)), `
)`) : Ce("(", ie(n, ", "), ")")) + (r ? " repeatable" : "") + " on " + ie(i, " | ")
  },
  SchemaExtension: {
    leave: ({ directives: e, operationTypes: t }) => ie(
      ["extend schema", ie(e, " "), bn(t)],
      " "
    )
  },
  ScalarTypeExtension: {
    leave: ({ name: e, directives: t }) => ie(["extend scalar", e, ie(t, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name: e, interfaces: t, directives: n, fields: r }) => ie(
      [
        "extend type",
        e,
        Ce("implements ", ie(t, " & ")),
        ie(n, " "),
        bn(r)
      ],
      " "
    )
  },
  InterfaceTypeExtension: {
    leave: ({ name: e, interfaces: t, directives: n, fields: r }) => ie(
      [
        "extend interface",
        e,
        Ce("implements ", ie(t, " & ")),
        ie(n, " "),
        bn(r)
      ],
      " "
    )
  },
  UnionTypeExtension: {
    leave: ({ name: e, directives: t, types: n }) => ie(
      [
        "extend union",
        e,
        ie(t, " "),
        Ce("= ", ie(n, " | "))
      ],
      " "
    )
  },
  EnumTypeExtension: {
    leave: ({ name: e, directives: t, values: n }) => ie(["extend enum", e, ie(t, " "), bn(n)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name: e, directives: t, fields: n }) => ie(["extend input", e, ie(t, " "), bn(n)], " ")
  }
};
function ie(e, t = "") {
  var n;
  return (n = e == null ? void 0 : e.filter((r) => r).join(t)) !== null && n !== void 0 ? n : "";
}
function bn(e) {
  return Ce(`{
`, Ll(ie(e, `
`)), `
}`);
}
function Ce(e, t, n = "") {
  return t != null && t !== "" ? e + t + n : "";
}
function Ll(e) {
  return Ce("  ", e.replace(/\n/g, `
  `));
}
function Oy(e) {
  var t;
  return (t = e == null ? void 0 : e.some((n) => n.includes(`
`))) !== null && t !== void 0 ? t : !1;
}
function MX(e) {
  return typeof e == "object" && e !== null;
}
function FX(e, t) {
  if (!!!e)
    throw new Error(
      t ?? "Unexpected invariant triggered."
    );
}
const PX = /\r\n|[\n\r]/g;
function s0(e, t) {
  let n = 0, r = 1;
  for (const i of e.body.matchAll(PX)) {
    if (typeof i.index == "number" || FX(!1), i.index >= t)
      break;
    n = i.index + i[0].length, r += 1;
  }
  return {
    line: r,
    column: t + 1 - n
  };
}
function IX(e) {
  return _$(
    e.source,
    s0(e.source, e.start)
  );
}
function _$(e, t) {
  const n = e.locationOffset.column - 1, r = "".padStart(n) + e.body, i = t.line - 1, s = e.locationOffset.line - 1, a = t.line + s, o = t.line === 1 ? n : 0, l = t.column + o, c = `${e.name}:${a}:${l}
`, u = r.split(/\r\n|[\n\r]/g), f = u[i];
  if (f.length > 120) {
    const d = Math.floor(l / 80), h = l % 80, p = [];
    for (let g = 0; g < f.length; g += 80)
      p.push(f.slice(g, g + 80));
    return c + My([
      [`${a} |`, p[0]],
      ...p.slice(1, d + 1).map((g) => ["|", g]),
      ["|", "^".padStart(h)],
      ["|", p[d + 1]]
    ]);
  }
  return c + My([
    // Lines specified like this: ["prefix", "string"],
    [`${a - 1} |`, u[i - 1]],
    [`${a} |`, f],
    ["|", "^".padStart(l)],
    [`${a + 1} |`, u[i + 1]]
  ]);
}
function My(e) {
  const t = e.filter(([r, i]) => i !== void 0), n = Math.max(...t.map(([r]) => r.length));
  return t.map(([r, i]) => r.padStart(n) + (i ? " " + i : "")).join(`
`);
}
function RX(e) {
  const t = e[0];
  return t == null || "kind" in t || "length" in t ? {
    nodes: t,
    source: e[1],
    positions: e[2],
    path: e[3],
    originalError: e[4],
    extensions: e[5]
  } : t;
}
class uo extends Error {
  /**
   * An array of `{ line, column }` locations within the source GraphQL document
   * which correspond to this error.
   *
   * Errors during validation often contain multiple locations, for example to
   * point out two things with the same name. Errors during execution include a
   * single location, the field which produced the error.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array describing the JSON-path into the execution response which
   * corresponds to this error. Only included for errors during execution.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array of GraphQL AST Nodes corresponding to this error.
   */
  /**
   * The source GraphQL document for the first location of this error.
   *
   * Note that if this Error represents more than one node, the source may not
   * represent nodes after the first node.
   */
  /**
   * An array of character offsets within the source GraphQL document
   * which correspond to this error.
   */
  /**
   * The original error thrown from a field resolver during execution.
   */
  /**
   * Extension fields to add to the formatted error.
   */
  /**
   * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
   */
  constructor(t, ...n) {
    var r, i, s;
    const { nodes: a, source: o, positions: l, path: c, originalError: u, extensions: f } = RX(n);
    super(t), this.name = "GraphQLError", this.path = c ?? void 0, this.originalError = u ?? void 0, this.nodes = Fy(
      Array.isArray(a) ? a : a ? [a] : void 0
    );
    const d = Fy(
      (r = this.nodes) === null || r === void 0 ? void 0 : r.map((p) => p.loc).filter((p) => p != null)
    );
    this.source = o ?? (d == null || (i = d[0]) === null || i === void 0 ? void 0 : i.source), this.positions = l ?? (d == null ? void 0 : d.map((p) => p.start)), this.locations = l && o ? l.map((p) => s0(o, p)) : d == null ? void 0 : d.map((p) => s0(p.source, p.start));
    const h = MX(
      u == null ? void 0 : u.extensions
    ) ? u == null ? void 0 : u.extensions : void 0;
    this.extensions = (s = f ?? h) !== null && s !== void 0 ? s : /* @__PURE__ */ Object.create(null), Object.defineProperties(this, {
      message: {
        writable: !0,
        enumerable: !0
      },
      name: {
        enumerable: !1
      },
      nodes: {
        enumerable: !1
      },
      source: {
        enumerable: !1
      },
      positions: {
        enumerable: !1
      },
      originalError: {
        enumerable: !1
      }
    }), u != null && u.stack ? Object.defineProperty(this, "stack", {
      value: u.stack,
      writable: !0,
      configurable: !0
    }) : Error.captureStackTrace ? Error.captureStackTrace(this, uo) : Object.defineProperty(this, "stack", {
      value: Error().stack,
      writable: !0,
      configurable: !0
    });
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    let t = this.message;
    if (this.nodes)
      for (const n of this.nodes)
        n.loc && (t += `

` + IX(n.loc));
    else if (this.source && this.locations)
      for (const n of this.locations)
        t += `

` + _$(this.source, n);
    return t;
  }
  toJSON() {
    const t = {
      message: this.message
    };
    return this.locations != null && (t.locations = this.locations), this.path != null && (t.path = this.path), this.extensions != null && Object.keys(this.extensions).length > 0 && (t.extensions = this.extensions), t;
  }
}
function Fy(e) {
  return e === void 0 || e.length === 0 ? void 0 : e;
}
function Mt(e, t, n) {
  return new uo(`Syntax Error: ${n}`, {
    source: e,
    positions: [t]
  });
}
let a0;
(function(e) {
  e.QUERY = "QUERY", e.MUTATION = "MUTATION", e.SUBSCRIPTION = "SUBSCRIPTION", e.FIELD = "FIELD", e.FRAGMENT_DEFINITION = "FRAGMENT_DEFINITION", e.FRAGMENT_SPREAD = "FRAGMENT_SPREAD", e.INLINE_FRAGMENT = "INLINE_FRAGMENT", e.VARIABLE_DEFINITION = "VARIABLE_DEFINITION", e.SCHEMA = "SCHEMA", e.SCALAR = "SCALAR", e.OBJECT = "OBJECT", e.FIELD_DEFINITION = "FIELD_DEFINITION", e.ARGUMENT_DEFINITION = "ARGUMENT_DEFINITION", e.INTERFACE = "INTERFACE", e.UNION = "UNION", e.ENUM = "ENUM", e.ENUM_VALUE = "ENUM_VALUE", e.INPUT_OBJECT = "INPUT_OBJECT", e.INPUT_FIELD_DEFINITION = "INPUT_FIELD_DEFINITION";
})(a0 || (a0 = {}));
let q;
(function(e) {
  e.SOF = "<SOF>", e.EOF = "<EOF>", e.BANG = "!", e.DOLLAR = "$", e.AMP = "&", e.PAREN_L = "(", e.PAREN_R = ")", e.SPREAD = "...", e.COLON = ":", e.EQUALS = "=", e.AT = "@", e.BRACKET_L = "[", e.BRACKET_R = "]", e.BRACE_L = "{", e.PIPE = "|", e.BRACE_R = "}", e.NAME = "Name", e.INT = "Int", e.FLOAT = "Float", e.STRING = "String", e.BLOCK_STRING = "BlockString", e.COMMENT = "Comment";
})(q || (q = {}));
class BX {
  /**
   * The previously focused non-ignored token.
   */
  /**
   * The currently focused non-ignored token.
   */
  /**
   * The (1-indexed) line containing the current token.
   */
  /**
   * The character offset at which the current line begins.
   */
  constructor(t) {
    const n = new g$(q.SOF, 0, 0, 0, 0);
    this.source = t, this.lastToken = n, this.token = n, this.line = 1, this.lineStart = 0;
  }
  get [Symbol.toStringTag]() {
    return "Lexer";
  }
  /**
   * Advances the token stream to the next non-ignored token.
   */
  advance() {
    return this.lastToken = this.token, this.token = this.lookahead();
  }
  /**
   * Looks ahead and returns the next non-ignored token, but does not change
   * the state of Lexer.
   */
  lookahead() {
    let t = this.token;
    if (t.kind !== q.EOF)
      do
        if (t.next)
          t = t.next;
        else {
          const n = LX(this, t.end);
          t.next = n, n.prev = t, t = n;
        }
      while (t.kind === q.COMMENT);
    return t;
  }
}
function NX(e) {
  return e === q.BANG || e === q.DOLLAR || e === q.AMP || e === q.PAREN_L || e === q.PAREN_R || e === q.SPREAD || e === q.COLON || e === q.EQUALS || e === q.AT || e === q.BRACKET_L || e === q.BRACKET_R || e === q.BRACE_L || e === q.PIPE || e === q.BRACE_R;
}
function Ws(e) {
  return e >= 0 && e <= 55295 || e >= 57344 && e <= 1114111;
}
function Du(e, t) {
  return w$(e.charCodeAt(t)) && $$(e.charCodeAt(t + 1));
}
function w$(e) {
  return e >= 55296 && e <= 56319;
}
function $$(e) {
  return e >= 56320 && e <= 57343;
}
function wi(e, t) {
  const n = e.source.body.codePointAt(t);
  if (n === void 0)
    return q.EOF;
  if (n >= 32 && n <= 126) {
    const r = String.fromCodePoint(n);
    return r === '"' ? `'"'` : `"${r}"`;
  }
  return "U+" + n.toString(16).toUpperCase().padStart(4, "0");
}
function bt(e, t, n, r, i) {
  const s = e.line, a = 1 + n - e.lineStart;
  return new g$(t, n, r, s, a, i);
}
function LX(e, t) {
  const n = e.source.body, r = n.length;
  let i = t;
  for (; i < r; ) {
    const s = n.charCodeAt(i);
    switch (s) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++i;
        continue;
      case 10:
        ++i, ++e.line, e.lineStart = i;
        continue;
      case 13:
        n.charCodeAt(i + 1) === 10 ? i += 2 : ++i, ++e.line, e.lineStart = i;
        continue;
      case 35:
        return jX(e, i);
      case 33:
        return bt(e, q.BANG, i, i + 1);
      case 36:
        return bt(e, q.DOLLAR, i, i + 1);
      case 38:
        return bt(e, q.AMP, i, i + 1);
      case 40:
        return bt(e, q.PAREN_L, i, i + 1);
      case 41:
        return bt(e, q.PAREN_R, i, i + 1);
      case 46:
        if (n.charCodeAt(i + 1) === 46 && n.charCodeAt(i + 2) === 46)
          return bt(e, q.SPREAD, i, i + 3);
        break;
      case 58:
        return bt(e, q.COLON, i, i + 1);
      case 61:
        return bt(e, q.EQUALS, i, i + 1);
      case 64:
        return bt(e, q.AT, i, i + 1);
      case 91:
        return bt(e, q.BRACKET_L, i, i + 1);
      case 93:
        return bt(e, q.BRACKET_R, i, i + 1);
      case 123:
        return bt(e, q.BRACE_L, i, i + 1);
      case 124:
        return bt(e, q.PIPE, i, i + 1);
      case 125:
        return bt(e, q.BRACE_R, i, i + 1);
      case 34:
        return n.charCodeAt(i + 1) === 34 && n.charCodeAt(i + 2) === 34 ? YX(e, i) : VX(e, i);
    }
    if (co(s) || s === 45)
      return zX(e, i, s);
    if (x$(s))
      return qX(e, i);
    throw Mt(
      e.source,
      i,
      s === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : Ws(s) || Du(n, i) ? `Unexpected character: ${wi(e, i)}.` : `Invalid character: ${wi(e, i)}.`
    );
  }
  return bt(e, q.EOF, r, r);
}
function jX(e, t) {
  const n = e.source.body, r = n.length;
  let i = t + 1;
  for (; i < r; ) {
    const s = n.charCodeAt(i);
    if (s === 10 || s === 13)
      break;
    if (Ws(s))
      ++i;
    else if (Du(n, i))
      i += 2;
    else
      break;
  }
  return bt(
    e,
    q.COMMENT,
    t,
    i,
    n.slice(t + 1, i)
  );
}
function zX(e, t, n) {
  const r = e.source.body;
  let i = t, s = n, a = !1;
  if (s === 45 && (s = r.charCodeAt(++i)), s === 48) {
    if (s = r.charCodeAt(++i), co(s))
      throw Mt(
        e.source,
        i,
        `Invalid number, unexpected digit after 0: ${wi(
          e,
          i
        )}.`
      );
  } else
    i = ff(e, i, s), s = r.charCodeAt(i);
  if (s === 46 && (a = !0, s = r.charCodeAt(++i), i = ff(e, i, s), s = r.charCodeAt(i)), (s === 69 || s === 101) && (a = !0, s = r.charCodeAt(++i), (s === 43 || s === 45) && (s = r.charCodeAt(++i)), i = ff(e, i, s), s = r.charCodeAt(i)), s === 46 || x$(s))
    throw Mt(
      e.source,
      i,
      `Invalid number, expected digit but got: ${wi(
        e,
        i
      )}.`
    );
  return bt(
    e,
    a ? q.FLOAT : q.INT,
    t,
    i,
    r.slice(t, i)
  );
}
function ff(e, t, n) {
  if (!co(n))
    throw Mt(
      e.source,
      t,
      `Invalid number, expected digit but got: ${wi(
        e,
        t
      )}.`
    );
  const r = e.source.body;
  let i = t + 1;
  for (; co(r.charCodeAt(i)); )
    ++i;
  return i;
}
function VX(e, t) {
  const n = e.source.body, r = n.length;
  let i = t + 1, s = i, a = "";
  for (; i < r; ) {
    const o = n.charCodeAt(i);
    if (o === 34)
      return a += n.slice(s, i), bt(e, q.STRING, t, i + 1, a);
    if (o === 92) {
      a += n.slice(s, i);
      const l = n.charCodeAt(i + 1) === 117 ? n.charCodeAt(i + 2) === 123 ? HX(e, i) : WX(e, i) : UX(e, i);
      a += l.value, i += l.size, s = i;
      continue;
    }
    if (o === 10 || o === 13)
      break;
    if (Ws(o))
      ++i;
    else if (Du(n, i))
      i += 2;
    else
      throw Mt(
        e.source,
        i,
        `Invalid character within String: ${wi(
          e,
          i
        )}.`
      );
  }
  throw Mt(e.source, i, "Unterminated string.");
}
function HX(e, t) {
  const n = e.source.body;
  let r = 0, i = 3;
  for (; i < 12; ) {
    const s = n.charCodeAt(t + i++);
    if (s === 125) {
      if (i < 5 || !Ws(r))
        break;
      return {
        value: String.fromCodePoint(r),
        size: i
      };
    }
    if (r = r << 4 | $a(s), r < 0)
      break;
  }
  throw Mt(
    e.source,
    t,
    `Invalid Unicode escape sequence: "${n.slice(
      t,
      t + i
    )}".`
  );
}
function WX(e, t) {
  const n = e.source.body, r = Py(n, t + 2);
  if (Ws(r))
    return {
      value: String.fromCodePoint(r),
      size: 6
    };
  if (w$(r) && n.charCodeAt(t + 6) === 92 && n.charCodeAt(t + 7) === 117) {
    const i = Py(n, t + 8);
    if ($$(i))
      return {
        value: String.fromCodePoint(r, i),
        size: 12
      };
  }
  throw Mt(
    e.source,
    t,
    `Invalid Unicode escape sequence: "${n.slice(t, t + 6)}".`
  );
}
function Py(e, t) {
  return $a(e.charCodeAt(t)) << 12 | $a(e.charCodeAt(t + 1)) << 8 | $a(e.charCodeAt(t + 2)) << 4 | $a(e.charCodeAt(t + 3));
}
function $a(e) {
  return e >= 48 && e <= 57 ? e - 48 : e >= 65 && e <= 70 ? e - 55 : e >= 97 && e <= 102 ? e - 87 : -1;
}
function UX(e, t) {
  const n = e.source.body;
  switch (n.charCodeAt(t + 1)) {
    case 34:
      return {
        value: '"',
        size: 2
      };
    case 92:
      return {
        value: "\\",
        size: 2
      };
    case 47:
      return {
        value: "/",
        size: 2
      };
    case 98:
      return {
        value: "\b",
        size: 2
      };
    case 102:
      return {
        value: "\f",
        size: 2
      };
    case 110:
      return {
        value: `
`,
        size: 2
      };
    case 114:
      return {
        value: "\r",
        size: 2
      };
    case 116:
      return {
        value: "	",
        size: 2
      };
  }
  throw Mt(
    e.source,
    t,
    `Invalid character escape sequence: "${n.slice(
      t,
      t + 2
    )}".`
  );
}
function YX(e, t) {
  const n = e.source.body, r = n.length;
  let i = e.lineStart, s = t + 3, a = s, o = "";
  const l = [];
  for (; s < r; ) {
    const c = n.charCodeAt(s);
    if (c === 34 && n.charCodeAt(s + 1) === 34 && n.charCodeAt(s + 2) === 34) {
      o += n.slice(a, s), l.push(o);
      const u = bt(
        e,
        q.BLOCK_STRING,
        t,
        s + 3,
        // Return a string of the lines joined with U+000A.
        $X(l).join(`
`)
      );
      return e.line += l.length - 1, e.lineStart = i, u;
    }
    if (c === 92 && n.charCodeAt(s + 1) === 34 && n.charCodeAt(s + 2) === 34 && n.charCodeAt(s + 3) === 34) {
      o += n.slice(a, s), a = s + 1, s += 4;
      continue;
    }
    if (c === 10 || c === 13) {
      o += n.slice(a, s), l.push(o), c === 13 && n.charCodeAt(s + 1) === 10 ? s += 2 : ++s, o = "", a = s, i = s;
      continue;
    }
    if (Ws(c))
      ++s;
    else if (Du(n, s))
      s += 2;
    else
      throw Mt(
        e.source,
        s,
        `Invalid character within String: ${wi(
          e,
          s
        )}.`
      );
  }
  throw Mt(e.source, s, "Unterminated string.");
}
function qX(e, t) {
  const n = e.source.body, r = n.length;
  let i = t + 1;
  for (; i < r; ) {
    const s = n.charCodeAt(i);
    if (wX(s))
      ++i;
    else
      break;
  }
  return bt(
    e,
    q.NAME,
    t,
    i,
    n.slice(t, i)
  );
}
const GX = (
  /* c8 ignore next 6 */
  // FIXME: https://github.com/graphql/graphql-js/issues/2317
  // eslint-disable-next-line no-undef
  process.env.NODE_ENV === "production" ? function(t, n) {
    return t instanceof n;
  } : function(t, n) {
    if (t instanceof n)
      return !0;
    if (typeof t == "object" && t !== null) {
      var r;
      const i = n.prototype[Symbol.toStringTag], s = (
        // We still need to support constructor's name to detect conflicts with older versions of this library.
        Symbol.toStringTag in t ? t[Symbol.toStringTag] : (r = t.constructor) === null || r === void 0 ? void 0 : r.name
      );
      if (i === s) {
        const a = sp(t);
        throw new Error(`Cannot use ${i} "${a}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
      }
    }
    return !1;
  }
);
class E$ {
  constructor(t, n = "GraphQL request", r = {
    line: 1,
    column: 1
  }) {
    typeof t == "string" || Nl(!1, `Body must be a string. Received: ${sp(t)}.`), this.body = t, this.name = n, this.locationOffset = r, this.locationOffset.line > 0 || Nl(
      !1,
      "line in locationOffset is 1-indexed and must be positive."
    ), this.locationOffset.column > 0 || Nl(
      !1,
      "column in locationOffset is 1-indexed and must be positive."
    );
  }
  get [Symbol.toStringTag]() {
    return "Source";
  }
}
function XX(e) {
  return GX(e, E$);
}
function ZX(e, t) {
  return new KX(e, t).parseDocument();
}
class KX {
  constructor(t, n) {
    const r = XX(t) ? t : new E$(t);
    this._lexer = new BX(r), this._options = n;
  }
  /**
   * Converts a name lex token into a name parse node.
   */
  parseName() {
    const t = this.expectToken(q.NAME);
    return this.node(t, {
      kind: le.NAME,
      value: t.value
    });
  }
  // Implements the parsing rules in the Document section.
  /**
   * Document : Definition+
   */
  parseDocument() {
    return this.node(this._lexer.token, {
      kind: le.DOCUMENT,
      definitions: this.many(
        q.SOF,
        this.parseDefinition,
        q.EOF
      )
    });
  }
  /**
   * Definition :
   *   - ExecutableDefinition
   *   - TypeSystemDefinition
   *   - TypeSystemExtension
   *
   * ExecutableDefinition :
   *   - OperationDefinition
   *   - FragmentDefinition
   *
   * TypeSystemDefinition :
   *   - SchemaDefinition
   *   - TypeDefinition
   *   - DirectiveDefinition
   *
   * TypeDefinition :
   *   - ScalarTypeDefinition
   *   - ObjectTypeDefinition
   *   - InterfaceTypeDefinition
   *   - UnionTypeDefinition
   *   - EnumTypeDefinition
   *   - InputObjectTypeDefinition
   */
  parseDefinition() {
    if (this.peek(q.BRACE_L))
      return this.parseOperationDefinition();
    const t = this.peekDescription(), n = t ? this._lexer.lookahead() : this._lexer.token;
    if (n.kind === q.NAME) {
      switch (n.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition();
      }
      if (t)
        throw Mt(
          this._lexer.source,
          this._lexer.token.start,
          "Unexpected description, descriptions are supported only on type definitions."
        );
      switch (n.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
        case "extend":
          return this.parseTypeSystemExtension();
      }
    }
    throw this.unexpected(n);
  }
  // Implements the parsing rules in the Operations section.
  /**
   * OperationDefinition :
   *  - SelectionSet
   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
   */
  parseOperationDefinition() {
    const t = this._lexer.token;
    if (this.peek(q.BRACE_L))
      return this.node(t, {
        kind: le.OPERATION_DEFINITION,
        operation: rs.QUERY,
        name: void 0,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet()
      });
    const n = this.parseOperationType();
    let r;
    return this.peek(q.NAME) && (r = this.parseName()), this.node(t, {
      kind: le.OPERATION_DEFINITION,
      operation: n,
      name: r,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * OperationType : one of query mutation subscription
   */
  parseOperationType() {
    const t = this.expectToken(q.NAME);
    switch (t.value) {
      case "query":
        return rs.QUERY;
      case "mutation":
        return rs.MUTATION;
      case "subscription":
        return rs.SUBSCRIPTION;
    }
    throw this.unexpected(t);
  }
  /**
   * VariableDefinitions : ( VariableDefinition+ )
   */
  parseVariableDefinitions() {
    return this.optionalMany(
      q.PAREN_L,
      this.parseVariableDefinition,
      q.PAREN_R
    );
  }
  /**
   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
   */
  parseVariableDefinition() {
    return this.node(this._lexer.token, {
      kind: le.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(q.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(q.EQUALS) ? this.parseConstValueLiteral() : void 0,
      directives: this.parseConstDirectives()
    });
  }
  /**
   * Variable : $ Name
   */
  parseVariable() {
    const t = this._lexer.token;
    return this.expectToken(q.DOLLAR), this.node(t, {
      kind: le.VARIABLE,
      name: this.parseName()
    });
  }
  /**
   * ```
   * SelectionSet : { Selection+ }
   * ```
   */
  parseSelectionSet() {
    return this.node(this._lexer.token, {
      kind: le.SELECTION_SET,
      selections: this.many(
        q.BRACE_L,
        this.parseSelection,
        q.BRACE_R
      )
    });
  }
  /**
   * Selection :
   *   - Field
   *   - FragmentSpread
   *   - InlineFragment
   */
  parseSelection() {
    return this.peek(q.SPREAD) ? this.parseFragment() : this.parseField();
  }
  /**
   * Field : Alias? Name Arguments? Directives? SelectionSet?
   *
   * Alias : Name :
   */
  parseField() {
    const t = this._lexer.token, n = this.parseName();
    let r, i;
    return this.expectOptionalToken(q.COLON) ? (r = n, i = this.parseName()) : i = n, this.node(t, {
      kind: le.FIELD,
      alias: r,
      name: i,
      arguments: this.parseArguments(!1),
      directives: this.parseDirectives(!1),
      selectionSet: this.peek(q.BRACE_L) ? this.parseSelectionSet() : void 0
    });
  }
  /**
   * Arguments[Const] : ( Argument[?Const]+ )
   */
  parseArguments(t) {
    const n = t ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(q.PAREN_L, n, q.PAREN_R);
  }
  /**
   * Argument[Const] : Name : Value[?Const]
   */
  parseArgument(t = !1) {
    const n = this._lexer.token, r = this.parseName();
    return this.expectToken(q.COLON), this.node(n, {
      kind: le.ARGUMENT,
      name: r,
      value: this.parseValueLiteral(t)
    });
  }
  parseConstArgument() {
    return this.parseArgument(!0);
  }
  // Implements the parsing rules in the Fragments section.
  /**
   * Corresponds to both FragmentSpread and InlineFragment in the spec.
   *
   * FragmentSpread : ... FragmentName Directives?
   *
   * InlineFragment : ... TypeCondition? Directives? SelectionSet
   */
  parseFragment() {
    const t = this._lexer.token;
    this.expectToken(q.SPREAD);
    const n = this.expectOptionalKeyword("on");
    return !n && this.peek(q.NAME) ? this.node(t, {
      kind: le.FRAGMENT_SPREAD,
      name: this.parseFragmentName(),
      directives: this.parseDirectives(!1)
    }) : this.node(t, {
      kind: le.INLINE_FRAGMENT,
      typeCondition: n ? this.parseNamedType() : void 0,
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentDefinition :
   *   - fragment FragmentName on TypeCondition Directives? SelectionSet
   *
   * TypeCondition : NamedType
   */
  parseFragmentDefinition() {
    var t;
    const n = this._lexer.token;
    return this.expectKeyword("fragment"), ((t = this._options) === null || t === void 0 ? void 0 : t.allowLegacyFragmentVariables) === !0 ? this.node(n, {
      kind: le.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      variableDefinitions: this.parseVariableDefinitions(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    }) : this.node(n, {
      kind: le.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentName : Name but not `on`
   */
  parseFragmentName() {
    if (this._lexer.token.value === "on")
      throw this.unexpected();
    return this.parseName();
  }
  // Implements the parsing rules in the Values section.
  /**
   * Value[Const] :
   *   - [~Const] Variable
   *   - IntValue
   *   - FloatValue
   *   - StringValue
   *   - BooleanValue
   *   - NullValue
   *   - EnumValue
   *   - ListValue[?Const]
   *   - ObjectValue[?Const]
   *
   * BooleanValue : one of `true` `false`
   *
   * NullValue : `null`
   *
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseValueLiteral(t) {
    const n = this._lexer.token;
    switch (n.kind) {
      case q.BRACKET_L:
        return this.parseList(t);
      case q.BRACE_L:
        return this.parseObject(t);
      case q.INT:
        return this._lexer.advance(), this.node(n, {
          kind: le.INT,
          value: n.value
        });
      case q.FLOAT:
        return this._lexer.advance(), this.node(n, {
          kind: le.FLOAT,
          value: n.value
        });
      case q.STRING:
      case q.BLOCK_STRING:
        return this.parseStringLiteral();
      case q.NAME:
        switch (this._lexer.advance(), n.value) {
          case "true":
            return this.node(n, {
              kind: le.BOOLEAN,
              value: !0
            });
          case "false":
            return this.node(n, {
              kind: le.BOOLEAN,
              value: !1
            });
          case "null":
            return this.node(n, {
              kind: le.NULL
            });
          default:
            return this.node(n, {
              kind: le.ENUM,
              value: n.value
            });
        }
      case q.DOLLAR:
        if (t)
          if (this.expectToken(q.DOLLAR), this._lexer.token.kind === q.NAME) {
            const r = this._lexer.token.value;
            throw Mt(
              this._lexer.source,
              n.start,
              `Unexpected variable "$${r}" in constant value.`
            );
          } else
            throw this.unexpected(n);
        return this.parseVariable();
      default:
        throw this.unexpected();
    }
  }
  parseConstValueLiteral() {
    return this.parseValueLiteral(!0);
  }
  parseStringLiteral() {
    const t = this._lexer.token;
    return this._lexer.advance(), this.node(t, {
      kind: le.STRING,
      value: t.value,
      block: t.kind === q.BLOCK_STRING
    });
  }
  /**
   * ListValue[Const] :
   *   - [ ]
   *   - [ Value[?Const]+ ]
   */
  parseList(t) {
    const n = () => this.parseValueLiteral(t);
    return this.node(this._lexer.token, {
      kind: le.LIST,
      values: this.any(q.BRACKET_L, n, q.BRACKET_R)
    });
  }
  /**
   * ```
   * ObjectValue[Const] :
   *   - { }
   *   - { ObjectField[?Const]+ }
   * ```
   */
  parseObject(t) {
    const n = () => this.parseObjectField(t);
    return this.node(this._lexer.token, {
      kind: le.OBJECT,
      fields: this.any(q.BRACE_L, n, q.BRACE_R)
    });
  }
  /**
   * ObjectField[Const] : Name : Value[?Const]
   */
  parseObjectField(t) {
    const n = this._lexer.token, r = this.parseName();
    return this.expectToken(q.COLON), this.node(n, {
      kind: le.OBJECT_FIELD,
      name: r,
      value: this.parseValueLiteral(t)
    });
  }
  // Implements the parsing rules in the Directives section.
  /**
   * Directives[Const] : Directive[?Const]+
   */
  parseDirectives(t) {
    const n = [];
    for (; this.peek(q.AT); )
      n.push(this.parseDirective(t));
    return n;
  }
  parseConstDirectives() {
    return this.parseDirectives(!0);
  }
  /**
   * ```
   * Directive[Const] : @ Name Arguments[?Const]?
   * ```
   */
  parseDirective(t) {
    const n = this._lexer.token;
    return this.expectToken(q.AT), this.node(n, {
      kind: le.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(t)
    });
  }
  // Implements the parsing rules in the Types section.
  /**
   * Type :
   *   - NamedType
   *   - ListType
   *   - NonNullType
   */
  parseTypeReference() {
    const t = this._lexer.token;
    let n;
    if (this.expectOptionalToken(q.BRACKET_L)) {
      const r = this.parseTypeReference();
      this.expectToken(q.BRACKET_R), n = this.node(t, {
        kind: le.LIST_TYPE,
        type: r
      });
    } else
      n = this.parseNamedType();
    return this.expectOptionalToken(q.BANG) ? this.node(t, {
      kind: le.NON_NULL_TYPE,
      type: n
    }) : n;
  }
  /**
   * NamedType : Name
   */
  parseNamedType() {
    return this.node(this._lexer.token, {
      kind: le.NAMED_TYPE,
      name: this.parseName()
    });
  }
  // Implements the parsing rules in the Type Definition section.
  peekDescription() {
    return this.peek(q.STRING) || this.peek(q.BLOCK_STRING);
  }
  /**
   * Description : StringValue
   */
  parseDescription() {
    if (this.peekDescription())
      return this.parseStringLiteral();
  }
  /**
   * ```
   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
   * ```
   */
  parseSchemaDefinition() {
    const t = this._lexer.token, n = this.parseDescription();
    this.expectKeyword("schema");
    const r = this.parseConstDirectives(), i = this.many(
      q.BRACE_L,
      this.parseOperationTypeDefinition,
      q.BRACE_R
    );
    return this.node(t, {
      kind: le.SCHEMA_DEFINITION,
      description: n,
      directives: r,
      operationTypes: i
    });
  }
  /**
   * OperationTypeDefinition : OperationType : NamedType
   */
  parseOperationTypeDefinition() {
    const t = this._lexer.token, n = this.parseOperationType();
    this.expectToken(q.COLON);
    const r = this.parseNamedType();
    return this.node(t, {
      kind: le.OPERATION_TYPE_DEFINITION,
      operation: n,
      type: r
    });
  }
  /**
   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
   */
  parseScalarTypeDefinition() {
    const t = this._lexer.token, n = this.parseDescription();
    this.expectKeyword("scalar");
    const r = this.parseName(), i = this.parseConstDirectives();
    return this.node(t, {
      kind: le.SCALAR_TYPE_DEFINITION,
      description: n,
      name: r,
      directives: i
    });
  }
  /**
   * ObjectTypeDefinition :
   *   Description?
   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
   */
  parseObjectTypeDefinition() {
    const t = this._lexer.token, n = this.parseDescription();
    this.expectKeyword("type");
    const r = this.parseName(), i = this.parseImplementsInterfaces(), s = this.parseConstDirectives(), a = this.parseFieldsDefinition();
    return this.node(t, {
      kind: le.OBJECT_TYPE_DEFINITION,
      description: n,
      name: r,
      interfaces: i,
      directives: s,
      fields: a
    });
  }
  /**
   * ImplementsInterfaces :
   *   - implements `&`? NamedType
   *   - ImplementsInterfaces & NamedType
   */
  parseImplementsInterfaces() {
    return this.expectOptionalKeyword("implements") ? this.delimitedMany(q.AMP, this.parseNamedType) : [];
  }
  /**
   * ```
   * FieldsDefinition : { FieldDefinition+ }
   * ```
   */
  parseFieldsDefinition() {
    return this.optionalMany(
      q.BRACE_L,
      this.parseFieldDefinition,
      q.BRACE_R
    );
  }
  /**
   * FieldDefinition :
   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
   */
  parseFieldDefinition() {
    const t = this._lexer.token, n = this.parseDescription(), r = this.parseName(), i = this.parseArgumentDefs();
    this.expectToken(q.COLON);
    const s = this.parseTypeReference(), a = this.parseConstDirectives();
    return this.node(t, {
      kind: le.FIELD_DEFINITION,
      description: n,
      name: r,
      arguments: i,
      type: s,
      directives: a
    });
  }
  /**
   * ArgumentsDefinition : ( InputValueDefinition+ )
   */
  parseArgumentDefs() {
    return this.optionalMany(
      q.PAREN_L,
      this.parseInputValueDef,
      q.PAREN_R
    );
  }
  /**
   * InputValueDefinition :
   *   - Description? Name : Type DefaultValue? Directives[Const]?
   */
  parseInputValueDef() {
    const t = this._lexer.token, n = this.parseDescription(), r = this.parseName();
    this.expectToken(q.COLON);
    const i = this.parseTypeReference();
    let s;
    this.expectOptionalToken(q.EQUALS) && (s = this.parseConstValueLiteral());
    const a = this.parseConstDirectives();
    return this.node(t, {
      kind: le.INPUT_VALUE_DEFINITION,
      description: n,
      name: r,
      type: i,
      defaultValue: s,
      directives: a
    });
  }
  /**
   * InterfaceTypeDefinition :
   *   - Description? interface Name Directives[Const]? FieldsDefinition?
   */
  parseInterfaceTypeDefinition() {
    const t = this._lexer.token, n = this.parseDescription();
    this.expectKeyword("interface");
    const r = this.parseName(), i = this.parseImplementsInterfaces(), s = this.parseConstDirectives(), a = this.parseFieldsDefinition();
    return this.node(t, {
      kind: le.INTERFACE_TYPE_DEFINITION,
      description: n,
      name: r,
      interfaces: i,
      directives: s,
      fields: a
    });
  }
  /**
   * UnionTypeDefinition :
   *   - Description? union Name Directives[Const]? UnionMemberTypes?
   */
  parseUnionTypeDefinition() {
    const t = this._lexer.token, n = this.parseDescription();
    this.expectKeyword("union");
    const r = this.parseName(), i = this.parseConstDirectives(), s = this.parseUnionMemberTypes();
    return this.node(t, {
      kind: le.UNION_TYPE_DEFINITION,
      description: n,
      name: r,
      directives: i,
      types: s
    });
  }
  /**
   * UnionMemberTypes :
   *   - = `|`? NamedType
   *   - UnionMemberTypes | NamedType
   */
  parseUnionMemberTypes() {
    return this.expectOptionalToken(q.EQUALS) ? this.delimitedMany(q.PIPE, this.parseNamedType) : [];
  }
  /**
   * EnumTypeDefinition :
   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
   */
  parseEnumTypeDefinition() {
    const t = this._lexer.token, n = this.parseDescription();
    this.expectKeyword("enum");
    const r = this.parseName(), i = this.parseConstDirectives(), s = this.parseEnumValuesDefinition();
    return this.node(t, {
      kind: le.ENUM_TYPE_DEFINITION,
      description: n,
      name: r,
      directives: i,
      values: s
    });
  }
  /**
   * ```
   * EnumValuesDefinition : { EnumValueDefinition+ }
   * ```
   */
  parseEnumValuesDefinition() {
    return this.optionalMany(
      q.BRACE_L,
      this.parseEnumValueDefinition,
      q.BRACE_R
    );
  }
  /**
   * EnumValueDefinition : Description? EnumValue Directives[Const]?
   */
  parseEnumValueDefinition() {
    const t = this._lexer.token, n = this.parseDescription(), r = this.parseEnumValueName(), i = this.parseConstDirectives();
    return this.node(t, {
      kind: le.ENUM_VALUE_DEFINITION,
      description: n,
      name: r,
      directives: i
    });
  }
  /**
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseEnumValueName() {
    if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null")
      throw Mt(
        this._lexer.source,
        this._lexer.token.start,
        `${gl(
          this._lexer.token
        )} is reserved and cannot be used for an enum value.`
      );
    return this.parseName();
  }
  /**
   * InputObjectTypeDefinition :
   *   - Description? input Name Directives[Const]? InputFieldsDefinition?
   */
  parseInputObjectTypeDefinition() {
    const t = this._lexer.token, n = this.parseDescription();
    this.expectKeyword("input");
    const r = this.parseName(), i = this.parseConstDirectives(), s = this.parseInputFieldsDefinition();
    return this.node(t, {
      kind: le.INPUT_OBJECT_TYPE_DEFINITION,
      description: n,
      name: r,
      directives: i,
      fields: s
    });
  }
  /**
   * ```
   * InputFieldsDefinition : { InputValueDefinition+ }
   * ```
   */
  parseInputFieldsDefinition() {
    return this.optionalMany(
      q.BRACE_L,
      this.parseInputValueDef,
      q.BRACE_R
    );
  }
  /**
   * TypeSystemExtension :
   *   - SchemaExtension
   *   - TypeExtension
   *
   * TypeExtension :
   *   - ScalarTypeExtension
   *   - ObjectTypeExtension
   *   - InterfaceTypeExtension
   *   - UnionTypeExtension
   *   - EnumTypeExtension
   *   - InputObjectTypeDefinition
   */
  parseTypeSystemExtension() {
    const t = this._lexer.lookahead();
    if (t.kind === q.NAME)
      switch (t.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension();
      }
    throw this.unexpected(t);
  }
  /**
   * ```
   * SchemaExtension :
   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
   *  - extend schema Directives[Const]
   * ```
   */
  parseSchemaExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("schema");
    const n = this.parseConstDirectives(), r = this.optionalMany(
      q.BRACE_L,
      this.parseOperationTypeDefinition,
      q.BRACE_R
    );
    if (n.length === 0 && r.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: le.SCHEMA_EXTENSION,
      directives: n,
      operationTypes: r
    });
  }
  /**
   * ScalarTypeExtension :
   *   - extend scalar Name Directives[Const]
   */
  parseScalarTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("scalar");
    const n = this.parseName(), r = this.parseConstDirectives();
    if (r.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: le.SCALAR_TYPE_EXTENSION,
      name: n,
      directives: r
    });
  }
  /**
   * ObjectTypeExtension :
   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend type Name ImplementsInterfaces? Directives[Const]
   *  - extend type Name ImplementsInterfaces
   */
  parseObjectTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("type");
    const n = this.parseName(), r = this.parseImplementsInterfaces(), i = this.parseConstDirectives(), s = this.parseFieldsDefinition();
    if (r.length === 0 && i.length === 0 && s.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: le.OBJECT_TYPE_EXTENSION,
      name: n,
      interfaces: r,
      directives: i,
      fields: s
    });
  }
  /**
   * InterfaceTypeExtension :
   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend interface Name ImplementsInterfaces? Directives[Const]
   *  - extend interface Name ImplementsInterfaces
   */
  parseInterfaceTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("interface");
    const n = this.parseName(), r = this.parseImplementsInterfaces(), i = this.parseConstDirectives(), s = this.parseFieldsDefinition();
    if (r.length === 0 && i.length === 0 && s.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: le.INTERFACE_TYPE_EXTENSION,
      name: n,
      interfaces: r,
      directives: i,
      fields: s
    });
  }
  /**
   * UnionTypeExtension :
   *   - extend union Name Directives[Const]? UnionMemberTypes
   *   - extend union Name Directives[Const]
   */
  parseUnionTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("union");
    const n = this.parseName(), r = this.parseConstDirectives(), i = this.parseUnionMemberTypes();
    if (r.length === 0 && i.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: le.UNION_TYPE_EXTENSION,
      name: n,
      directives: r,
      types: i
    });
  }
  /**
   * EnumTypeExtension :
   *   - extend enum Name Directives[Const]? EnumValuesDefinition
   *   - extend enum Name Directives[Const]
   */
  parseEnumTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("enum");
    const n = this.parseName(), r = this.parseConstDirectives(), i = this.parseEnumValuesDefinition();
    if (r.length === 0 && i.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: le.ENUM_TYPE_EXTENSION,
      name: n,
      directives: r,
      values: i
    });
  }
  /**
   * InputObjectTypeExtension :
   *   - extend input Name Directives[Const]? InputFieldsDefinition
   *   - extend input Name Directives[Const]
   */
  parseInputObjectTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("input");
    const n = this.parseName(), r = this.parseConstDirectives(), i = this.parseInputFieldsDefinition();
    if (r.length === 0 && i.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: le.INPUT_OBJECT_TYPE_EXTENSION,
      name: n,
      directives: r,
      fields: i
    });
  }
  /**
   * ```
   * DirectiveDefinition :
   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
   * ```
   */
  parseDirectiveDefinition() {
    const t = this._lexer.token, n = this.parseDescription();
    this.expectKeyword("directive"), this.expectToken(q.AT);
    const r = this.parseName(), i = this.parseArgumentDefs(), s = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    const a = this.parseDirectiveLocations();
    return this.node(t, {
      kind: le.DIRECTIVE_DEFINITION,
      description: n,
      name: r,
      arguments: i,
      repeatable: s,
      locations: a
    });
  }
  /**
   * DirectiveLocations :
   *   - `|`? DirectiveLocation
   *   - DirectiveLocations | DirectiveLocation
   */
  parseDirectiveLocations() {
    return this.delimitedMany(q.PIPE, this.parseDirectiveLocation);
  }
  /*
   * DirectiveLocation :
   *   - ExecutableDirectiveLocation
   *   - TypeSystemDirectiveLocation
   *
   * ExecutableDirectiveLocation : one of
   *   `QUERY`
   *   `MUTATION`
   *   `SUBSCRIPTION`
   *   `FIELD`
   *   `FRAGMENT_DEFINITION`
   *   `FRAGMENT_SPREAD`
   *   `INLINE_FRAGMENT`
   *
   * TypeSystemDirectiveLocation : one of
   *   `SCHEMA`
   *   `SCALAR`
   *   `OBJECT`
   *   `FIELD_DEFINITION`
   *   `ARGUMENT_DEFINITION`
   *   `INTERFACE`
   *   `UNION`
   *   `ENUM`
   *   `ENUM_VALUE`
   *   `INPUT_OBJECT`
   *   `INPUT_FIELD_DEFINITION`
   */
  parseDirectiveLocation() {
    const t = this._lexer.token, n = this.parseName();
    if (Object.prototype.hasOwnProperty.call(a0, n.value))
      return n;
    throw this.unexpected(t);
  }
  // Core parsing utility functions
  /**
   * Returns a node that, if configured to do so, sets a "loc" field as a
   * location object, used to identify the place in the source that created a
   * given parsed object.
   */
  node(t, n) {
    var r;
    return ((r = this._options) === null || r === void 0 ? void 0 : r.noLocation) !== !0 && (n.loc = new yX(
      t,
      this._lexer.lastToken,
      this._lexer.source
    )), n;
  }
  /**
   * Determines if the next token is of a given kind
   */
  peek(t) {
    return this._lexer.token.kind === t;
  }
  /**
   * If the next token is of the given kind, return that token after advancing the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectToken(t) {
    const n = this._lexer.token;
    if (n.kind === t)
      return this._lexer.advance(), n;
    throw Mt(
      this._lexer.source,
      n.start,
      `Expected ${A$(t)}, found ${gl(n)}.`
    );
  }
  /**
   * If the next token is of the given kind, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalToken(t) {
    return this._lexer.token.kind === t ? (this._lexer.advance(), !0) : !1;
  }
  /**
   * If the next token is a given keyword, advance the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectKeyword(t) {
    const n = this._lexer.token;
    if (n.kind === q.NAME && n.value === t)
      this._lexer.advance();
    else
      throw Mt(
        this._lexer.source,
        n.start,
        `Expected "${t}", found ${gl(n)}.`
      );
  }
  /**
   * If the next token is a given keyword, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalKeyword(t) {
    const n = this._lexer.token;
    return n.kind === q.NAME && n.value === t ? (this._lexer.advance(), !0) : !1;
  }
  /**
   * Helper function for creating an error when an unexpected lexed token is encountered.
   */
  unexpected(t) {
    const n = t ?? this._lexer.token;
    return Mt(
      this._lexer.source,
      n.start,
      `Unexpected ${gl(n)}.`
    );
  }
  /**
   * Returns a possibly empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  any(t, n, r) {
    this.expectToken(t);
    const i = [];
    for (; !this.expectOptionalToken(r); )
      i.push(n.call(this));
    return i;
  }
  /**
   * Returns a list of parse nodes, determined by the parseFn.
   * It can be empty only if open token is missing otherwise it will always return non-empty list
   * that begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  optionalMany(t, n, r) {
    if (this.expectOptionalToken(t)) {
      const i = [];
      do
        i.push(n.call(this));
      while (!this.expectOptionalToken(r));
      return i;
    }
    return [];
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  many(t, n, r) {
    this.expectToken(t);
    const i = [];
    do
      i.push(n.call(this));
    while (!this.expectOptionalToken(r));
    return i;
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
   * Advances the parser to the next lex token after last item in the list.
   */
  delimitedMany(t, n) {
    this.expectOptionalToken(t);
    const r = [];
    do
      r.push(n.call(this));
    while (this.expectOptionalToken(t));
    return r;
  }
}
function gl(e) {
  const t = e.value;
  return A$(e.kind) + (t != null ? ` "${t}"` : "");
}
function A$(e) {
  return NX(e) ? `"${e}"` : e;
}
function Dt(e, t) {
  return t.tag = e, t;
}
function An() {
}
function JX(e) {
  return function(t) {
    var n = e.length;
    let r = !1, i = !1, s = !1, a = 0;
    t(
      Dt(0, [
        function(o) {
          if (o)
            r = !0;
          else if (i)
            s = !0;
          else {
            for (i = s = !0; s && !r; )
              a < n ? (o = e[a], a = a + 1 | 0, s = !1, t(Dt(1, [o]))) : (r = !0, t(0));
            i = !1;
          }
        }
      ])
    );
  };
}
function QX() {
}
function eZ(e) {
  e(0);
}
function tZ(e) {
  return e(0);
}
function k$(e) {
  return function(t) {
    return function(n) {
      let r = An, i = !1, s = [], a = !1;
      t(function(o) {
        typeof o == "number" ? a || (a = !0, s.length === 0 && n(0)) : o.tag ? a || (i = !1, function(l) {
          function c(d) {
            typeof d == "number" ? s.length !== 0 && (s = s.filter(u), d = s.length === 0, a && d ? n(0) : !i && d && (i = !0, r(0))) : d.tag ? s.length !== 0 && (n(Dt(1, [d[0]])), f(0)) : (f = d = d[0], s = s.concat(d), d(0));
          }
          function u(d) {
            return d !== f;
          }
          let f = An;
          l.length === 1 ? l(c) : l.bind(null, c);
        }(e(o[0])), i || (i = !0, r(0))) : r = o[0];
      }), n(
        Dt(0, [
          function(o) {
            o ? (a || (a = !0, r(o)), s.forEach(function(l) {
              return l(o);
            }), s = []) : (i || a ? i = !1 : (i = !0, r(0)), s.forEach(tZ));
          }
        ])
      );
    };
  };
}
function nZ(e) {
  return e;
}
function To(e) {
  return function(t) {
    return function(n) {
      let r = !1;
      return t(function(i) {
        if (typeof i == "number")
          r || (r = !0, n(i));
        else if (i.tag)
          r || (e(i[0]), n(i));
        else {
          var s = i[0];
          n(
            Dt(0, [
              function(a) {
                if (!r)
                  return a && (r = !0), s(a);
              }
            ])
          );
        }
      });
    };
  };
}
function rZ(e) {
  e(0);
}
function iZ(e) {
  return function(t) {
    return function(n) {
      function r(u) {
        o && (typeof u == "number" ? (o = !1, c ? n(u) : s || (s = !0, i(0))) : u.tag ? (n(u), l ? l = !1 : a(0)) : (a = u = u[0], l = !1, u(0)));
      }
      let i = An, s = !1, a = An, o = !1, l = !1, c = !1;
      t(function(u) {
        typeof u == "number" ? c || (c = !0, o || n(0)) : u.tag ? c || (o && (a(1), a = An), s ? s = !1 : (s = !0, i(0)), u = e(u[0]), o = !0, u(r)) : i = u[0];
      }), n(
        Dt(0, [
          function(u) {
            if (u) {
              if (c || (c = !0, i(1)), o)
                return o = !1, a(1);
            } else
              c || s || (s = !0, i(0)), o && !l && (l = !0, a(0));
          }
        ])
      );
    };
  };
}
function Ia(e) {
  return function(t) {
    let n = An, r = !1;
    return t(function(i) {
      typeof i == "number" ? r = !0 : i.tag ? r || (e(i[0]), n(0)) : (n = i = i[0], i(0));
    }), {
      unsubscribe: function() {
        if (!r)
          return r = !0, n(1);
      }
    };
  };
}
function sZ() {
}
function dn(e) {
  return function(t) {
    return function(n) {
      let r = An;
      return t(function(i) {
        typeof i == "number" ? n(i) : i.tag ? e(i[0]) ? n(i) : r(0) : (r = i[0], n(i));
      });
    };
  };
}
function Iy(e) {
  return function(t) {
    let n = !1;
    t(
      Dt(0, [
        function(r) {
          r ? n = !0 : n || (n = !0, t(Dt(1, [e])), t(0));
        }
      ])
    );
  };
}
function C$(e) {
  return function(t) {
    let n = QX, r = !1;
    n = e({
      next: function(i) {
        r || t(Dt(1, [i]));
      },
      complete: function() {
        r || (r = !0, t(0));
      }
    }), t(
      Dt(0, [
        function(i) {
          if (i && !r)
            return r = !0, n();
        }
      ])
    );
  };
}
function Ry() {
  let e = [], t = !1;
  return {
    source: function(n) {
      function r(i) {
        return i !== n;
      }
      e = e.concat(n), n(
        Dt(0, [
          function(i) {
            i && (e = e.filter(r));
          }
        ])
      );
    },
    next: function(n) {
      t || e.forEach(function(r) {
        r(Dt(1, [n]));
      });
    },
    complete: function() {
      t || (t = !0, e.forEach(eZ));
    }
  };
}
function Ra(e) {
  return function(t) {
    return function(n) {
      return t(function(r) {
        r = typeof r == "number" ? 0 : r.tag ? Dt(1, [e(r[0])]) : Dt(0, [r[0]]), n(r);
      });
    };
  };
}
function Fc(e) {
  return k$(nZ)(JX(e));
}
function By(e) {
  return function(t) {
    return function(n) {
      let r = !1;
      return t(function(i) {
        if (typeof i == "number")
          return r ? void 0 : (r = !0, n(i), e());
        if (i.tag)
          r || n(i);
        else {
          var s = i[0];
          n(
            Dt(0, [
              function(a) {
                if (!r)
                  return a ? (r = !0, s(a), e()) : s(a);
              }
            ])
          );
        }
      });
    };
  };
}
function Ny(e) {
  return function(t) {
    return function(n) {
      return t(function(r) {
        typeof r == "number" || r.tag ? n(r) : (n(r), e());
      });
    };
  };
}
function aZ(e) {
  return Ia(sZ)(e);
}
function Pc(e) {
  function t(s) {
    typeof s == "number" ? (n.forEach(rZ), n = []) : s.tag ? (i = !1, n.forEach(function(a) {
      a(s);
    })) : r = s[0];
  }
  let n = [], r = An, i = !1;
  return function(s) {
    function a(o) {
      return o !== s;
    }
    n = n.concat(s), n.length === 1 && e(t), s(
      Dt(0, [
        function(o) {
          if (o) {
            if (n = n.filter(a), n.length === 0)
              return r(1);
          } else
            i || (i = !0, r(o));
        }
      ])
    );
  };
}
function Ly(e) {
  return function(t) {
    return function(n) {
      let r = !1, i = 0, s = An;
      t(function(a) {
        typeof a == "number" ? r || (r = !0, n(0)) : a.tag ? i < e && !r && (i = i + 1 | 0, n(a), !r && i >= e && (r = !0, n(0), s(1))) : (a = a[0], 0 >= e ? (r = !0, n(0), a(1)) : s = a);
      }), n(
        Dt(0, [
          function(a) {
            if (!r) {
              if (a)
                return r = !0, s(1);
              if (i < e)
                return s(0);
            }
          }
        ])
      );
    };
  };
}
function D$(e) {
  return function(t) {
    return function(n) {
      function r(o) {
        typeof o != "number" && (o.tag ? (i = !0, s(1), n(0)) : (a = o = o[0], o(0)));
      }
      let i = !1, s = An, a = An;
      t(function(o) {
        typeof o == "number" ? i || (i = !0, a(1), n(0)) : o.tag ? i || n(o) : (s = o[0], e(r));
      }), n(
        Dt(0, [
          function(o) {
            if (!i)
              return o ? (i = !0, s(1), a(1)) : s(0);
          }
        ])
      );
    };
  };
}
typeof Symbol == "function" && (Symbol.observable || (Symbol.observable = Symbol("observable")));
function oZ(e) {
  return typeof e == "string" ? new uo(e) : typeof e == "object" && e.message ? new uo(e.message, e.nodes, e.source, e.positions, e.path, e, e.extensions || {}) : e;
}
var ap = function(e) {
  function t(n) {
    var r = n.networkError, i = n.response, s = (n.graphQLErrors || []).map(oZ), a = function(l, c) {
      var u = "";
      return l !== void 0 ? u = "[Network] " + l.message : (c !== void 0 && c.forEach(function(f) {
        u += "[GraphQL] " + f.message + `
`;
      }), u.trim());
    }(r, s);
    e.call(this, a), this.name = "CombinedError", this.message = a, this.graphQLErrors = s, this.networkError = r, this.response = i;
  }
  return e && (t.__proto__ = e), (t.prototype = Object.create(e && e.prototype)).constructor = t, t.prototype.toString = function() {
    return this.message;
  }, t;
}(Error);
function S$(e, t) {
  e |= 0;
  for (var n = 0, r = 0 | t.length; n < r; n++)
    e = (e << 5) + e + t.charCodeAt(n);
  return e;
}
function jy(e) {
  return S$(5381, e) >>> 0;
}
var jl = /* @__PURE__ */ new Set(), zy = /* @__PURE__ */ new WeakMap();
function Ea(e) {
  if (e === null || jl.has(e))
    return "null";
  if (typeof e != "object")
    return JSON.stringify(e) || "";
  if (e.toJSON)
    return Ea(e.toJSON());
  if (Array.isArray(e)) {
    for (var t = "[", n = 0, r = e.length; n < r; n++) {
      n > 0 && (t += ",");
      var i = Ea(e[n]);
      t += i.length > 0 ? i : "null";
    }
    return t += "]";
  }
  var s = Object.keys(e).sort();
  if (!s.length && e.constructor && e.constructor !== Object) {
    var a = zy.get(e) || Math.random().toString(36).slice(2);
    return zy.set(e, a), '{"__key":"' + a + '"}';
  }
  jl.add(e);
  for (var o = "{", l = 0, c = s.length; l < c; l++) {
    var u = s[l], f = Ea(e[u]);
    f && (o.length > 1 && (o += ","), o += Ea(u) + ":" + f);
  }
  return jl.delete(e), o += "}";
}
function o0(e) {
  return jl.clear(), Ea(e);
}
var lZ = /("{3}[\s\S]*"{3}|"(?:\\.|[^"])*")/g, cZ = /([\s,]|#[^\n\r]+)+/g;
function uZ(e, t) {
  return t % 2 == 0 ? e.replace(cZ, " ").trim() : e;
}
function df(e) {
  var t = (typeof e != "string" ? e.loc && e.loc.source.body || b$(e) : e).split(lZ).map(uZ).join("");
  if (typeof e != "string") {
    var n = "definitions" in e && O$(e);
    n && (t = "# " + n + `
` + t), e.loc || (e.loc = {
      start: 0,
      end: t.length,
      source: {
        body: t,
        name: "gql",
        locationOffset: {
          line: 1,
          column: 1
        }
      }
    });
  }
  return t;
}
var hf = /* @__PURE__ */ new Map();
function T$(e) {
  var t, n;
  return typeof e == "string" ? (t = jy(df(e)), n = hf.get(t) || ZX(e, {
    noLocation: !0
  })) : (t = e.__key || jy(df(e)), n = hf.get(t) || e), n.loc || df(n), n.__key = t, hf.set(t, n), n;
}
function pf(e, t) {
  t || (t = {});
  var n = T$(e);
  return {
    key: S$(n.__key, o0(t)) >>> 0,
    query: n,
    variables: t
  };
}
function O$(e) {
  for (var t = 0, n = e.definitions.length; t < n; t++) {
    var r = e.definitions[t];
    if (r.kind === le.OPERATION_DEFINITION && r.name)
      return r.name.value;
  }
}
function fZ(e) {
  for (var t = 0, n = e.definitions.length; t < n; t++) {
    var r = e.definitions[t];
    if (r.kind === le.OPERATION_DEFINITION)
      return r.operation;
  }
}
function pt() {
  return pt = Object.assign || function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, pt.apply(this, arguments);
}
function gf(e, t, n) {
  if (!("data" in t) && !("errors" in t) || "path" in t)
    throw new Error("No Content");
  return {
    operation: e,
    data: t.data,
    error: Array.isArray(t.errors) ? new ap({
      graphQLErrors: t.errors,
      response: n
    }) : void 0,
    extensions: typeof t.extensions == "object" && t.extensions || void 0,
    hasNext: !!t.hasNext
  };
}
function dZ(e, t, n) {
  var r = pt({}, e);
  if (r.hasNext = !!t.hasNext, !("path" in t))
    return "data" in t && (r.data = t.data), r;
  Array.isArray(t.errors) && (r.error = new ap({
    graphQLErrors: r.error ? r.error.graphQLErrors.concat(t.errors) : t.errors,
    response: n
  }));
  for (var i = r.data = pt({}, r.data), s = 0, a; s < t.path.length; )
    i = i[a = t.path[s++]] = Array.isArray(i[a]) ? [].concat(i[a]) : pt({}, i[a]);
  return pt(i, t.data), r;
}
function Vy(e, t, n) {
  return {
    operation: e,
    data: void 0,
    error: new ap({
      networkError: t,
      response: n
    }),
    extensions: void 0
  };
}
function M$(e) {
  return e.kind === "query" && !!e.context.preferGetMethod;
}
function hZ(e) {
  return {
    query: b$(e.query),
    operationName: O$(e.query),
    variables: e.variables || void 0,
    extensions: void 0
  };
}
function pZ(e, t) {
  var n = M$(e), r = e.context.url;
  if (!n || !t)
    return r;
  var i = [];
  t.operationName && i.push("operationName=" + encodeURIComponent(t.operationName)), t.query && i.push("query=" + encodeURIComponent(t.query.replace(/#[^\n\r]+/g, " ").trim())), t.variables && i.push("variables=" + encodeURIComponent(o0(t.variables))), t.extensions && i.push("extensions=" + encodeURIComponent(o0(t.extensions)));
  var s = r + "?" + i.join("&");
  return s.length > 2047 ? (e.context.preferGetMethod = !1, r) : s;
}
function gZ(e, t) {
  var n = M$(e), r = {
    accept: "application/graphql+json, application/json"
  };
  n || (r["content-type"] = "application/json");
  var i = (typeof e.context.fetchOptions == "function" ? e.context.fetchOptions() : e.context.fetchOptions) || {};
  if (i.headers)
    for (var s in i.headers)
      r[s.toLowerCase()] = i.headers[s];
  return pt({}, i, {
    body: !n && t ? JSON.stringify(t) : void 0,
    method: n ? "GET" : "POST",
    headers: r
  });
}
var vf = typeof Symbol < "u" ? Symbol.asyncIterator : null, vZ = typeof TextDecoder < "u" ? new TextDecoder() : null, mZ = /content-type:[^\r\n]*application\/json/i, yZ = /boundary="?([^=";]+)"?/i;
function xZ(e, t, n) {
  var r = n.redirect === "manual" ? 400 : 300, i = e.context.fetch;
  return C$(function(s) {
    var a = s.next, o = s.complete, l = typeof AbortController < "u" ? new AbortController() : null;
    l && (n.signal = l.signal);
    var c = !1;
    function u(p, g, v) {
      var m = v.headers && v.headers.get("Content-Type") || "";
      if (/text\//i.test(m))
        return v.text().then(function(D) {
          p(Vy(g, new Error(D), v));
        });
      if (!/multipart\/mixed/i.test(m))
        return v.text().then(function(D) {
          p(gf(g, JSON.parse(D), v));
        });
      var x = "---", _ = m.match(yZ);
      _ && (x = "--" + _[1]);
      var y, b = function() {
      };
      if (vf && v[vf]) {
        var w = v[vf]();
        y = w.next.bind(w);
      } else if ("body" in v && v.body) {
        var E = v.body.getReader();
        b = E.cancel.bind(E), y = E.read.bind(E);
      } else
        throw new TypeError("Streaming requests unsupported");
      var $ = "", C = !0, A = null, k = null;
      return y().then(function D(S) {
        if (S.done)
          c = !0;
        else {
          var L = function(z) {
            return z.constructor.name === "Buffer" ? z.toString() : vZ.decode(z);
          }(S.value), P = L.indexOf(x);
          for (P > -1 ? P += $.length : P = $.indexOf(x), $ += L; P > -1; ) {
            var H = $.slice(0, P), M = $.slice(P + x.length);
            if (C)
              C = !1;
            else {
              var B = H.indexOf(`\r
\r
`) + 4, W = H.slice(0, B), R = H.slice(B, H.lastIndexOf(`\r
`)), O = void 0;
              if (mZ.test(W))
                try {
                  O = JSON.parse(R), A = k = k ? dZ(k, O, v) : gf(g, O, v);
                } catch {
                }
              if (M.slice(0, 2) === "--" || O && !O.hasNext) {
                if (!k)
                  return p(gf(g, {}, v));
                break;
              }
            }
            P = ($ = M).indexOf(x);
          }
        }
        if (A && (p(A), A = null), !S.done && (!k || k.hasNext))
          return y().then(D);
      }).finally(b);
    }
    var f = !1, d = !1, h;
    return Promise.resolve().then(function() {
      if (!f)
        return (i || fetch)(t, n);
    }).then(function(p) {
      if (p)
        return d = (h = p).status < 200 || h.status >= r, u(a, e, h);
    }).then(o).catch(function(p) {
      if (c)
        throw p;
      var g = Vy(e, d && h.statusText ? new Error(h.statusText) : p, h);
      a(g), o();
    }), function() {
      f = !0, l && l.abort();
    };
  });
}
function l0(e, t) {
  if (Array.isArray(e))
    for (var n = 0; n < e.length; n++)
      l0(e[n], t);
  else if (typeof e == "object" && e !== null)
    for (var r in e)
      r === "__typename" && typeof e[r] == "string" ? t[e[r]] = 0 : l0(e[r], t);
  return t;
}
function bZ(e) {
  return Object.keys(l0(e, {}));
}
var Hy = function(e) {
  if (e.selectionSet && !e.selectionSet.selections.some(function(t) {
    return t.kind === le.FIELD && t.name.value === "__typename" && !t.alias;
  }))
    return pt({}, e, {
      selectionSet: pt({}, e.selectionSet, {
        selections: e.selectionSet.selections.concat([{
          kind: le.FIELD,
          name: {
            kind: le.NAME,
            value: "__typename"
          }
        }])
      })
    });
}, Wy = /* @__PURE__ */ new Map();
function _Z(e) {
  var t = T$(e), n = Wy.get(t.__key);
  return n || (n = m$(t, {
    Field: Hy,
    InlineFragment: Hy
  }), Object.defineProperty(n, "__key", {
    value: t.__key,
    enumerable: !1
  }), Wy.set(t.__key, n)), n;
}
function c0(e) {
  return !e || typeof e != "object" ? e : Object.keys(e).reduce(function(t, n) {
    var r = e[n];
    return n === "__typename" ? Object.defineProperty(t, "__typename", {
      enumerable: !1,
      value: r
    }) : Array.isArray(r) ? t[n] = r.map(c0) : r && typeof r == "object" && "__typename" in r ? t[n] = c0(r) : t[n] = r, t;
  }, Array.isArray(e) ? [] : {});
}
function Uy(e) {
  return e.toPromise = function() {
    return new Promise(function(t) {
      var n = Ia(function(r) {
        !r.stale && !r.hasNext && Promise.resolve().then(function() {
          n.unsubscribe(), t(r);
        });
      })(e);
    });
  }, e;
}
function fo(e, t, n) {
  return n || (n = t.context), {
    key: t.key,
    query: t.query,
    variables: t.variables,
    kind: e,
    context: n
  };
}
function Yy(e, t) {
  return fo(e.kind, e, pt({}, e.context, {
    meta: pt({}, e.context.meta, t)
  }));
}
function F$() {
}
function mf(e) {
  var t = e.kind;
  return t !== "mutation" && t !== "query";
}
function wZ(e) {
  var t = e.forward, n = e.client, r = e.dispatchDebug, i = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ Object.create(null);
  function a(l) {
    var c = fo(l.kind, l);
    return c.query = _Z(l.query), c;
  }
  function o(l) {
    var c = l.context.requestPolicy;
    return l.kind === "query" && c !== "network-only" && (c === "cache-only" || i.has(l.key));
  }
  return function(l) {
    var c = Pc(l), u = Ra(function(d) {
      var h = i.get(d.key);
      process.env.NODE_ENV !== "production" && r(pt({}, {
        operation: d
      }, h ? {
        type: "cacheHit",
        message: "The result was successfully retried from the cache"
      } : {
        type: "cacheMiss",
        message: "The result could not be retrieved from the cache"
      }));
      var p = pt({}, h, {
        operation: Yy(d, {
          cacheOutcome: h ? "hit" : "miss"
        })
      });
      return d.context.requestPolicy === "cache-and-network" && (p.stale = !0, qy(n, d)), p;
    })(dn(function(d) {
      return !mf(d) && o(d);
    })(c)), f = To(function(d) {
      var h = d.operation;
      if (h) {
        var p = bZ(d.data).concat(h.context.additionalTypenames || []);
        if (d.operation.kind === "mutation") {
          var g = /* @__PURE__ */ new Set();
          process.env.NODE_ENV !== "production" && r({
            type: "cacheInvalidation",
            message: "The following typenames have been invalidated: " + p,
            operation: h,
            data: {
              typenames: p,
              response: d
            },
            source: "cacheExchange"
          });
          for (var v = 0; v < p.length; v++) {
            var m = p[v], x = s[m] || (s[m] = /* @__PURE__ */ new Set());
            x.forEach(function(b) {
              g.add(b);
            }), x.clear();
          }
          g.forEach(function(b) {
            i.has(b) && (h = i.get(b).operation, i.delete(b), qy(n, h));
          });
        } else if (h.kind === "query" && d.data) {
          i.set(h.key, d);
          for (var _ = 0; _ < p.length; _++) {
            var y = p[_];
            (s[y] || (s[y] = /* @__PURE__ */ new Set())).add(h.key);
          }
        }
      }
    })(t(dn(function(d) {
      return d.kind !== "query" || d.context.requestPolicy !== "cache-only";
    })(Ra(function(d) {
      return Yy(d, {
        cacheOutcome: "miss"
      });
    })(Fc([Ra(a)(dn(function(d) {
      return !mf(d) && !o(d);
    })(c)), dn(function(d) {
      return mf(d);
    })(c)])))));
    return Fc([u, f]);
  };
}
function qy(e, t) {
  return e.reexecuteOperation(fo(t.kind, t, pt({}, t.context, {
    requestPolicy: "network-only"
  })));
}
function $Z(e) {
  var t = e.forward, n = e.dispatchDebug, r = /* @__PURE__ */ new Set();
  function i(a) {
    var o = a.key, l = a.kind;
    if (l === "teardown")
      return r.delete(o), !0;
    if (l !== "query" && l !== "subscription")
      return !0;
    var c = r.has(o);
    return r.add(o), c && process.env.NODE_ENV !== "production" && n({
      type: "dedup",
      message: "An operation has been deduped.",
      operation: a,
      source: "dedupExchange"
    }), !c;
  }
  function s(a) {
    a.hasNext || r.delete(a.operation.key);
  }
  return function(a) {
    var o = dn(i)(a);
    return To(s)(t(o));
  };
}
function EZ(e) {
  var t = e.forward, n = e.dispatchDebug;
  return function(r) {
    var i = Pc(r), s = k$(function(o) {
      var l = o.key, c = dn(function(h) {
        return h.kind === "teardown" && h.key === l;
      })(i), u = hZ(o), f = pZ(o, u), d = gZ(o, u);
      return process.env.NODE_ENV !== "production" && n({
        type: "fetchRequest",
        message: "A fetch request is being executed.",
        operation: o,
        data: {
          url: f,
          fetchOptions: d
        },
        source: "fetchExchange"
      }), To(function(h) {
        var p = h.data ? void 0 : h.error;
        process.env.NODE_ENV !== "production" && n({
          type: p ? "fetchError" : "fetchSuccess",
          message: "A " + (p ? "failed" : "successful") + " fetch response has been returned.",
          operation: o,
          data: {
            url: f,
            fetchOptions: d,
            value: p || h
          },
          source: "fetchExchange"
        });
      })(D$(c)(xZ(o, f, d)));
    })(dn(function(o) {
      return o.kind === "query" || o.kind === "mutation";
    })(i)), a = t(dn(function(o) {
      return o.kind !== "query" && o.kind !== "mutation";
    })(i));
    return Fc([s, a]);
  };
}
function P$(e) {
  var t = e.dispatchDebug;
  return function(n) {
    return dn(function() {
      return !1;
    })(To(function(r) {
      if (r.kind !== "teardown" && process.env.NODE_ENV !== "production") {
        var i = 'No exchange has handled operations of kind "' + r.kind + `". Check whether you've added an exchange responsible for these operations.`;
        process.env.NODE_ENV !== "production" && t({
          type: "fallbackCatch",
          message: i,
          operation: r,
          source: "fallbackExchange"
        }), console.warn(i);
      }
    })(n));
  };
}
P$({
  dispatchDebug: F$
});
function AZ(e) {
  return function(t) {
    var n = t.client, r = t.dispatchDebug;
    return e.reduceRight(function(i, s) {
      return s({
        client: n,
        forward: i,
        dispatchDebug: function(o) {
          process.env.NODE_ENV !== "production" && r(pt({}, {
            timestamp: Date.now(),
            source: s.name
          }, o));
        }
      });
    }, t.forward);
  };
}
var kZ = [$Z, wZ, EZ], CZ = function e(t) {
  if (process.env.NODE_ENV !== "production" && !t.url)
    throw new Error("You are creating an urql-client without a url.");
  var n = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map(), i = [], s = Ry(), a = s.source, o = s.next, l = !1;
  function c(_) {
    if (_ && o(_), !l) {
      for (l = !0; l && (_ = i.shift()); )
        o(_);
      l = !1;
    }
  }
  function u(_) {
    var y = dn(function(b) {
      return b.operation.kind === _.kind && b.operation.key === _.key && (!b.operation.context._instance || b.operation.context._instance === _.context._instance);
    })(x);
    return d.maskTypename && (y = Ra(function(b) {
      return pt({}, b, {
        data: c0(b.data)
      });
    })(y)), _.kind === "mutation" ? Ly(1)(Ny(function() {
      return o(_);
    })(y)) : Pc(By(function() {
      n.delete(_.key), r.delete(_.key);
      for (var b = i.length - 1; b >= 0; b--)
        i[b].key === _.key && i.splice(b, 1);
      o(fo("teardown", _, _.context));
    })(To(function(b) {
      n.set(_.key, b);
    })(iZ(function(b) {
      return _.kind !== "query" || b.stale ? Iy(b) : Fc([Iy(b), Ra(function() {
        return pt({}, b, {
          stale: !0
        });
      })(Ly(1)(dn(function(w) {
        return w.kind === "query" && w.key === _.key && w.context.requestPolicy !== "cache-only";
      })(a)))]);
    })(D$(dn(function(b) {
      return b.kind === "teardown" && b.key === _.key;
    })(a))(y)))));
  }
  var f = this instanceof e ? this : Object.create(e.prototype), d = pt(f, {
    url: t.url,
    fetchOptions: t.fetchOptions,
    fetch: t.fetch,
    suspense: !!t.suspense,
    requestPolicy: t.requestPolicy || "cache-first",
    preferGetMethod: !!t.preferGetMethod,
    maskTypename: !!t.maskTypename,
    operations$: a,
    reexecuteOperation: function(y) {
      (y.kind === "mutation" || r.has(y.key)) && (i.push(y), Promise.resolve().then(c));
    },
    createOperationContext: function(y) {
      return y || (y = {}), pt({}, {
        _instance: void 0,
        url: d.url,
        fetchOptions: d.fetchOptions,
        fetch: d.fetch,
        preferGetMethod: d.preferGetMethod
      }, y, {
        suspense: y.suspense || y.suspense !== !1 && d.suspense,
        requestPolicy: y.requestPolicy || d.requestPolicy
      });
    },
    createRequestOperation: function(y, b, w) {
      var E = fZ(b.query);
      if (process.env.NODE_ENV !== "production" && y !== "teardown" && E !== y)
        throw new Error('Expected operation of type "' + y + '" but found "' + E + '"');
      var $ = d.createOperationContext(w);
      return y === "mutation" && ($._instance = []), fo(y, b, $);
    },
    executeRequestOperation: function(y) {
      return y.kind === "mutation" ? u(y) : C$(function(b) {
        var w = r.get(y.key);
        w || r.set(y.key, w = u(y));
        var E = y.context.requestPolicy === "cache-and-network" || y.context.requestPolicy === "network-only";
        return Ia(b.next)(By(function() {
          l = !1, b.complete();
        })(Ny(function() {
          var $ = n.get(y.key);
          if (y.kind === "subscription")
            return c(y);
          E && c(y), $ != null && $ === n.get(y.key) ? b.next(E ? pt({}, $, {
            stale: !0
          }) : $) : E || c(y);
        })(w))).unsubscribe;
      });
    },
    executeQuery: function(y, b) {
      var w = d.createRequestOperation("query", y, b);
      return d.executeRequestOperation(w);
    },
    executeSubscription: function(y, b) {
      var w = d.createRequestOperation("subscription", y, b);
      return d.executeRequestOperation(w);
    },
    executeMutation: function(y, b) {
      var w = d.createRequestOperation("mutation", y, b);
      return d.executeRequestOperation(w);
    },
    query: function(y, b, w) {
      return (!w || typeof w.suspense != "boolean") && (w = pt({}, w, {
        suspense: !1
      })), Uy(d.executeQuery(pf(y, b), w));
    },
    readQuery: function(y, b, w) {
      var E = null;
      return Ia(function($) {
        E = $;
      })(d.query(y, b, w)).unsubscribe(), E;
    },
    subscription: function(y, b, w) {
      return d.executeSubscription(pf(y, b), w);
    },
    mutation: function(y, b, w) {
      return Uy(d.executeMutation(pf(y, b), w));
    }
  }), h = F$;
  if (process.env.NODE_ENV !== "production") {
    var p = Ry(), g = p.next, v = p.source;
    d.subscribeToDebugTarget = function(_) {
      return Ia(_)(v);
    }, h = g;
  }
  var m = AZ(t.exchanges !== void 0 ? t.exchanges : kZ), x = Pc(m({
    client: d,
    dispatchDebug: h,
    forward: P$({
      dispatchDebug: h
    })
  })(a));
  return aZ(x), d;
}, DZ = CZ;
class SZ {
  constructor(t, n) {
    V(this, "_resultType", null);
    V(this, "hooks", new bb());
    V(this, "client");
    V(this, "documents");
    this.documents = n, this.client = DZ({
      url: t
    });
  }
  interceptorRequest(t) {
    this.hooks.attach("request", t);
  }
  interceptorResponse(t) {
    this.hooks.attach("response", t);
  }
  async query(t, n) {
    let r = (o) => {
      if (Kl.getType(o) === "object") {
        let l = {};
        for (let c in o)
          o[c] != null && (l[c] = o[c]);
        return l;
      } else
        return {};
    }, i = {};
    await this.hooks.notify("request", {
      name: t,
      context: i
    });
    let s = await this.client.query(this.documents[t], r(n), i).toPromise(), a = s.data;
    return await this.hooks.notify("response", {
      name: t,
      context: i,
      result: s
    }), a;
  }
}
var TZ = function() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var t = {}, n = Symbol("test"), r = Object(n);
  if (typeof n == "string" || Object.prototype.toString.call(n) !== "[object Symbol]" || Object.prototype.toString.call(r) !== "[object Symbol]")
    return !1;
  var i = 42;
  t[n] = i;
  for (n in t)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0)
    return !1;
  var s = Object.getOwnPropertySymbols(t);
  if (s.length !== 1 || s[0] !== n || !Object.prototype.propertyIsEnumerable.call(t, n))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var a = Object.getOwnPropertyDescriptor(t, n);
    if (a.value !== i || a.enumerable !== !0)
      return !1;
  }
  return !0;
}, Gy = typeof Symbol < "u" && Symbol, OZ = TZ, MZ = function() {
  return typeof Gy != "function" || typeof Symbol != "function" || typeof Gy("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : OZ();
}, Xy = {
  foo: {}
}, FZ = Object, PZ = function() {
  return { __proto__: Xy }.foo === Xy.foo && !({ __proto__: null } instanceof FZ);
}, IZ = "Function.prototype.bind called on incompatible ", RZ = Object.prototype.toString, BZ = Math.max, NZ = "[object Function]", Zy = function(t, n) {
  for (var r = [], i = 0; i < t.length; i += 1)
    r[i] = t[i];
  for (var s = 0; s < n.length; s += 1)
    r[s + t.length] = n[s];
  return r;
}, LZ = function(t, n) {
  for (var r = [], i = n || 0, s = 0; i < t.length; i += 1, s += 1)
    r[s] = t[i];
  return r;
}, jZ = function(e, t) {
  for (var n = "", r = 0; r < e.length; r += 1)
    n += e[r], r + 1 < e.length && (n += t);
  return n;
}, zZ = function(t) {
  var n = this;
  if (typeof n != "function" || RZ.apply(n) !== NZ)
    throw new TypeError(IZ + n);
  for (var r = LZ(arguments, 1), i, s = function() {
    if (this instanceof i) {
      var u = n.apply(
        this,
        Zy(r, arguments)
      );
      return Object(u) === u ? u : this;
    }
    return n.apply(
      t,
      Zy(r, arguments)
    );
  }, a = BZ(0, n.length - r.length), o = [], l = 0; l < a; l++)
    o[l] = "$" + l;
  if (i = Function("binder", "return function (" + jZ(o, ",") + "){ return binder.apply(this,arguments); }")(s), n.prototype) {
    var c = function() {
    };
    c.prototype = n.prototype, i.prototype = new c(), c.prototype = null;
  }
  return i;
}, VZ = zZ, op = Function.prototype.bind || VZ, HZ = Function.prototype.call, WZ = Object.prototype.hasOwnProperty, UZ = op, YZ = UZ.call(HZ, WZ), De, Ds = SyntaxError, I$ = Function, fs = TypeError, yf = function(e) {
  try {
    return I$('"use strict"; return (' + e + ").constructor;")();
  } catch {
  }
}, hi = Object.getOwnPropertyDescriptor;
if (hi)
  try {
    hi({}, "");
  } catch {
    hi = null;
  }
var xf = function() {
  throw new fs();
}, qZ = hi ? function() {
  try {
    return arguments.callee, xf;
  } catch {
    try {
      return hi(arguments, "callee").get;
    } catch {
      return xf;
    }
  }
}() : xf, qi = MZ(), GZ = PZ(), At = Object.getPrototypeOf || (GZ ? function(e) {
  return e.__proto__;
} : null), Qi = {}, XZ = typeof Uint8Array > "u" || !At ? De : At(Uint8Array), pi = {
  "%AggregateError%": typeof AggregateError > "u" ? De : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? De : ArrayBuffer,
  "%ArrayIteratorPrototype%": qi && At ? At([][Symbol.iterator]()) : De,
  "%AsyncFromSyncIteratorPrototype%": De,
  "%AsyncFunction%": Qi,
  "%AsyncGenerator%": Qi,
  "%AsyncGeneratorFunction%": Qi,
  "%AsyncIteratorPrototype%": Qi,
  "%Atomics%": typeof Atomics > "u" ? De : Atomics,
  "%BigInt%": typeof BigInt > "u" ? De : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? De : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? De : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? De : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": EvalError,
  "%Float32Array%": typeof Float32Array > "u" ? De : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? De : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? De : FinalizationRegistry,
  "%Function%": I$,
  "%GeneratorFunction%": Qi,
  "%Int8Array%": typeof Int8Array > "u" ? De : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? De : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? De : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": qi && At ? At(At([][Symbol.iterator]())) : De,
  "%JSON%": typeof JSON == "object" ? JSON : De,
  "%Map%": typeof Map > "u" ? De : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !qi || !At ? De : At((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? De : Promise,
  "%Proxy%": typeof Proxy > "u" ? De : Proxy,
  "%RangeError%": RangeError,
  "%ReferenceError%": ReferenceError,
  "%Reflect%": typeof Reflect > "u" ? De : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? De : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !qi || !At ? De : At((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? De : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": qi && At ? At(""[Symbol.iterator]()) : De,
  "%Symbol%": qi ? Symbol : De,
  "%SyntaxError%": Ds,
  "%ThrowTypeError%": qZ,
  "%TypedArray%": XZ,
  "%TypeError%": fs,
  "%Uint8Array%": typeof Uint8Array > "u" ? De : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? De : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? De : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? De : Uint32Array,
  "%URIError%": URIError,
  "%WeakMap%": typeof WeakMap > "u" ? De : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? De : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? De : WeakSet
};
if (At)
  try {
    null.error;
  } catch (e) {
    var ZZ = At(At(e));
    pi["%Error.prototype%"] = ZZ;
  }
var KZ = function e(t) {
  var n;
  if (t === "%AsyncFunction%")
    n = yf("async function () {}");
  else if (t === "%GeneratorFunction%")
    n = yf("function* () {}");
  else if (t === "%AsyncGeneratorFunction%")
    n = yf("async function* () {}");
  else if (t === "%AsyncGenerator%") {
    var r = e("%AsyncGeneratorFunction%");
    r && (n = r.prototype);
  } else if (t === "%AsyncIteratorPrototype%") {
    var i = e("%AsyncGenerator%");
    i && At && (n = At(i.prototype));
  }
  return pi[t] = n, n;
}, Ky = {
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, Oo = op, Ic = YZ, JZ = Oo.call(Function.call, Array.prototype.concat), QZ = Oo.call(Function.apply, Array.prototype.splice), Jy = Oo.call(Function.call, String.prototype.replace), Rc = Oo.call(Function.call, String.prototype.slice), eK = Oo.call(Function.call, RegExp.prototype.exec), tK = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, nK = /\\(\\)?/g, rK = function(t) {
  var n = Rc(t, 0, 1), r = Rc(t, -1);
  if (n === "%" && r !== "%")
    throw new Ds("invalid intrinsic syntax, expected closing `%`");
  if (r === "%" && n !== "%")
    throw new Ds("invalid intrinsic syntax, expected opening `%`");
  var i = [];
  return Jy(t, tK, function(s, a, o, l) {
    i[i.length] = o ? Jy(l, nK, "$1") : a || s;
  }), i;
}, iK = function(t, n) {
  var r = t, i;
  if (Ic(Ky, r) && (i = Ky[r], r = "%" + i[0] + "%"), Ic(pi, r)) {
    var s = pi[r];
    if (s === Qi && (s = KZ(r)), typeof s > "u" && !n)
      throw new fs("intrinsic " + t + " exists, but is not available. Please file an issue!");
    return {
      alias: i,
      name: r,
      value: s
    };
  }
  throw new Ds("intrinsic " + t + " does not exist!");
}, Ri = function(t, n) {
  if (typeof t != "string" || t.length === 0)
    throw new fs("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof n != "boolean")
    throw new fs('"allowMissing" argument must be a boolean');
  if (eK(/^%?[^%]*%?$/, t) === null)
    throw new Ds("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var r = rK(t), i = r.length > 0 ? r[0] : "", s = iK("%" + i + "%", n), a = s.name, o = s.value, l = !1, c = s.alias;
  c && (i = c[0], QZ(r, JZ([0, 1], c)));
  for (var u = 1, f = !0; u < r.length; u += 1) {
    var d = r[u], h = Rc(d, 0, 1), p = Rc(d, -1);
    if ((h === '"' || h === "'" || h === "`" || p === '"' || p === "'" || p === "`") && h !== p)
      throw new Ds("property names with quotes must have matching quotes");
    if ((d === "constructor" || !f) && (l = !0), i += "." + d, a = "%" + i + "%", Ic(pi, a))
      o = pi[a];
    else if (o != null) {
      if (!(d in o)) {
        if (!n)
          throw new fs("base intrinsic for " + t + " exists, but the property is not available.");
        return;
      }
      if (hi && u + 1 >= r.length) {
        var g = hi(o, d);
        f = !!g, f && "get" in g && !("originalValue" in g.get) ? o = g.get : o = o[d];
      } else
        f = Ic(o, d), o = o[d];
      f && !l && (pi[a] = o);
    }
  }
  return o;
}, R$ = { exports: {} }, sK = Ri, u0 = sK("%Object.defineProperty%", !0), f0 = function() {
  if (u0)
    try {
      return u0({}, "a", { value: 1 }), !0;
    } catch {
      return !1;
    }
  return !1;
};
f0.hasArrayLengthDefineBug = function() {
  if (!f0())
    return null;
  try {
    return u0([], "length", { value: 1 }).length !== 1;
  } catch {
    return !0;
  }
};
var B$ = f0, aK = Ri, zl = aK("%Object.getOwnPropertyDescriptor%", !0);
if (zl)
  try {
    zl([], "length");
  } catch {
    zl = null;
  }
var N$ = zl, oK = B$(), lp = Ri, Ba = oK && lp("%Object.defineProperty%", !0);
if (Ba)
  try {
    Ba({}, "a", { value: 1 });
  } catch {
    Ba = !1;
  }
var lK = lp("%SyntaxError%"), Gi = lp("%TypeError%"), Qy = N$, cK = function(t, n, r) {
  if (!t || typeof t != "object" && typeof t != "function")
    throw new Gi("`obj` must be an object or a function`");
  if (typeof n != "string" && typeof n != "symbol")
    throw new Gi("`property` must be a string or a symbol`");
  if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
    throw new Gi("`nonEnumerable`, if provided, must be a boolean or null");
  if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
    throw new Gi("`nonWritable`, if provided, must be a boolean or null");
  if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
    throw new Gi("`nonConfigurable`, if provided, must be a boolean or null");
  if (arguments.length > 6 && typeof arguments[6] != "boolean")
    throw new Gi("`loose`, if provided, must be a boolean");
  var i = arguments.length > 3 ? arguments[3] : null, s = arguments.length > 4 ? arguments[4] : null, a = arguments.length > 5 ? arguments[5] : null, o = arguments.length > 6 ? arguments[6] : !1, l = !!Qy && Qy(t, n);
  if (Ba)
    Ba(t, n, {
      configurable: a === null && l ? l.configurable : !a,
      enumerable: i === null && l ? l.enumerable : !i,
      value: r,
      writable: s === null && l ? l.writable : !s
    });
  else if (o || !i && !s && !a)
    t[n] = r;
  else
    throw new lK("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
}, L$ = Ri, ex = cK, uK = B$(), tx = N$, nx = L$("%TypeError%"), fK = L$("%Math.floor%"), dK = function(t, n) {
  if (typeof t != "function")
    throw new nx("`fn` is not a function");
  if (typeof n != "number" || n < 0 || n > 4294967295 || fK(n) !== n)
    throw new nx("`length` must be a positive 32-bit integer");
  var r = arguments.length > 2 && !!arguments[2], i = !0, s = !0;
  if ("length" in t && tx) {
    var a = tx(t, "length");
    a && !a.configurable && (i = !1), a && !a.writable && (s = !1);
  }
  return (i || s || !r) && (uK ? ex(
    /** @type {Parameters<define>[0]} */
    t,
    "length",
    n,
    !0,
    !0
  ) : ex(
    /** @type {Parameters<define>[0]} */
    t,
    "length",
    n
  )), t;
};
(function(e) {
  var t = op, n = Ri, r = dK, i = n("%TypeError%"), s = n("%Function.prototype.apply%"), a = n("%Function.prototype.call%"), o = n("%Reflect.apply%", !0) || t.call(a, s), l = n("%Object.defineProperty%", !0), c = n("%Math.max%");
  if (l)
    try {
      l({}, "a", { value: 1 });
    } catch {
      l = null;
    }
  e.exports = function(d) {
    if (typeof d != "function")
      throw new i("a function is required");
    var h = o(t, a, arguments);
    return r(
      h,
      1 + c(0, d.length - (arguments.length - 1)),
      !0
    );
  };
  var u = function() {
    return o(t, s, arguments);
  };
  l ? l(e.exports, "apply", { value: u }) : e.exports.apply = u;
})(R$);
var hK = R$.exports, j$ = Ri, z$ = hK, pK = z$(j$("String.prototype.indexOf")), gK = function(t, n) {
  var r = j$(t, !!n);
  return typeof r == "function" && pK(t, ".prototype.") > -1 ? z$(r) : r;
};
const vK = {}, mK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: vK
}, Symbol.toStringTag, { value: "Module" })), V$ = /* @__PURE__ */ kY(mK);
var cp = typeof Map == "function" && Map.prototype, bf = Object.getOwnPropertyDescriptor && cp ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null, Bc = cp && bf && typeof bf.get == "function" ? bf.get : null, rx = cp && Map.prototype.forEach, up = typeof Set == "function" && Set.prototype, _f = Object.getOwnPropertyDescriptor && up ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null, Nc = up && _f && typeof _f.get == "function" ? _f.get : null, ix = up && Set.prototype.forEach, yK = typeof WeakMap == "function" && WeakMap.prototype, Na = yK ? WeakMap.prototype.has : null, xK = typeof WeakSet == "function" && WeakSet.prototype, La = xK ? WeakSet.prototype.has : null, bK = typeof WeakRef == "function" && WeakRef.prototype, sx = bK ? WeakRef.prototype.deref : null, _K = Boolean.prototype.valueOf, wK = Object.prototype.toString, $K = Function.prototype.toString, EK = String.prototype.match, fp = String.prototype.slice, Fr = String.prototype.replace, AK = String.prototype.toUpperCase, ax = String.prototype.toLowerCase, H$ = RegExp.prototype.test, ox = Array.prototype.concat, Fn = Array.prototype.join, kK = Array.prototype.slice, lx = Math.floor, d0 = typeof BigInt == "function" ? BigInt.prototype.valueOf : null, wf = Object.getOwnPropertySymbols, h0 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null, Ss = typeof Symbol == "function" && typeof Symbol.iterator == "object", jt = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === Ss || !0) ? Symbol.toStringTag : null, W$ = Object.prototype.propertyIsEnumerable, cx = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(e) {
  return e.__proto__;
} : null);
function ux(e, t) {
  if (e === 1 / 0 || e === -1 / 0 || e !== e || e && e > -1e3 && e < 1e3 || H$.call(/e/, t))
    return t;
  var n = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
  if (typeof e == "number") {
    var r = e < 0 ? -lx(-e) : lx(e);
    if (r !== e) {
      var i = String(r), s = fp.call(t, i.length + 1);
      return Fr.call(i, n, "$&_") + "." + Fr.call(Fr.call(s, /([0-9]{3})/g, "$&_"), /_$/, "");
    }
  }
  return Fr.call(t, n, "$&_");
}
var p0 = V$, fx = p0.custom, dx = Y$(fx) ? fx : null, CK = function e(t, n, r, i) {
  var s = n || {};
  if (kr(s, "quoteStyle") && s.quoteStyle !== "single" && s.quoteStyle !== "double")
    throw new TypeError('option "quoteStyle" must be "single" or "double"');
  if (kr(s, "maxStringLength") && (typeof s.maxStringLength == "number" ? s.maxStringLength < 0 && s.maxStringLength !== 1 / 0 : s.maxStringLength !== null))
    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
  var a = kr(s, "customInspect") ? s.customInspect : !0;
  if (typeof a != "boolean" && a !== "symbol")
    throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
  if (kr(s, "indent") && s.indent !== null && s.indent !== "	" && !(parseInt(s.indent, 10) === s.indent && s.indent > 0))
    throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
  if (kr(s, "numericSeparator") && typeof s.numericSeparator != "boolean")
    throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
  var o = s.numericSeparator;
  if (typeof t > "u")
    return "undefined";
  if (t === null)
    return "null";
  if (typeof t == "boolean")
    return t ? "true" : "false";
  if (typeof t == "string")
    return G$(t, s);
  if (typeof t == "number") {
    if (t === 0)
      return 1 / 0 / t > 0 ? "0" : "-0";
    var l = String(t);
    return o ? ux(t, l) : l;
  }
  if (typeof t == "bigint") {
    var c = String(t) + "n";
    return o ? ux(t, c) : c;
  }
  var u = typeof s.depth > "u" ? 5 : s.depth;
  if (typeof r > "u" && (r = 0), r >= u && u > 0 && typeof t == "object")
    return g0(t) ? "[Array]" : "[Object]";
  var f = UK(s, r);
  if (typeof i > "u")
    i = [];
  else if (q$(i, t) >= 0)
    return "[Circular]";
  function d(S, L, P) {
    if (L && (i = kK.call(i), i.push(L)), P) {
      var H = {
        depth: s.depth
      };
      return kr(s, "quoteStyle") && (H.quoteStyle = s.quoteStyle), e(S, H, r + 1, i);
    }
    return e(S, s, r + 1, i);
  }
  if (typeof t == "function" && !hx(t)) {
    var h = RK(t), p = vl(t, d);
    return "[Function" + (h ? ": " + h : " (anonymous)") + "]" + (p.length > 0 ? " { " + Fn.call(p, ", ") + " }" : "");
  }
  if (Y$(t)) {
    var g = Ss ? Fr.call(String(t), /^(Symbol\(.*\))_[^)]*$/, "$1") : h0.call(t);
    return typeof t == "object" && !Ss ? ha(g) : g;
  }
  if (VK(t)) {
    for (var v = "<" + ax.call(String(t.nodeName)), m = t.attributes || [], x = 0; x < m.length; x++)
      v += " " + m[x].name + "=" + U$(DK(m[x].value), "double", s);
    return v += ">", t.childNodes && t.childNodes.length && (v += "..."), v += "</" + ax.call(String(t.nodeName)) + ">", v;
  }
  if (g0(t)) {
    if (t.length === 0)
      return "[]";
    var _ = vl(t, d);
    return f && !WK(_) ? "[" + v0(_, f) + "]" : "[ " + Fn.call(_, ", ") + " ]";
  }
  if (TK(t)) {
    var y = vl(t, d);
    return !("cause" in Error.prototype) && "cause" in t && !W$.call(t, "cause") ? "{ [" + String(t) + "] " + Fn.call(ox.call("[cause]: " + d(t.cause), y), ", ") + " }" : y.length === 0 ? "[" + String(t) + "]" : "{ [" + String(t) + "] " + Fn.call(y, ", ") + " }";
  }
  if (typeof t == "object" && a) {
    if (dx && typeof t[dx] == "function" && p0)
      return p0(t, { depth: u - r });
    if (a !== "symbol" && typeof t.inspect == "function")
      return t.inspect();
  }
  if (BK(t)) {
    var b = [];
    return rx && rx.call(t, function(S, L) {
      b.push(d(L, t, !0) + " => " + d(S, t));
    }), px("Map", Bc.call(t), b, f);
  }
  if (jK(t)) {
    var w = [];
    return ix && ix.call(t, function(S) {
      w.push(d(S, t));
    }), px("Set", Nc.call(t), w, f);
  }
  if (NK(t))
    return $f("WeakMap");
  if (zK(t))
    return $f("WeakSet");
  if (LK(t))
    return $f("WeakRef");
  if (MK(t))
    return ha(d(Number(t)));
  if (PK(t))
    return ha(d(d0.call(t)));
  if (FK(t))
    return ha(_K.call(t));
  if (OK(t))
    return ha(d(String(t)));
  if (typeof window < "u" && t === window)
    return "{ [object Window] }";
  if (t === ye)
    return "{ [object globalThis] }";
  if (!SK(t) && !hx(t)) {
    var E = vl(t, d), $ = cx ? cx(t) === Object.prototype : t instanceof Object || t.constructor === Object, C = t instanceof Object ? "" : "null prototype", A = !$ && jt && Object(t) === t && jt in t ? fp.call(Hr(t), 8, -1) : C ? "Object" : "", k = $ || typeof t.constructor != "function" ? "" : t.constructor.name ? t.constructor.name + " " : "", D = k + (A || C ? "[" + Fn.call(ox.call([], A || [], C || []), ": ") + "] " : "");
    return E.length === 0 ? D + "{}" : f ? D + "{" + v0(E, f) + "}" : D + "{ " + Fn.call(E, ", ") + " }";
  }
  return String(t);
};
function U$(e, t, n) {
  var r = (n.quoteStyle || t) === "double" ? '"' : "'";
  return r + e + r;
}
function DK(e) {
  return Fr.call(String(e), /"/g, "&quot;");
}
function g0(e) {
  return Hr(e) === "[object Array]" && (!jt || !(typeof e == "object" && jt in e));
}
function SK(e) {
  return Hr(e) === "[object Date]" && (!jt || !(typeof e == "object" && jt in e));
}
function hx(e) {
  return Hr(e) === "[object RegExp]" && (!jt || !(typeof e == "object" && jt in e));
}
function TK(e) {
  return Hr(e) === "[object Error]" && (!jt || !(typeof e == "object" && jt in e));
}
function OK(e) {
  return Hr(e) === "[object String]" && (!jt || !(typeof e == "object" && jt in e));
}
function MK(e) {
  return Hr(e) === "[object Number]" && (!jt || !(typeof e == "object" && jt in e));
}
function FK(e) {
  return Hr(e) === "[object Boolean]" && (!jt || !(typeof e == "object" && jt in e));
}
function Y$(e) {
  if (Ss)
    return e && typeof e == "object" && e instanceof Symbol;
  if (typeof e == "symbol")
    return !0;
  if (!e || typeof e != "object" || !h0)
    return !1;
  try {
    return h0.call(e), !0;
  } catch {
  }
  return !1;
}
function PK(e) {
  if (!e || typeof e != "object" || !d0)
    return !1;
  try {
    return d0.call(e), !0;
  } catch {
  }
  return !1;
}
var IK = Object.prototype.hasOwnProperty || function(e) {
  return e in this;
};
function kr(e, t) {
  return IK.call(e, t);
}
function Hr(e) {
  return wK.call(e);
}
function RK(e) {
  if (e.name)
    return e.name;
  var t = EK.call($K.call(e), /^function\s*([\w$]+)/);
  return t ? t[1] : null;
}
function q$(e, t) {
  if (e.indexOf)
    return e.indexOf(t);
  for (var n = 0, r = e.length; n < r; n++)
    if (e[n] === t)
      return n;
  return -1;
}
function BK(e) {
  if (!Bc || !e || typeof e != "object")
    return !1;
  try {
    Bc.call(e);
    try {
      Nc.call(e);
    } catch {
      return !0;
    }
    return e instanceof Map;
  } catch {
  }
  return !1;
}
function NK(e) {
  if (!Na || !e || typeof e != "object")
    return !1;
  try {
    Na.call(e, Na);
    try {
      La.call(e, La);
    } catch {
      return !0;
    }
    return e instanceof WeakMap;
  } catch {
  }
  return !1;
}
function LK(e) {
  if (!sx || !e || typeof e != "object")
    return !1;
  try {
    return sx.call(e), !0;
  } catch {
  }
  return !1;
}
function jK(e) {
  if (!Nc || !e || typeof e != "object")
    return !1;
  try {
    Nc.call(e);
    try {
      Bc.call(e);
    } catch {
      return !0;
    }
    return e instanceof Set;
  } catch {
  }
  return !1;
}
function zK(e) {
  if (!La || !e || typeof e != "object")
    return !1;
  try {
    La.call(e, La);
    try {
      Na.call(e, Na);
    } catch {
      return !0;
    }
    return e instanceof WeakSet;
  } catch {
  }
  return !1;
}
function VK(e) {
  return !e || typeof e != "object" ? !1 : typeof HTMLElement < "u" && e instanceof HTMLElement ? !0 : typeof e.nodeName == "string" && typeof e.getAttribute == "function";
}
function G$(e, t) {
  if (e.length > t.maxStringLength) {
    var n = e.length - t.maxStringLength, r = "... " + n + " more character" + (n > 1 ? "s" : "");
    return G$(fp.call(e, 0, t.maxStringLength), t) + r;
  }
  var i = Fr.call(Fr.call(e, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, HK);
  return U$(i, "single", t);
}
function HK(e) {
  var t = e.charCodeAt(0), n = {
    8: "b",
    9: "t",
    10: "n",
    12: "f",
    13: "r"
  }[t];
  return n ? "\\" + n : "\\x" + (t < 16 ? "0" : "") + AK.call(t.toString(16));
}
function ha(e) {
  return "Object(" + e + ")";
}
function $f(e) {
  return e + " { ? }";
}
function px(e, t, n, r) {
  var i = r ? v0(n, r) : Fn.call(n, ", ");
  return e + " (" + t + ") {" + i + "}";
}
function WK(e) {
  for (var t = 0; t < e.length; t++)
    if (q$(e[t], `
`) >= 0)
      return !1;
  return !0;
}
function UK(e, t) {
  var n;
  if (e.indent === "	")
    n = "	";
  else if (typeof e.indent == "number" && e.indent > 0)
    n = Fn.call(Array(e.indent + 1), " ");
  else
    return null;
  return {
    base: n,
    prev: Fn.call(Array(t + 1), n)
  };
}
function v0(e, t) {
  if (e.length === 0)
    return "";
  var n = `
` + t.prev + t.base;
  return n + Fn.call(e, "," + n) + `
` + t.prev;
}
function vl(e, t) {
  var n = g0(e), r = [];
  if (n) {
    r.length = e.length;
    for (var i = 0; i < e.length; i++)
      r[i] = kr(e, i) ? t(e[i], e) : "";
  }
  var s = typeof wf == "function" ? wf(e) : [], a;
  if (Ss) {
    a = {};
    for (var o = 0; o < s.length; o++)
      a["$" + s[o]] = s[o];
  }
  for (var l in e)
    kr(e, l) && (n && String(Number(l)) === l && l < e.length || Ss && a["$" + l] instanceof Symbol || (H$.call(/[^\w$]/, l) ? r.push(t(l, e) + ": " + t(e[l], e)) : r.push(l + ": " + t(e[l], e))));
  if (typeof wf == "function")
    for (var c = 0; c < s.length; c++)
      W$.call(e, s[c]) && r.push("[" + t(s[c]) + "]: " + t(e[s[c]], e));
  return r;
}
var dp = Ri, Us = gK, YK = CK, qK = dp("%TypeError%"), ml = dp("%WeakMap%", !0), yl = dp("%Map%", !0), GK = Us("WeakMap.prototype.get", !0), XK = Us("WeakMap.prototype.set", !0), ZK = Us("WeakMap.prototype.has", !0), KK = Us("Map.prototype.get", !0), JK = Us("Map.prototype.set", !0), QK = Us("Map.prototype.has", !0), hp = function(e, t) {
  for (var n = e, r; (r = n.next) !== null; n = r)
    if (r.key === t)
      return n.next = r.next, r.next = e.next, e.next = r, r;
}, eJ = function(e, t) {
  var n = hp(e, t);
  return n && n.value;
}, tJ = function(e, t, n) {
  var r = hp(e, t);
  r ? r.value = n : e.next = {
    // eslint-disable-line no-param-reassign
    key: t,
    next: e.next,
    value: n
  };
}, nJ = function(e, t) {
  return !!hp(e, t);
}, rJ = function() {
  var t, n, r, i = {
    assert: function(s) {
      if (!i.has(s))
        throw new qK("Side channel does not contain " + YK(s));
    },
    get: function(s) {
      if (ml && s && (typeof s == "object" || typeof s == "function")) {
        if (t)
          return GK(t, s);
      } else if (yl) {
        if (n)
          return KK(n, s);
      } else if (r)
        return eJ(r, s);
    },
    has: function(s) {
      if (ml && s && (typeof s == "object" || typeof s == "function")) {
        if (t)
          return ZK(t, s);
      } else if (yl) {
        if (n)
          return QK(n, s);
      } else if (r)
        return nJ(r, s);
      return !1;
    },
    set: function(s, a) {
      ml && s && (typeof s == "object" || typeof s == "function") ? (t || (t = new ml()), XK(t, s, a)) : yl ? (n || (n = new yl()), JK(n, s, a)) : (r || (r = { key: {}, next: null }), tJ(r, s, a));
    }
  };
  return i;
}, iJ = String.prototype.replace, sJ = /%20/g, Ef = {
  RFC1738: "RFC1738",
  RFC3986: "RFC3986"
}, pp = {
  default: Ef.RFC3986,
  formatters: {
    RFC1738: function(e) {
      return iJ.call(e, sJ, "+");
    },
    RFC3986: function(e) {
      return String(e);
    }
  },
  RFC1738: Ef.RFC1738,
  RFC3986: Ef.RFC3986
}, aJ = pp, Af = Object.prototype.hasOwnProperty, si = Array.isArray, On = function() {
  for (var e = [], t = 0; t < 256; ++t)
    e.push("%" + ((t < 16 ? "0" : "") + t.toString(16)).toUpperCase());
  return e;
}(), oJ = function(t) {
  for (; t.length > 1; ) {
    var n = t.pop(), r = n.obj[n.prop];
    if (si(r)) {
      for (var i = [], s = 0; s < r.length; ++s)
        typeof r[s] < "u" && i.push(r[s]);
      n.obj[n.prop] = i;
    }
  }
}, X$ = function(t, n) {
  for (var r = n && n.plainObjects ? /* @__PURE__ */ Object.create(null) : {}, i = 0; i < t.length; ++i)
    typeof t[i] < "u" && (r[i] = t[i]);
  return r;
}, lJ = function e(t, n, r) {
  if (!n)
    return t;
  if (typeof n != "object") {
    if (si(t))
      t.push(n);
    else if (t && typeof t == "object")
      (r && (r.plainObjects || r.allowPrototypes) || !Af.call(Object.prototype, n)) && (t[n] = !0);
    else
      return [t, n];
    return t;
  }
  if (!t || typeof t != "object")
    return [t].concat(n);
  var i = t;
  return si(t) && !si(n) && (i = X$(t, r)), si(t) && si(n) ? (n.forEach(function(s, a) {
    if (Af.call(t, a)) {
      var o = t[a];
      o && typeof o == "object" && s && typeof s == "object" ? t[a] = e(o, s, r) : t.push(s);
    } else
      t[a] = s;
  }), t) : Object.keys(n).reduce(function(s, a) {
    var o = n[a];
    return Af.call(s, a) ? s[a] = e(s[a], o, r) : s[a] = o, s;
  }, i);
}, cJ = function(t, n) {
  return Object.keys(n).reduce(function(r, i) {
    return r[i] = n[i], r;
  }, t);
}, uJ = function(e, t, n) {
  var r = e.replace(/\+/g, " ");
  if (n === "iso-8859-1")
    return r.replace(/%[0-9a-f]{2}/gi, unescape);
  try {
    return decodeURIComponent(r);
  } catch {
    return r;
  }
}, fJ = function(t, n, r, i, s) {
  if (t.length === 0)
    return t;
  var a = t;
  if (typeof t == "symbol" ? a = Symbol.prototype.toString.call(t) : typeof t != "string" && (a = String(t)), r === "iso-8859-1")
    return escape(a).replace(/%u[0-9a-f]{4}/gi, function(u) {
      return "%26%23" + parseInt(u.slice(2), 16) + "%3B";
    });
  for (var o = "", l = 0; l < a.length; ++l) {
    var c = a.charCodeAt(l);
    if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || s === aJ.RFC1738 && (c === 40 || c === 41)) {
      o += a.charAt(l);
      continue;
    }
    if (c < 128) {
      o = o + On[c];
      continue;
    }
    if (c < 2048) {
      o = o + (On[192 | c >> 6] + On[128 | c & 63]);
      continue;
    }
    if (c < 55296 || c >= 57344) {
      o = o + (On[224 | c >> 12] + On[128 | c >> 6 & 63] + On[128 | c & 63]);
      continue;
    }
    l += 1, c = 65536 + ((c & 1023) << 10 | a.charCodeAt(l) & 1023), o += On[240 | c >> 18] + On[128 | c >> 12 & 63] + On[128 | c >> 6 & 63] + On[128 | c & 63];
  }
  return o;
}, dJ = function(t) {
  for (var n = [{ obj: { o: t }, prop: "o" }], r = [], i = 0; i < n.length; ++i)
    for (var s = n[i], a = s.obj[s.prop], o = Object.keys(a), l = 0; l < o.length; ++l) {
      var c = o[l], u = a[c];
      typeof u == "object" && u !== null && r.indexOf(u) === -1 && (n.push({ obj: a, prop: c }), r.push(u));
    }
  return oJ(n), t;
}, hJ = function(t) {
  return Object.prototype.toString.call(t) === "[object RegExp]";
}, pJ = function(t) {
  return !t || typeof t != "object" ? !1 : !!(t.constructor && t.constructor.isBuffer && t.constructor.isBuffer(t));
}, gJ = function(t, n) {
  return [].concat(t, n);
}, vJ = function(t, n) {
  if (si(t)) {
    for (var r = [], i = 0; i < t.length; i += 1)
      r.push(n(t[i]));
    return r;
  }
  return n(t);
}, Z$ = {
  arrayToObject: X$,
  assign: cJ,
  combine: gJ,
  compact: dJ,
  decode: uJ,
  encode: fJ,
  isBuffer: pJ,
  isRegExp: hJ,
  maybeMap: vJ,
  merge: lJ
}, K$ = rJ, Vl = Z$, ja = pp, mJ = Object.prototype.hasOwnProperty, gx = {
  brackets: function(t) {
    return t + "[]";
  },
  comma: "comma",
  indices: function(t, n) {
    return t + "[" + n + "]";
  },
  repeat: function(t) {
    return t;
  }
}, Jn = Array.isArray, yJ = Array.prototype.push, J$ = function(e, t) {
  yJ.apply(e, Jn(t) ? t : [t]);
}, xJ = Date.prototype.toISOString, vx = ja.default, It = {
  addQueryPrefix: !1,
  allowDots: !1,
  charset: "utf-8",
  charsetSentinel: !1,
  delimiter: "&",
  encode: !0,
  encoder: Vl.encode,
  encodeValuesOnly: !1,
  format: vx,
  formatter: ja.formatters[vx],
  // deprecated
  indices: !1,
  serializeDate: function(t) {
    return xJ.call(t);
  },
  skipNulls: !1,
  strictNullHandling: !1
}, bJ = function(t) {
  return typeof t == "string" || typeof t == "number" || typeof t == "boolean" || typeof t == "symbol" || typeof t == "bigint";
}, kf = {}, _J = function e(t, n, r, i, s, a, o, l, c, u, f, d, h, p, g, v) {
  for (var m = t, x = v, _ = 0, y = !1; (x = x.get(kf)) !== void 0 && !y; ) {
    var b = x.get(t);
    if (_ += 1, typeof b < "u") {
      if (b === _)
        throw new RangeError("Cyclic object value");
      y = !0;
    }
    typeof x.get(kf) > "u" && (_ = 0);
  }
  if (typeof l == "function" ? m = l(n, m) : m instanceof Date ? m = f(m) : r === "comma" && Jn(m) && (m = Vl.maybeMap(m, function(H) {
    return H instanceof Date ? f(H) : H;
  })), m === null) {
    if (s)
      return o && !p ? o(n, It.encoder, g, "key", d) : n;
    m = "";
  }
  if (bJ(m) || Vl.isBuffer(m)) {
    if (o) {
      var w = p ? n : o(n, It.encoder, g, "key", d);
      return [h(w) + "=" + h(o(m, It.encoder, g, "value", d))];
    }
    return [h(n) + "=" + h(String(m))];
  }
  var E = [];
  if (typeof m > "u")
    return E;
  var $;
  if (r === "comma" && Jn(m))
    p && o && (m = Vl.maybeMap(m, o)), $ = [{ value: m.length > 0 ? m.join(",") || null : void 0 }];
  else if (Jn(l))
    $ = l;
  else {
    var C = Object.keys(m);
    $ = c ? C.sort(c) : C;
  }
  for (var A = i && Jn(m) && m.length === 1 ? n + "[]" : n, k = 0; k < $.length; ++k) {
    var D = $[k], S = typeof D == "object" && typeof D.value < "u" ? D.value : m[D];
    if (!(a && S === null)) {
      var L = Jn(m) ? typeof r == "function" ? r(A, D) : A : A + (u ? "." + D : "[" + D + "]");
      v.set(t, _);
      var P = K$();
      P.set(kf, v), J$(E, e(
        S,
        L,
        r,
        i,
        s,
        a,
        r === "comma" && p && Jn(m) ? null : o,
        l,
        c,
        u,
        f,
        d,
        h,
        p,
        g,
        P
      ));
    }
  }
  return E;
}, wJ = function(t) {
  if (!t)
    return It;
  if (t.encoder !== null && typeof t.encoder < "u" && typeof t.encoder != "function")
    throw new TypeError("Encoder has to be a function.");
  var n = t.charset || It.charset;
  if (typeof t.charset < "u" && t.charset !== "utf-8" && t.charset !== "iso-8859-1")
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  var r = ja.default;
  if (typeof t.format < "u") {
    if (!mJ.call(ja.formatters, t.format))
      throw new TypeError("Unknown format option provided.");
    r = t.format;
  }
  var i = ja.formatters[r], s = It.filter;
  return (typeof t.filter == "function" || Jn(t.filter)) && (s = t.filter), {
    addQueryPrefix: typeof t.addQueryPrefix == "boolean" ? t.addQueryPrefix : It.addQueryPrefix,
    allowDots: typeof t.allowDots > "u" ? It.allowDots : !!t.allowDots,
    charset: n,
    charsetSentinel: typeof t.charsetSentinel == "boolean" ? t.charsetSentinel : It.charsetSentinel,
    delimiter: typeof t.delimiter > "u" ? It.delimiter : t.delimiter,
    encode: typeof t.encode == "boolean" ? t.encode : It.encode,
    encoder: typeof t.encoder == "function" ? t.encoder : It.encoder,
    encodeValuesOnly: typeof t.encodeValuesOnly == "boolean" ? t.encodeValuesOnly : It.encodeValuesOnly,
    filter: s,
    format: r,
    formatter: i,
    serializeDate: typeof t.serializeDate == "function" ? t.serializeDate : It.serializeDate,
    skipNulls: typeof t.skipNulls == "boolean" ? t.skipNulls : It.skipNulls,
    sort: typeof t.sort == "function" ? t.sort : null,
    strictNullHandling: typeof t.strictNullHandling == "boolean" ? t.strictNullHandling : It.strictNullHandling
  };
}, $J = function(e, t) {
  var n = e, r = wJ(t), i, s;
  typeof r.filter == "function" ? (s = r.filter, n = s("", n)) : Jn(r.filter) && (s = r.filter, i = s);
  var a = [];
  if (typeof n != "object" || n === null)
    return "";
  var o;
  t && t.arrayFormat in gx ? o = t.arrayFormat : t && "indices" in t ? o = t.indices ? "indices" : "repeat" : o = "indices";
  var l = gx[o];
  if (t && "commaRoundTrip" in t && typeof t.commaRoundTrip != "boolean")
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  var c = l === "comma" && t && t.commaRoundTrip;
  i || (i = Object.keys(n)), r.sort && i.sort(r.sort);
  for (var u = K$(), f = 0; f < i.length; ++f) {
    var d = i[f];
    r.skipNulls && n[d] === null || J$(a, _J(
      n[d],
      d,
      l,
      c,
      r.strictNullHandling,
      r.skipNulls,
      r.encode ? r.encoder : null,
      r.filter,
      r.sort,
      r.allowDots,
      r.serializeDate,
      r.format,
      r.formatter,
      r.encodeValuesOnly,
      r.charset,
      u
    ));
  }
  var h = a.join(r.delimiter), p = r.addQueryPrefix === !0 ? "?" : "";
  return r.charsetSentinel && (r.charset === "iso-8859-1" ? p += "utf8=%26%2310003%3B&" : p += "utf8=%E2%9C%93&"), h.length > 0 ? p + h : "";
}, Ts = Z$, m0 = Object.prototype.hasOwnProperty, EJ = Array.isArray, Et = {
  allowDots: !1,
  allowPrototypes: !1,
  allowSparse: !1,
  arrayLimit: 20,
  charset: "utf-8",
  charsetSentinel: !1,
  comma: !1,
  decoder: Ts.decode,
  delimiter: "&",
  depth: 5,
  ignoreQueryPrefix: !1,
  interpretNumericEntities: !1,
  parameterLimit: 1e3,
  parseArrays: !0,
  plainObjects: !1,
  strictNullHandling: !1
}, AJ = function(e) {
  return e.replace(/&#(\d+);/g, function(t, n) {
    return String.fromCharCode(parseInt(n, 10));
  });
}, Q$ = function(e, t) {
  return e && typeof e == "string" && t.comma && e.indexOf(",") > -1 ? e.split(",") : e;
}, kJ = "utf8=%26%2310003%3B", CJ = "utf8=%E2%9C%93", DJ = function(t, n) {
  var r = { __proto__: null }, i = n.ignoreQueryPrefix ? t.replace(/^\?/, "") : t, s = n.parameterLimit === 1 / 0 ? void 0 : n.parameterLimit, a = i.split(n.delimiter, s), o = -1, l, c = n.charset;
  if (n.charsetSentinel)
    for (l = 0; l < a.length; ++l)
      a[l].indexOf("utf8=") === 0 && (a[l] === CJ ? c = "utf-8" : a[l] === kJ && (c = "iso-8859-1"), o = l, l = a.length);
  for (l = 0; l < a.length; ++l)
    if (l !== o) {
      var u = a[l], f = u.indexOf("]="), d = f === -1 ? u.indexOf("=") : f + 1, h, p;
      d === -1 ? (h = n.decoder(u, Et.decoder, c, "key"), p = n.strictNullHandling ? null : "") : (h = n.decoder(u.slice(0, d), Et.decoder, c, "key"), p = Ts.maybeMap(
        Q$(u.slice(d + 1), n),
        function(g) {
          return n.decoder(g, Et.decoder, c, "value");
        }
      )), p && n.interpretNumericEntities && c === "iso-8859-1" && (p = AJ(p)), u.indexOf("[]=") > -1 && (p = EJ(p) ? [p] : p), m0.call(r, h) ? r[h] = Ts.combine(r[h], p) : r[h] = p;
    }
  return r;
}, SJ = function(e, t, n, r) {
  for (var i = r ? t : Q$(t, n), s = e.length - 1; s >= 0; --s) {
    var a, o = e[s];
    if (o === "[]" && n.parseArrays)
      a = [].concat(i);
    else {
      a = n.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var l = o.charAt(0) === "[" && o.charAt(o.length - 1) === "]" ? o.slice(1, -1) : o, c = parseInt(l, 10);
      !n.parseArrays && l === "" ? a = { 0: i } : !isNaN(c) && o !== l && String(c) === l && c >= 0 && n.parseArrays && c <= n.arrayLimit ? (a = [], a[c] = i) : l !== "__proto__" && (a[l] = i);
    }
    i = a;
  }
  return i;
}, TJ = function(t, n, r, i) {
  if (t) {
    var s = r.allowDots ? t.replace(/\.([^.[]+)/g, "[$1]") : t, a = /(\[[^[\]]*])/, o = /(\[[^[\]]*])/g, l = r.depth > 0 && a.exec(s), c = l ? s.slice(0, l.index) : s, u = [];
    if (c) {
      if (!r.plainObjects && m0.call(Object.prototype, c) && !r.allowPrototypes)
        return;
      u.push(c);
    }
    for (var f = 0; r.depth > 0 && (l = o.exec(s)) !== null && f < r.depth; ) {
      if (f += 1, !r.plainObjects && m0.call(Object.prototype, l[1].slice(1, -1)) && !r.allowPrototypes)
        return;
      u.push(l[1]);
    }
    return l && u.push("[" + s.slice(l.index) + "]"), SJ(u, n, r, i);
  }
}, OJ = function(t) {
  if (!t)
    return Et;
  if (t.decoder !== null && t.decoder !== void 0 && typeof t.decoder != "function")
    throw new TypeError("Decoder has to be a function.");
  if (typeof t.charset < "u" && t.charset !== "utf-8" && t.charset !== "iso-8859-1")
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  var n = typeof t.charset > "u" ? Et.charset : t.charset;
  return {
    allowDots: typeof t.allowDots > "u" ? Et.allowDots : !!t.allowDots,
    allowPrototypes: typeof t.allowPrototypes == "boolean" ? t.allowPrototypes : Et.allowPrototypes,
    allowSparse: typeof t.allowSparse == "boolean" ? t.allowSparse : Et.allowSparse,
    arrayLimit: typeof t.arrayLimit == "number" ? t.arrayLimit : Et.arrayLimit,
    charset: n,
    charsetSentinel: typeof t.charsetSentinel == "boolean" ? t.charsetSentinel : Et.charsetSentinel,
    comma: typeof t.comma == "boolean" ? t.comma : Et.comma,
    decoder: typeof t.decoder == "function" ? t.decoder : Et.decoder,
    delimiter: typeof t.delimiter == "string" || Ts.isRegExp(t.delimiter) ? t.delimiter : Et.delimiter,
    // eslint-disable-next-line no-implicit-coercion, no-extra-parens
    depth: typeof t.depth == "number" || t.depth === !1 ? +t.depth : Et.depth,
    ignoreQueryPrefix: t.ignoreQueryPrefix === !0,
    interpretNumericEntities: typeof t.interpretNumericEntities == "boolean" ? t.interpretNumericEntities : Et.interpretNumericEntities,
    parameterLimit: typeof t.parameterLimit == "number" ? t.parameterLimit : Et.parameterLimit,
    parseArrays: t.parseArrays !== !1,
    plainObjects: typeof t.plainObjects == "boolean" ? t.plainObjects : Et.plainObjects,
    strictNullHandling: typeof t.strictNullHandling == "boolean" ? t.strictNullHandling : Et.strictNullHandling
  };
}, MJ = function(e, t) {
  var n = OJ(t);
  if (e === "" || e === null || typeof e > "u")
    return n.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  for (var r = typeof e == "string" ? DJ(e, n) : e, i = n.plainObjects ? /* @__PURE__ */ Object.create(null) : {}, s = Object.keys(r), a = 0; a < s.length; ++a) {
    var o = s[a], l = TJ(o, r[o], n, typeof e == "string");
    i = Ts.merge(i, l, n);
  }
  return n.allowSparse === !0 ? i : Ts.compact(i);
}, FJ = $J, PJ = MJ, IJ = pp, RJ = {
  formats: IJ,
  parse: PJ,
  stringify: FJ
};
const BJ = yn.checkout("request");
class NJ extends Lt {
  constructor(n) {
    super();
    V(this, "__names", null);
    V(this, "state", {});
    V(this, "cache", new wb({
      key: (n) => JSON.stringify(n),
      pick: async (n) => await this.http(n.path, n.data)
    }));
    V(this, "mocks", {});
    V(this, "params");
    V(this, "installed", !1);
    this.params = n;
  }
  get name() {
    return this.params.name;
  }
  static parseLaravelResourcePaginateResponse(n) {
    return Array.isArray(n.data) && n.meta && n.links, n;
  }
  static fakeLaravelPaginateResult(n) {
    return {
      data: n,
      total: 1,
      per_page: 1,
      current_page: 1,
      last_page: 1,
      from: 1,
      to: 1
    };
  }
  static fakeLaravelResourcePaginateResult(n) {
    return {
      data: n,
      links: {
        first: "",
        last: "",
        prev: "",
        next: ""
      },
      meta: {
        current_page: 1,
        from: "",
        path: "",
        last_page: 1,
        to: 1,
        per_page: 10,
        total: 1
      }
    };
  }
  static async AxiosRequest(n) {
    let { axios: r, context: i } = n, { method: s, path: a, query: o, headers: l, responseType: c, body: u } = i, f = null;
    return (s === "get" || s === "delete") && (f = await r[s](a, {
      params: o,
      headers: l,
      responseType: c
    })), (s === "post" || s === "put" || s === "patch") && (f = await r[s](a, u, {
      params: o,
      headers: l,
      responseType: c
    })), f;
  }
  parseUrl(n, r) {
    let i = n.split("@"), s = i[0], a = i.slice(1).join("@");
    if (r)
      for (let o in r) {
        if (r[o] == null)
          throw BJ.create(`Url ${n} param ${o} is null.`);
        a = a.replace(":" + o, r[o].toString());
      }
    return {
      path: a.split("#")[0],
      method: s
    };
  }
  mock(n, r) {
    this.mocks[n] = r;
  }
  export() {
    return this.http.bind(this);
  }
  exportKeep() {
    return this.httpKeepAlive.bind(this);
  }
  async httpKeepAlive(n, r) {
    return await this.cache.get({
      data: r,
      path: n
    });
  }
  async http(n, r) {
    this.installed === !1 && this.params.install && this.params.install(this), this.installed = !0;
    let i = this.parseUrl(n, r.params), s = r.headers || {}, a = {
      name: n,
      path: i.path,
      form: document.createElement("form"),
      body: r.body || {},
      query: r.query || {},
      state: this.state,
      headers: s,
      contentType: r.contentType || "application/json",
      responseType: r.responseType,
      method: i.method
    };
    if (a.contentType === "x-www-form-urlencoded") {
      let l = {};
      for (let [c, u] of Object.entries(a.body))
        Va.lastMatch(c, "[]") ? l[c.slice(0, -2)] = u : l[c] = u;
      a.body = RJ.stringify(l, {
        arrayFormat: "brackets"
      }), s.contentType = "application/x-www-form-urlencoded";
    }
    if (a.contentType === "multipart/form-data") {
      let l = new FormData();
      for (let c in a.body)
        l.append(c, a.body[c]);
      a.body = l, s.contentType = "multipart/form-data";
    }
    if (a.contentType === "multipart/form-data#json") {
      let l = new FormData();
      for (let c in a.body)
        l.append(c, a.body[c]);
      a.body = l;
    }
    if (a.contentType === "form") {
      a.form.setAttribute("method", a.method.toUpperCase());
      for (let l in a.body) {
        const c = a.body[l], u = document.createElement("input");
        u.setAttribute("type", "hidden"), u.setAttribute("name", l), u.setAttribute("value", typeof c == "string" ? c : JSON.stringify(c)), a.form.appendChild(u);
      }
      a.form.style.opacity = "0", a.form.style.position = "fixed", document.body.appendChild(a.form);
    }
    let o = null;
    return this.mocks && this.mocks[n] ? (await Lr.sleep(500), o = this.mocks[n](a), this.emit("useMockAfter", {
      context: a,
      response: o
    })) : o = await this.params.http(a), a.contentType === "form" && a.form.remove(), o;
  }
}
var eE = { exports: {} };
function LJ(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var Cf = { exports: {} }, mx;
function Se() {
  return mx || (mx = 1, function(e, t) {
    (function(n, r) {
      e.exports = r();
    })(ye, function() {
      var n = n || function(r, i) {
        var s;
        if (typeof window < "u" && window.crypto && (s = window.crypto), typeof self < "u" && self.crypto && (s = self.crypto), typeof globalThis < "u" && globalThis.crypto && (s = globalThis.crypto), !s && typeof window < "u" && window.msCrypto && (s = window.msCrypto), !s && typeof ye < "u" && ye.crypto && (s = ye.crypto), !s && typeof LJ == "function")
          try {
            s = V$;
          } catch {
          }
        var a = function() {
          if (s) {
            if (typeof s.getRandomValues == "function")
              try {
                return s.getRandomValues(new Uint32Array(1))[0];
              } catch {
              }
            if (typeof s.randomBytes == "function")
              try {
                return s.randomBytes(4).readInt32LE();
              } catch {
              }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        }, o = Object.create || /* @__PURE__ */ function() {
          function x() {
          }
          return function(_) {
            var y;
            return x.prototype = _, y = new x(), x.prototype = null, y;
          };
        }(), l = {}, c = l.lib = {}, u = c.Base = /* @__PURE__ */ function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(x) {
              var _ = o(this);
              return x && _.mixIn(x), (!_.hasOwnProperty("init") || this.init === _.init) && (_.init = function() {
                _.$super.init.apply(this, arguments);
              }), _.init.prototype = _, _.$super = this, _;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var x = this.extend();
              return x.init.apply(x, arguments), x;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(x) {
              for (var _ in x)
                x.hasOwnProperty(_) && (this[_] = x[_]);
              x.hasOwnProperty("toString") && (this.toString = x.toString);
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }(), f = c.WordArray = u.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(x, _) {
            x = this.words = x || [], _ != i ? this.sigBytes = _ : this.sigBytes = x.length * 4;
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(x) {
            return (x || h).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(x) {
            var _ = this.words, y = x.words, b = this.sigBytes, w = x.sigBytes;
            if (this.clamp(), b % 4)
              for (var E = 0; E < w; E++) {
                var $ = y[E >>> 2] >>> 24 - E % 4 * 8 & 255;
                _[b + E >>> 2] |= $ << 24 - (b + E) % 4 * 8;
              }
            else
              for (var C = 0; C < w; C += 4)
                _[b + C >>> 2] = y[C >>> 2];
            return this.sigBytes += w, this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var x = this.words, _ = this.sigBytes;
            x[_ >>> 2] &= 4294967295 << 32 - _ % 4 * 8, x.length = r.ceil(_ / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var x = u.clone.call(this);
            return x.words = this.words.slice(0), x;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(x) {
            for (var _ = [], y = 0; y < x; y += 4)
              _.push(a());
            return new f.init(_, x);
          }
        }), d = l.enc = {}, h = d.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(x) {
            for (var _ = x.words, y = x.sigBytes, b = [], w = 0; w < y; w++) {
              var E = _[w >>> 2] >>> 24 - w % 4 * 8 & 255;
              b.push((E >>> 4).toString(16)), b.push((E & 15).toString(16));
            }
            return b.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(x) {
            for (var _ = x.length, y = [], b = 0; b < _; b += 2)
              y[b >>> 3] |= parseInt(x.substr(b, 2), 16) << 24 - b % 8 * 4;
            return new f.init(y, _ / 2);
          }
        }, p = d.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(x) {
            for (var _ = x.words, y = x.sigBytes, b = [], w = 0; w < y; w++) {
              var E = _[w >>> 2] >>> 24 - w % 4 * 8 & 255;
              b.push(String.fromCharCode(E));
            }
            return b.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(x) {
            for (var _ = x.length, y = [], b = 0; b < _; b++)
              y[b >>> 2] |= (x.charCodeAt(b) & 255) << 24 - b % 4 * 8;
            return new f.init(y, _);
          }
        }, g = d.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(x) {
            try {
              return decodeURIComponent(escape(p.stringify(x)));
            } catch {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(x) {
            return p.parse(unescape(encodeURIComponent(x)));
          }
        }, v = c.BufferedBlockAlgorithm = u.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new f.init(), this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(x) {
            typeof x == "string" && (x = g.parse(x)), this._data.concat(x), this._nDataBytes += x.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(x) {
            var _, y = this._data, b = y.words, w = y.sigBytes, E = this.blockSize, $ = E * 4, C = w / $;
            x ? C = r.ceil(C) : C = r.max((C | 0) - this._minBufferSize, 0);
            var A = C * E, k = r.min(A * 4, w);
            if (A) {
              for (var D = 0; D < A; D += E)
                this._doProcessBlock(b, D);
              _ = b.splice(0, A), y.sigBytes -= k;
            }
            return new f.init(_, k);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var x = u.clone.call(this);
            return x._data = this._data.clone(), x;
          },
          _minBufferSize: 0
        });
        c.Hasher = v.extend({
          /**
           * Configuration options.
           */
          cfg: u.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(x) {
            this.cfg = this.cfg.extend(x), this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            v.reset.call(this), this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(x) {
            return this._append(x), this._process(), this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(x) {
            x && this._append(x);
            var _ = this._doFinalize();
            return _;
          },
          blockSize: 16,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(x) {
            return function(_, y) {
              return new x.init(y).finalize(_);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(x) {
            return function(_, y) {
              return new m.HMAC.init(x, y).finalize(_);
            };
          }
        });
        var m = l.algo = {};
        return l;
      }(Math);
      return n;
    });
  }(Cf)), Cf.exports;
}
var Df = { exports: {} }, yx;
function Su() {
  return yx || (yx = 1, function(e, t) {
    (function(n, r) {
      e.exports = r(Se());
    })(ye, function(n) {
      return function(r) {
        var i = n, s = i.lib, a = s.Base, o = s.WordArray, l = i.x64 = {};
        l.Word = a.extend({
          /**
           * Initializes a newly created 64-bit word.
           *
           * @param {number} high The high 32 bits.
           * @param {number} low The low 32 bits.
           *
           * @example
           *
           *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
           */
          init: function(c, u) {
            this.high = c, this.low = u;
          }
          /**
           * Bitwise NOTs this word.
           *
           * @return {X64Word} A new x64-Word object after negating.
           *
           * @example
           *
           *     var negated = x64Word.not();
           */
          // not: function () {
          // var high = ~this.high;
          // var low = ~this.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ANDs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to AND with this word.
           *
           * @return {X64Word} A new x64-Word object after ANDing.
           *
           * @example
           *
           *     var anded = x64Word.and(anotherX64Word);
           */
          // and: function (word) {
          // var high = this.high & word.high;
          // var low = this.low & word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to OR with this word.
           *
           * @return {X64Word} A new x64-Word object after ORing.
           *
           * @example
           *
           *     var ored = x64Word.or(anotherX64Word);
           */
          // or: function (word) {
          // var high = this.high | word.high;
          // var low = this.low | word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise XORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to XOR with this word.
           *
           * @return {X64Word} A new x64-Word object after XORing.
           *
           * @example
           *
           *     var xored = x64Word.xor(anotherX64Word);
           */
          // xor: function (word) {
          // var high = this.high ^ word.high;
          // var low = this.low ^ word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the left.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftL(25);
           */
          // shiftL: function (n) {
          // if (n < 32) {
          // var high = (this.high << n) | (this.low >>> (32 - n));
          // var low = this.low << n;
          // } else {
          // var high = this.low << (n - 32);
          // var low = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the right.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftR(7);
           */
          // shiftR: function (n) {
          // if (n < 32) {
          // var low = (this.low >>> n) | (this.high << (32 - n));
          // var high = this.high >>> n;
          // } else {
          // var low = this.high >>> (n - 32);
          // var high = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Rotates this word n bits to the left.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotL(25);
           */
          // rotL: function (n) {
          // return this.shiftL(n).or(this.shiftR(64 - n));
          // },
          /**
           * Rotates this word n bits to the right.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotR(7);
           */
          // rotR: function (n) {
          // return this.shiftR(n).or(this.shiftL(64 - n));
          // },
          /**
           * Adds this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to add with this word.
           *
           * @return {X64Word} A new x64-Word object after adding.
           *
           * @example
           *
           *     var added = x64Word.add(anotherX64Word);
           */
          // add: function (word) {
          // var low = (this.low + word.low) | 0;
          // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
          // var high = (this.high + word.high + carry) | 0;
          // return X64Word.create(high, low);
          // }
        }), l.WordArray = a.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.x64.WordArray.create();
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ]);
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ], 10);
           */
          init: function(c, u) {
            c = this.words = c || [], u != r ? this.sigBytes = u : this.sigBytes = c.length * 8;
          },
          /**
           * Converts this 64-bit word array to a 32-bit word array.
           *
           * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
           *
           * @example
           *
           *     var x32WordArray = x64WordArray.toX32();
           */
          toX32: function() {
            for (var c = this.words, u = c.length, f = [], d = 0; d < u; d++) {
              var h = c[d];
              f.push(h.high), f.push(h.low);
            }
            return o.create(f, this.sigBytes);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {X64WordArray} The clone.
           *
           * @example
           *
           *     var clone = x64WordArray.clone();
           */
          clone: function() {
            for (var c = a.clone.call(this), u = c.words = this.words.slice(0), f = u.length, d = 0; d < f; d++)
              u[d] = u[d].clone();
            return c;
          }
        });
      }(), n;
    });
  }(Df)), Df.exports;
}
var Sf = { exports: {} }, xx;
function jJ() {
  return xx || (xx = 1, function(e, t) {
    (function(n, r) {
      e.exports = r(Se());
    })(ye, function(n) {
      return function() {
        if (typeof ArrayBuffer == "function") {
          var r = n, i = r.lib, s = i.WordArray, a = s.init, o = s.init = function(l) {
            if (l instanceof ArrayBuffer && (l = new Uint8Array(l)), (l instanceof Int8Array || typeof Uint8ClampedArray < "u" && l instanceof Uint8ClampedArray || l instanceof Int16Array || l instanceof Uint16Array || l instanceof Int32Array || l instanceof Uint32Array || l instanceof Float32Array || l instanceof Float64Array) && (l = new Uint8Array(l.buffer, l.byteOffset, l.byteLength)), l instanceof Uint8Array) {
              for (var c = l.byteLength, u = [], f = 0; f < c; f++)
                u[f >>> 2] |= l[f] << 24 - f % 4 * 8;
              a.call(this, u, c);
            } else
              a.apply(this, arguments);
          };
          o.prototype = s;
        }
      }(), n.lib.WordArray;
    });
  }(Sf)), Sf.exports;
}
var Tf = { exports: {} }, bx;
function zJ() {
  return bx || (bx = 1, function(e, t) {
    (function(n, r) {
      e.exports = r(Se());
    })(ye, function(n) {
      return function() {
        var r = n, i = r.lib, s = i.WordArray, a = r.enc;
        a.Utf16 = a.Utf16BE = {
          /**
           * Converts a word array to a UTF-16 BE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 BE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
           */
          stringify: function(l) {
            for (var c = l.words, u = l.sigBytes, f = [], d = 0; d < u; d += 2) {
              var h = c[d >>> 2] >>> 16 - d % 4 * 8 & 65535;
              f.push(String.fromCharCode(h));
            }
            return f.join("");
          },
          /**
           * Converts a UTF-16 BE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 BE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
           */
          parse: function(l) {
            for (var c = l.length, u = [], f = 0; f < c; f++)
              u[f >>> 1] |= l.charCodeAt(f) << 16 - f % 2 * 16;
            return s.create(u, c * 2);
          }
        }, a.Utf16LE = {
          /**
           * Converts a word array to a UTF-16 LE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 LE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
           */
          stringify: function(l) {
            for (var c = l.words, u = l.sigBytes, f = [], d = 0; d < u; d += 2) {
              var h = o(c[d >>> 2] >>> 16 - d % 4 * 8 & 65535);
              f.push(String.fromCharCode(h));
            }
            return f.join("");
          },
          /**
           * Converts a UTF-16 LE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 LE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
           */
          parse: function(l) {
            for (var c = l.length, u = [], f = 0; f < c; f++)
              u[f >>> 1] |= o(l.charCodeAt(f) << 16 - f % 2 * 16);
            return s.create(u, c * 2);
          }
        };
        function o(l) {
          return l << 8 & 4278255360 | l >>> 8 & 16711935;
        }
      }(), n.enc.Utf16;
    });
  }(Tf)), Tf.exports;
}
var Of = { exports: {} }, _x;
function Bi() {
  return _x || (_x = 1, function(e, t) {
    (function(n, r) {
      e.exports = r(Se());
    })(ye, function(n) {
      return function() {
        var r = n, i = r.lib, s = i.WordArray, a = r.enc;
        a.Base64 = {
          /**
           * Converts a word array to a Base64 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Base64 string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
           */
          stringify: function(l) {
            var c = l.words, u = l.sigBytes, f = this._map;
            l.clamp();
            for (var d = [], h = 0; h < u; h += 3)
              for (var p = c[h >>> 2] >>> 24 - h % 4 * 8 & 255, g = c[h + 1 >>> 2] >>> 24 - (h + 1) % 4 * 8 & 255, v = c[h + 2 >>> 2] >>> 24 - (h + 2) % 4 * 8 & 255, m = p << 16 | g << 8 | v, x = 0; x < 4 && h + x * 0.75 < u; x++)
                d.push(f.charAt(m >>> 6 * (3 - x) & 63));
            var _ = f.charAt(64);
            if (_)
              for (; d.length % 4; )
                d.push(_);
            return d.join("");
          },
          /**
           * Converts a Base64 string to a word array.
           *
           * @param {string} base64Str The Base64 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
           */
          parse: function(l) {
            var c = l.length, u = this._map, f = this._reverseMap;
            if (!f) {
              f = this._reverseMap = [];
              for (var d = 0; d < u.length; d++)
                f[u.charCodeAt(d)] = d;
            }
            var h = u.charAt(64);
            if (h) {
              var p = l.indexOf(h);
              p !== -1 && (c = p);
            }
            return o(l, c, f);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        };
        function o(l, c, u) {
          for (var f = [], d = 0, h = 0; h < c; h++)
            if (h % 4) {
              var p = u[l.charCodeAt(h - 1)] << h % 4 * 2, g = u[l.charCodeAt(h)] >>> 6 - h % 4 * 2, v = p | g;
              f[d >>> 2] |= v << 24 - d % 4 * 8, d++;
            }
          return s.create(f, d);
        }
      }(), n.enc.Base64;
    });
  }(Of)), Of.exports;
}
var Mf = { exports: {} }, wx;
function VJ() {
  return wx || (wx = 1, function(e, t) {
    (function(n, r) {
      e.exports = r(Se());
    })(ye, function(n) {
      return function() {
        var r = n, i = r.lib, s = i.WordArray, a = r.enc;
        a.Base64url = {
          /**
           * Converts a word array to a Base64url string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @param {boolean} urlSafe Whether to use url safe
           *
           * @return {string} The Base64url string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);
           */
          stringify: function(l, c) {
            c === void 0 && (c = !0);
            var u = l.words, f = l.sigBytes, d = c ? this._safe_map : this._map;
            l.clamp();
            for (var h = [], p = 0; p < f; p += 3)
              for (var g = u[p >>> 2] >>> 24 - p % 4 * 8 & 255, v = u[p + 1 >>> 2] >>> 24 - (p + 1) % 4 * 8 & 255, m = u[p + 2 >>> 2] >>> 24 - (p + 2) % 4 * 8 & 255, x = g << 16 | v << 8 | m, _ = 0; _ < 4 && p + _ * 0.75 < f; _++)
                h.push(d.charAt(x >>> 6 * (3 - _) & 63));
            var y = d.charAt(64);
            if (y)
              for (; h.length % 4; )
                h.push(y);
            return h.join("");
          },
          /**
           * Converts a Base64url string to a word array.
           *
           * @param {string} base64Str The Base64url string.
           *
           * @param {boolean} urlSafe Whether to use url safe
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);
           */
          parse: function(l, c) {
            c === void 0 && (c = !0);
            var u = l.length, f = c ? this._safe_map : this._map, d = this._reverseMap;
            if (!d) {
              d = this._reverseMap = [];
              for (var h = 0; h < f.length; h++)
                d[f.charCodeAt(h)] = h;
            }
            var p = f.charAt(64);
            if (p) {
              var g = l.indexOf(p);
              g !== -1 && (u = g);
            }
            return o(l, u, d);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
          _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
        };
        function o(l, c, u) {
          for (var f = [], d = 0, h = 0; h < c; h++)
            if (h % 4) {
              var p = u[l.charCodeAt(h - 1)] << h % 4 * 2, g = u[l.charCodeAt(h)] >>> 6 - h % 4 * 2, v = p | g;
              f[d >>> 2] |= v << 24 - d % 4 * 8, d++;
            }
          return s.create(f, d);
        }
      }(), n.enc.Base64url;
    });
  }(Mf)), Mf.exports;
}
var Ff = { exports: {} }, $x;
function Ni() {
  return $x || ($x = 1, function(e, t) {
    (function(n, r) {
      e.exports = r(Se());
    })(ye, function(n) {
      return function(r) {
        var i = n, s = i.lib, a = s.WordArray, o = s.Hasher, l = i.algo, c = [];
        (function() {
          for (var g = 0; g < 64; g++)
            c[g] = r.abs(r.sin(g + 1)) * 4294967296 | 0;
        })();
        var u = l.MD5 = o.extend({
          _doReset: function() {
            this._hash = new a.init([
              1732584193,
              4023233417,
              2562383102,
              271733878
            ]);
          },
          _doProcessBlock: function(g, v) {
            for (var m = 0; m < 16; m++) {
              var x = v + m, _ = g[x];
              g[x] = (_ << 8 | _ >>> 24) & 16711935 | (_ << 24 | _ >>> 8) & 4278255360;
            }
            var y = this._hash.words, b = g[v + 0], w = g[v + 1], E = g[v + 2], $ = g[v + 3], C = g[v + 4], A = g[v + 5], k = g[v + 6], D = g[v + 7], S = g[v + 8], L = g[v + 9], P = g[v + 10], H = g[v + 11], M = g[v + 12], B = g[v + 13], W = g[v + 14], R = g[v + 15], O = y[0], N = y[1], z = y[2], I = y[3];
            O = f(O, N, z, I, b, 7, c[0]), I = f(I, O, N, z, w, 12, c[1]), z = f(z, I, O, N, E, 17, c[2]), N = f(N, z, I, O, $, 22, c[3]), O = f(O, N, z, I, C, 7, c[4]), I = f(I, O, N, z, A, 12, c[5]), z = f(z, I, O, N, k, 17, c[6]), N = f(N, z, I, O, D, 22, c[7]), O = f(O, N, z, I, S, 7, c[8]), I = f(I, O, N, z, L, 12, c[9]), z = f(z, I, O, N, P, 17, c[10]), N = f(N, z, I, O, H, 22, c[11]), O = f(O, N, z, I, M, 7, c[12]), I = f(I, O, N, z, B, 12, c[13]), z = f(z, I, O, N, W, 17, c[14]), N = f(N, z, I, O, R, 22, c[15]), O = d(O, N, z, I, w, 5, c[16]), I = d(I, O, N, z, k, 9, c[17]), z = d(z, I, O, N, H, 14, c[18]), N = d(N, z, I, O, b, 20, c[19]), O = d(O, N, z, I, A, 5, c[20]), I = d(I, O, N, z, P, 9, c[21]), z = d(z, I, O, N, R, 14, c[22]), N = d(N, z, I, O, C, 20, c[23]), O = d(O, N, z, I, L, 5, c[24]), I = d(I, O, N, z, W, 9, c[25]), z = d(z, I, O, N, $, 14, c[26]), N = d(N, z, I, O, S, 20, c[27]), O = d(O, N, z, I, B, 5, c[28]), I = d(I, O, N, z, E, 9, c[29]), z = d(z, I, O, N, D, 14, c[30]), N = d(N, z, I, O, M, 20, c[31]), O = h(O, N, z, I, A, 4, c[32]), I = h(I, O, N, z, S, 11, c[33]), z = h(z, I, O, N, H, 16, c[34]), N = h(N, z, I, O, W, 23, c[35]), O = h(O, N, z, I, w, 4, c[36]), I = h(I, O, N, z, C, 11, c[37]), z = h(z, I, O, N, D, 16, c[38]), N = h(N, z, I, O, P, 23, c[39]), O = h(O, N, z, I, B, 4, c[40]), I = h(I, O, N, z, b, 11, c[41]), z = h(z, I, O, N, $, 16, c[42]), N = h(N, z, I, O, k, 23, c[43]), O = h(O, N, z, I, L, 4, c[44]), I = h(I, O, N, z, M, 11, c[45]), z = h(z, I, O, N, R, 16, c[46]), N = h(N, z, I, O, E, 23, c[47]), O = p(O, N, z, I, b, 6, c[48]), I = p(I, O, N, z, D, 10, c[49]), z = p(z, I, O, N, W, 15, c[50]), N = p(N, z, I, O, A, 21, c[51]), O = p(O, N, z, I, M, 6, c[52]), I = p(I, O, N, z, $, 10, c[53]), z = p(z, I, O, N, P, 15, c[54]), N = p(N, z, I, O, w, 21, c[55]), O = p(O, N, z, I, S, 6, c[56]), I = p(I, O, N, z, R, 10, c[57]), z = p(z, I, O, N, k, 15, c[58]), N = p(N, z, I, O, B, 21, c[59]), O = p(O, N, z, I, C, 6, c[60]), I = p(I, O, N, z, H, 10, c[61]), z = p(z, I, O, N, E, 15, c[62]), N = p(N, z, I, O, L, 21, c[63]), y[0] = y[0] + O | 0, y[1] = y[1] + N | 0, y[2] = y[2] + z | 0, y[3] = y[3] + I | 0;
          },
          _doFinalize: function() {
            var g = this._data, v = g.words, m = this._nDataBytes * 8, x = g.sigBytes * 8;
            v[x >>> 5] |= 128 << 24 - x % 32;
            var _ = r.floor(m / 4294967296), y = m;
            v[(x + 64 >>> 9 << 4) + 15] = (_ << 8 | _ >>> 24) & 16711935 | (_ << 24 | _ >>> 8) & 4278255360, v[(x + 64 >>> 9 << 4) + 14] = (y << 8 | y >>> 24) & 16711935 | (y << 24 | y >>> 8) & 4278255360, g.sigBytes = (v.length + 1) * 4, this._process();
            for (var b = this._hash, w = b.words, E = 0; E < 4; E++) {
              var $ = w[E];
              w[E] = ($ << 8 | $ >>> 24) & 16711935 | ($ << 24 | $ >>> 8) & 4278255360;
            }
            return b;
          },
          clone: function() {
            var g = o.clone.call(this);
            return g._hash = this._hash.clone(), g;
          }
        });
        function f(g, v, m, x, _, y, b) {
          var w = g + (v & m | ~v & x) + _ + b;
          return (w << y | w >>> 32 - y) + v;
        }
        function d(g, v, m, x, _, y, b) {
          var w = g + (v & x | m & ~x) + _ + b;
          return (w << y | w >>> 32 - y) + v;
        }
        function h(g, v, m, x, _, y, b) {
          var w = g + (v ^ m ^ x) + _ + b;
          return (w << y | w >>> 32 - y) + v;
        }
        function p(g, v, m, x, _, y, b) {
          var w = g + (m ^ (v | ~x)) + _ + b;
          return (w << y | w >>> 32 - y) + v;
        }
        i.MD5 = o._createHelper(u), i.HmacMD5 = o._createHmacHelper(u);
      }(Math), n.MD5;
    });
  }(Ff)), Ff.exports;
}
var Pf = { exports: {} }, Ex;
function tE() {
  return Ex || (Ex = 1, function(e, t) {
    (function(n, r) {
      e.exports = r(Se());
    })(ye, function(n) {
      return function() {
        var r = n, i = r.lib, s = i.WordArray, a = i.Hasher, o = r.algo, l = [], c = o.SHA1 = a.extend({
          _doReset: function() {
            this._hash = new s.init([
              1732584193,
              4023233417,
              2562383102,
              271733878,
              3285377520
            ]);
          },
          _doProcessBlock: function(u, f) {
            for (var d = this._hash.words, h = d[0], p = d[1], g = d[2], v = d[3], m = d[4], x = 0; x < 80; x++) {
              if (x < 16)
                l[x] = u[f + x] | 0;
              else {
                var _ = l[x - 3] ^ l[x - 8] ^ l[x - 14] ^ l[x - 16];
                l[x] = _ << 1 | _ >>> 31;
              }
              var y = (h << 5 | h >>> 27) + m + l[x];
              x < 20 ? y += (p & g | ~p & v) + 1518500249 : x < 40 ? y += (p ^ g ^ v) + 1859775393 : x < 60 ? y += (p & g | p & v | g & v) - 1894007588 : y += (p ^ g ^ v) - 899497514, m = v, v = g, g = p << 30 | p >>> 2, p = h, h = y;
            }
            d[0] = d[0] + h | 0, d[1] = d[1] + p | 0, d[2] = d[2] + g | 0, d[3] = d[3] + v | 0, d[4] = d[4] + m | 0;
          },
          _doFinalize: function() {
            var u = this._data, f = u.words, d = this._nDataBytes * 8, h = u.sigBytes * 8;
            return f[h >>> 5] |= 128 << 24 - h % 32, f[(h + 64 >>> 9 << 4) + 14] = Math.floor(d / 4294967296), f[(h + 64 >>> 9 << 4) + 15] = d, u.sigBytes = f.length * 4, this._process(), this._hash;
          },
          clone: function() {
            var u = a.clone.call(this);
            return u._hash = this._hash.clone(), u;
          }
        });
        r.SHA1 = a._createHelper(c), r.HmacSHA1 = a._createHmacHelper(c);
      }(), n.SHA1;
    });
  }(Pf)), Pf.exports;
}
var If = { exports: {} }, Ax;
function gp() {
  return Ax || (Ax = 1, function(e, t) {
    (function(n, r) {
      e.exports = r(Se());
    })(ye, function(n) {
      return function(r) {
        var i = n, s = i.lib, a = s.WordArray, o = s.Hasher, l = i.algo, c = [], u = [];
        (function() {
          function h(m) {
            for (var x = r.sqrt(m), _ = 2; _ <= x; _++)
              if (!(m % _))
                return !1;
            return !0;
          }
          function p(m) {
            return (m - (m | 0)) * 4294967296 | 0;
          }
          for (var g = 2, v = 0; v < 64; )
            h(g) && (v < 8 && (c[v] = p(r.pow(g, 1 / 2))), u[v] = p(r.pow(g, 1 / 3)), v++), g++;
        })();
        var f = [], d = l.SHA256 = o.extend({
          _doReset: function() {
            this._hash = new a.init(c.slice(0));
          },
          _doProcessBlock: function(h, p) {
            for (var g = this._hash.words, v = g[0], m = g[1], x = g[2], _ = g[3], y = g[4], b = g[5], w = g[6], E = g[7], $ = 0; $ < 64; $++) {
              if ($ < 16)
                f[$] = h[p + $] | 0;
              else {
                var C = f[$ - 15], A = (C << 25 | C >>> 7) ^ (C << 14 | C >>> 18) ^ C >>> 3, k = f[$ - 2], D = (k << 15 | k >>> 17) ^ (k << 13 | k >>> 19) ^ k >>> 10;
                f[$] = A + f[$ - 7] + D + f[$ - 16];
              }
              var S = y & b ^ ~y & w, L = v & m ^ v & x ^ m & x, P = (v << 30 | v >>> 2) ^ (v << 19 | v >>> 13) ^ (v << 10 | v >>> 22), H = (y << 26 | y >>> 6) ^ (y << 21 | y >>> 11) ^ (y << 7 | y >>> 25), M = E + H + S + u[$] + f[$], B = P + L;
              E = w, w = b, b = y, y = _ + M | 0, _ = x, x = m, m = v, v = M + B | 0;
            }
            g[0] = g[0] + v | 0, g[1] = g[1] + m | 0, g[2] = g[2] + x | 0, g[3] = g[3] + _ | 0, g[4] = g[4] + y | 0, g[5] = g[5] + b | 0, g[6] = g[6] + w | 0, g[7] = g[7] + E | 0;
          },
          _doFinalize: function() {
            var h = this._data, p = h.words, g = this._nDataBytes * 8, v = h.sigBytes * 8;
            return p[v >>> 5] |= 128 << 24 - v % 32, p[(v + 64 >>> 9 << 4) + 14] = r.floor(g / 4294967296), p[(v + 64 >>> 9 << 4) + 15] = g, h.sigBytes = p.length * 4, this._process(), this._hash;
          },
          clone: function() {
            var h = o.clone.call(this);
            return h._hash = this._hash.clone(), h;
          }
        });
        i.SHA256 = o._createHelper(d), i.HmacSHA256 = o._createHmacHelper(d);
      }(Math), n.SHA256;
    });
  }(If)), If.exports;
}
var Rf = { exports: {} }, kx;
function HJ() {
  return kx || (kx = 1, function(e, t) {
    (function(n, r, i) {
      e.exports = r(Se(), gp());
    })(ye, function(n) {
      return function() {
        var r = n, i = r.lib, s = i.WordArray, a = r.algo, o = a.SHA256, l = a.SHA224 = o.extend({
          _doReset: function() {
            this._hash = new s.init([
              3238371032,
              914150663,
              812702999,
              4144912697,
              4290775857,
              1750603025,
              1694076839,
              3204075428
            ]);
          },
          _doFinalize: function() {
            var c = o._doFinalize.call(this);
            return c.sigBytes -= 4, c;
          }
        });
        r.SHA224 = o._createHelper(l), r.HmacSHA224 = o._createHmacHelper(l);
      }(), n.SHA224;
    });
  }(Rf)), Rf.exports;
}
var Bf = { exports: {} }, Cx;
function nE() {
  return Cx || (Cx = 1, function(e, t) {
    (function(n, r, i) {
      e.exports = r(Se(), Su());
    })(ye, function(n) {
      return function() {
        var r = n, i = r.lib, s = i.Hasher, a = r.x64, o = a.Word, l = a.WordArray, c = r.algo;
        function u() {
          return o.create.apply(o, arguments);
        }
        var f = [
          u(1116352408, 3609767458),
          u(1899447441, 602891725),
          u(3049323471, 3964484399),
          u(3921009573, 2173295548),
          u(961987163, 4081628472),
          u(1508970993, 3053834265),
          u(2453635748, 2937671579),
          u(2870763221, 3664609560),
          u(3624381080, 2734883394),
          u(310598401, 1164996542),
          u(607225278, 1323610764),
          u(1426881987, 3590304994),
          u(1925078388, 4068182383),
          u(2162078206, 991336113),
          u(2614888103, 633803317),
          u(3248222580, 3479774868),
          u(3835390401, 2666613458),
          u(4022224774, 944711139),
          u(264347078, 2341262773),
          u(604807628, 2007800933),
          u(770255983, 1495990901),
          u(1249150122, 1856431235),
          u(1555081692, 3175218132),
          u(1996064986, 2198950837),
          u(2554220882, 3999719339),
          u(2821834349, 766784016),
          u(2952996808, 2566594879),
          u(3210313671, 3203337956),
          u(3336571891, 1034457026),
          u(3584528711, 2466948901),
          u(113926993, 3758326383),
          u(338241895, 168717936),
          u(666307205, 1188179964),
          u(773529912, 1546045734),
          u(1294757372, 1522805485),
          u(1396182291, 2643833823),
          u(1695183700, 2343527390),
          u(1986661051, 1014477480),
          u(2177026350, 1206759142),
          u(2456956037, 344077627),
          u(2730485921, 1290863460),
          u(2820302411, 3158454273),
          u(3259730800, 3505952657),
          u(3345764771, 106217008),
          u(3516065817, 3606008344),
          u(3600352804, 1432725776),
          u(4094571909, 1467031594),
          u(275423344, 851169720),
          u(430227734, 3100823752),
          u(506948616, 1363258195),
          u(659060556, 3750685593),
          u(883997877, 3785050280),
          u(958139571, 3318307427),
          u(1322822218, 3812723403),
          u(1537002063, 2003034995),
          u(1747873779, 3602036899),
          u(1955562222, 1575990012),
          u(2024104815, 1125592928),
          u(2227730452, 2716904306),
          u(2361852424, 442776044),
          u(2428436474, 593698344),
          u(2756734187, 3733110249),
          u(3204031479, 2999351573),
          u(3329325298, 3815920427),
          u(3391569614, 3928383900),
          u(3515267271, 566280711),
          u(3940187606, 3454069534),
          u(4118630271, 4000239992),
          u(116418474, 1914138554),
          u(174292421, 2731055270),
          u(289380356, 3203993006),
          u(460393269, 320620315),
          u(685471733, 587496836),
          u(852142971, 1086792851),
          u(1017036298, 365543100),
          u(1126000580, 2618297676),
          u(1288033470, 3409855158),
          u(1501505948, 4234509866),
          u(1607167915, 987167468),
          u(1816402316, 1246189591)
        ], d = [];
        (function() {
          for (var p = 0; p < 80; p++)
            d[p] = u();
        })();
        var h = c.SHA512 = s.extend({
          _doReset: function() {
            this._hash = new l.init([
              new o.init(1779033703, 4089235720),
              new o.init(3144134277, 2227873595),
              new o.init(1013904242, 4271175723),
              new o.init(2773480762, 1595750129),
              new o.init(1359893119, 2917565137),
              new o.init(2600822924, 725511199),
              new o.init(528734635, 4215389547),
              new o.init(1541459225, 327033209)
            ]);
          },
          _doProcessBlock: function(p, g) {
            for (var v = this._hash.words, m = v[0], x = v[1], _ = v[2], y = v[3], b = v[4], w = v[5], E = v[6], $ = v[7], C = m.high, A = m.low, k = x.high, D = x.low, S = _.high, L = _.low, P = y.high, H = y.low, M = b.high, B = b.low, W = w.high, R = w.low, O = E.high, N = E.low, z = $.high, I = $.low, te = C, ee = A, _e = k, re = D, Ae = S, st = L, ut = P, yt = H, He = M, We = B, wt = W, Ke = R, Ht = O, Tt = N, ce = z, xt = I, xe = 0; xe < 80; xe++) {
              var he, ft, dt = d[xe];
              if (xe < 16)
                ft = dt.high = p[g + xe * 2] | 0, he = dt.low = p[g + xe * 2 + 1] | 0;
              else {
                var Ft = d[xe - 15], $t = Ft.high, J = Ft.low, ne = ($t >>> 1 | J << 31) ^ ($t >>> 8 | J << 24) ^ $t >>> 7, me = (J >>> 1 | $t << 31) ^ (J >>> 8 | $t << 24) ^ (J >>> 7 | $t << 25), we = d[xe - 2], ze = we.high, ht = we.low, Yr = (ze >>> 19 | ht << 13) ^ (ze << 3 | ht >>> 29) ^ ze >>> 6, xr = (ht >>> 19 | ze << 13) ^ (ht << 3 | ze >>> 29) ^ (ht >>> 6 | ze << 26), qr = d[xe - 7], Z = qr.high, Q = qr.low, ue = d[xe - 16], F = ue.high, K = ue.low;
                he = me + Q, ft = ne + Z + (he >>> 0 < me >>> 0 ? 1 : 0), he = he + xr, ft = ft + Yr + (he >>> 0 < xr >>> 0 ? 1 : 0), he = he + K, ft = ft + F + (he >>> 0 < K >>> 0 ? 1 : 0), dt.high = ft, dt.low = he;
              }
              var ae = He & wt ^ ~He & Ht, $e = We & Ke ^ ~We & Tt, at = te & _e ^ te & Ae ^ _e & Ae, Jt = ee & re ^ ee & st ^ re & st, Pt = (te >>> 28 | ee << 4) ^ (te << 30 | ee >>> 2) ^ (te << 25 | ee >>> 7), qn = (ee >>> 28 | te << 4) ^ (ee << 30 | te >>> 2) ^ (ee << 25 | te >>> 7), Gr = (He >>> 14 | We << 18) ^ (He >>> 18 | We << 14) ^ (He << 23 | We >>> 9), zi = (We >>> 14 | He << 18) ^ (We >>> 18 | He << 14) ^ (We << 23 | He >>> 9), Wt = f[xe], Vi = Wt.high, br = Wt.low, Ot = xt + zi, xn = ce + Gr + (Ot >>> 0 < xt >>> 0 ? 1 : 0), Ot = Ot + $e, xn = xn + ae + (Ot >>> 0 < $e >>> 0 ? 1 : 0), Ot = Ot + br, xn = xn + Vi + (Ot >>> 0 < br >>> 0 ? 1 : 0), Ot = Ot + he, xn = xn + ft + (Ot >>> 0 < he >>> 0 ? 1 : 0), qp = qn + Jt, VA = Pt + at + (qp >>> 0 < qn >>> 0 ? 1 : 0);
              ce = Ht, xt = Tt, Ht = wt, Tt = Ke, wt = He, Ke = We, We = yt + Ot | 0, He = ut + xn + (We >>> 0 < yt >>> 0 ? 1 : 0) | 0, ut = Ae, yt = st, Ae = _e, st = re, _e = te, re = ee, ee = Ot + qp | 0, te = xn + VA + (ee >>> 0 < Ot >>> 0 ? 1 : 0) | 0;
            }
            A = m.low = A + ee, m.high = C + te + (A >>> 0 < ee >>> 0 ? 1 : 0), D = x.low = D + re, x.high = k + _e + (D >>> 0 < re >>> 0 ? 1 : 0), L = _.low = L + st, _.high = S + Ae + (L >>> 0 < st >>> 0 ? 1 : 0), H = y.low = H + yt, y.high = P + ut + (H >>> 0 < yt >>> 0 ? 1 : 0), B = b.low = B + We, b.high = M + He + (B >>> 0 < We >>> 0 ? 1 : 0), R = w.low = R + Ke, w.high = W + wt + (R >>> 0 < Ke >>> 0 ? 1 : 0), N = E.low = N + Tt, E.high = O + Ht + (N >>> 0 < Tt >>> 0 ? 1 : 0), I = $.low = I + xt, $.high = z + ce + (I >>> 0 < xt >>> 0 ? 1 : 0);
          },
          _doFinalize: function() {
            var p = this._data, g = p.words, v = this._nDataBytes * 8, m = p.sigBytes * 8;
            g[m >>> 5] |= 128 << 24 - m % 32, g[(m + 128 >>> 10 << 5) + 30] = Math.floor(v / 4294967296), g[(m + 128 >>> 10 << 5) + 31] = v, p.sigBytes = g.length * 4, this._process();
            var x = this._hash.toX32();
            return x;
          },
          clone: function() {
            var p = s.clone.call(this);
            return p._hash = this._hash.clone(), p;
          },
          blockSize: 1024 / 32
        });
        r.SHA512 = s._createHelper(h), r.HmacSHA512 = s._createHmacHelper(h);
      }(), n.SHA512;
    });
  }(Bf)), Bf.exports;
}
var Nf = { exports: {} }, Dx;
function WJ() {
  return Dx || (Dx = 1, function(e, t) {
    (function(n, r, i) {
      e.exports = r(Se(), Su(), nE());
    })(ye, function(n) {
      return function() {
        var r = n, i = r.x64, s = i.Word, a = i.WordArray, o = r.algo, l = o.SHA512, c = o.SHA384 = l.extend({
          _doReset: function() {
            this._hash = new a.init([
              new s.init(3418070365, 3238371032),
              new s.init(1654270250, 914150663),
              new s.init(2438529370, 812702999),
              new s.init(355462360, 4144912697),
              new s.init(1731405415, 4290775857),
              new s.init(2394180231, 1750603025),
              new s.init(3675008525, 1694076839),
              new s.init(1203062813, 3204075428)
            ]);
          },
          _doFinalize: function() {
            var u = l._doFinalize.call(this);
            return u.sigBytes -= 16, u;
          }
        });
        r.SHA384 = l._createHelper(c), r.HmacSHA384 = l._createHmacHelper(c);
      }(), n.SHA384;
    });
  }(Nf)), Nf.exports;
}
var Lf = { exports: {} }, Sx;
function UJ() {
  return Sx || (Sx = 1, function(e, t) {
    (function(n, r, i) {
      e.exports = r(Se(), Su());
    })(ye, function(n) {
      return function(r) {
        var i = n, s = i.lib, a = s.WordArray, o = s.Hasher, l = i.x64, c = l.Word, u = i.algo, f = [], d = [], h = [];
        (function() {
          for (var v = 1, m = 0, x = 0; x < 24; x++) {
            f[v + 5 * m] = (x + 1) * (x + 2) / 2 % 64;
            var _ = m % 5, y = (2 * v + 3 * m) % 5;
            v = _, m = y;
          }
          for (var v = 0; v < 5; v++)
            for (var m = 0; m < 5; m++)
              d[v + 5 * m] = m + (2 * v + 3 * m) % 5 * 5;
          for (var b = 1, w = 0; w < 24; w++) {
            for (var E = 0, $ = 0, C = 0; C < 7; C++) {
              if (b & 1) {
                var A = (1 << C) - 1;
                A < 32 ? $ ^= 1 << A : E ^= 1 << A - 32;
              }
              b & 128 ? b = b << 1 ^ 113 : b <<= 1;
            }
            h[w] = c.create(E, $);
          }
        })();
        var p = [];
        (function() {
          for (var v = 0; v < 25; v++)
            p[v] = c.create();
        })();
        var g = u.SHA3 = o.extend({
          /**
           * Configuration options.
           *
           * @property {number} outputLength
           *   The desired number of bits in the output hash.
           *   Only values permitted are: 224, 256, 384, 512.
           *   Default: 512
           */
          cfg: o.cfg.extend({
            outputLength: 512
          }),
          _doReset: function() {
            for (var v = this._state = [], m = 0; m < 25; m++)
              v[m] = new c.init();
            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
          },
          _doProcessBlock: function(v, m) {
            for (var x = this._state, _ = this.blockSize / 2, y = 0; y < _; y++) {
              var b = v[m + 2 * y], w = v[m + 2 * y + 1];
              b = (b << 8 | b >>> 24) & 16711935 | (b << 24 | b >>> 8) & 4278255360, w = (w << 8 | w >>> 24) & 16711935 | (w << 24 | w >>> 8) & 4278255360;
              var E = x[y];
              E.high ^= w, E.low ^= b;
            }
            for (var $ = 0; $ < 24; $++) {
              for (var C = 0; C < 5; C++) {
                for (var A = 0, k = 0, D = 0; D < 5; D++) {
                  var E = x[C + 5 * D];
                  A ^= E.high, k ^= E.low;
                }
                var S = p[C];
                S.high = A, S.low = k;
              }
              for (var C = 0; C < 5; C++)
                for (var L = p[(C + 4) % 5], P = p[(C + 1) % 5], H = P.high, M = P.low, A = L.high ^ (H << 1 | M >>> 31), k = L.low ^ (M << 1 | H >>> 31), D = 0; D < 5; D++) {
                  var E = x[C + 5 * D];
                  E.high ^= A, E.low ^= k;
                }
              for (var B = 1; B < 25; B++) {
                var A, k, E = x[B], W = E.high, R = E.low, O = f[B];
                O < 32 ? (A = W << O | R >>> 32 - O, k = R << O | W >>> 32 - O) : (A = R << O - 32 | W >>> 64 - O, k = W << O - 32 | R >>> 64 - O);
                var N = p[d[B]];
                N.high = A, N.low = k;
              }
              var z = p[0], I = x[0];
              z.high = I.high, z.low = I.low;
              for (var C = 0; C < 5; C++)
                for (var D = 0; D < 5; D++) {
                  var B = C + 5 * D, E = x[B], te = p[B], ee = p[(C + 1) % 5 + 5 * D], _e = p[(C + 2) % 5 + 5 * D];
                  E.high = te.high ^ ~ee.high & _e.high, E.low = te.low ^ ~ee.low & _e.low;
                }
              var E = x[0], re = h[$];
              E.high ^= re.high, E.low ^= re.low;
            }
          },
          _doFinalize: function() {
            var v = this._data, m = v.words;
            this._nDataBytes * 8;
            var x = v.sigBytes * 8, _ = this.blockSize * 32;
            m[x >>> 5] |= 1 << 24 - x % 32, m[(r.ceil((x + 1) / _) * _ >>> 5) - 1] |= 128, v.sigBytes = m.length * 4, this._process();
            for (var y = this._state, b = this.cfg.outputLength / 8, w = b / 8, E = [], $ = 0; $ < w; $++) {
              var C = y[$], A = C.high, k = C.low;
              A = (A << 8 | A >>> 24) & 16711935 | (A << 24 | A >>> 8) & 4278255360, k = (k << 8 | k >>> 24) & 16711935 | (k << 24 | k >>> 8) & 4278255360, E.push(k), E.push(A);
            }
            return new a.init(E, b);
          },
          clone: function() {
            for (var v = o.clone.call(this), m = v._state = this._state.slice(0), x = 0; x < 25; x++)
              m[x] = m[x].clone();
            return v;
          }
        });
        i.SHA3 = o._createHelper(g), i.HmacSHA3 = o._createHmacHelper(g);
      }(Math), n.SHA3;
    });
  }(Lf)), Lf.exports;
}
var jf = { exports: {} }, Tx;
function YJ() {
  return Tx || (Tx = 1, function(e, t) {
    (function(n, r) {
      e.exports = r(Se());
    })(ye, function(n) {
      /** @preserve
      			(c) 2012 by Cédric Mesnil. All rights reserved.
      
      			Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
      
      			    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
      			    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
      
      			THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
      			*/
      return function(r) {
        var i = n, s = i.lib, a = s.WordArray, o = s.Hasher, l = i.algo, c = a.create([
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          7,
          4,
          13,
          1,
          10,
          6,
          15,
          3,
          12,
          0,
          9,
          5,
          2,
          14,
          11,
          8,
          3,
          10,
          14,
          4,
          9,
          15,
          8,
          1,
          2,
          7,
          0,
          6,
          13,
          11,
          5,
          12,
          1,
          9,
          11,
          10,
          0,
          8,
          12,
          4,
          13,
          3,
          7,
          15,
          14,
          5,
          6,
          2,
          4,
          0,
          5,
          9,
          7,
          12,
          2,
          10,
          14,
          1,
          3,
          8,
          11,
          6,
          15,
          13
        ]), u = a.create([
          5,
          14,
          7,
          0,
          9,
          2,
          11,
          4,
          13,
          6,
          15,
          8,
          1,
          10,
          3,
          12,
          6,
          11,
          3,
          7,
          0,
          13,
          5,
          10,
          14,
          15,
          8,
          12,
          4,
          9,
          1,
          2,
          15,
          5,
          1,
          3,
          7,
          14,
          6,
          9,
          11,
          8,
          12,
          2,
          10,
          0,
          4,
          13,
          8,
          6,
          4,
          1,
          3,
          11,
          15,
          0,
          5,
          12,
          2,
          13,
          9,
          7,
          10,
          14,
          12,
          15,
          10,
          4,
          1,
          5,
          8,
          7,
          6,
          2,
          13,
          14,
          0,
          3,
          9,
          11
        ]), f = a.create([
          11,
          14,
          15,
          12,
          5,
          8,
          7,
          9,
          11,
          13,
          14,
          15,
          6,
          7,
          9,
          8,
          7,
          6,
          8,
          13,
          11,
          9,
          7,
          15,
          7,
          12,
          15,
          9,
          11,
          7,
          13,
          12,
          11,
          13,
          6,
          7,
          14,
          9,
          13,
          15,
          14,
          8,
          13,
          6,
          5,
          12,
          7,
          5,
          11,
          12,
          14,
          15,
          14,
          15,
          9,
          8,
          9,
          14,
          5,
          6,
          8,
          6,
          5,
          12,
          9,
          15,
          5,
          11,
          6,
          8,
          13,
          12,
          5,
          12,
          13,
          14,
          11,
          8,
          5,
          6
        ]), d = a.create([
          8,
          9,
          9,
          11,
          13,
          15,
          15,
          5,
          7,
          7,
          8,
          11,
          14,
          14,
          12,
          6,
          9,
          13,
          15,
          7,
          12,
          8,
          9,
          11,
          7,
          7,
          12,
          7,
          6,
          15,
          13,
          11,
          9,
          7,
          15,
          11,
          8,
          6,
          6,
          14,
          12,
          13,
          5,
          14,
          13,
          13,
          7,
          5,
          15,
          5,
          8,
          11,
          14,
          14,
          6,
          14,
          6,
          9,
          12,
          9,
          12,
          5,
          15,
          8,
          8,
          5,
          12,
          9,
          12,
          5,
          14,
          6,
          8,
          13,
          6,
          5,
          15,
          13,
          11,
          11
        ]), h = a.create([0, 1518500249, 1859775393, 2400959708, 2840853838]), p = a.create([1352829926, 1548603684, 1836072691, 2053994217, 0]), g = l.RIPEMD160 = o.extend({
          _doReset: function() {
            this._hash = a.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
          },
          _doProcessBlock: function(w, E) {
            for (var $ = 0; $ < 16; $++) {
              var C = E + $, A = w[C];
              w[C] = (A << 8 | A >>> 24) & 16711935 | (A << 24 | A >>> 8) & 4278255360;
            }
            var k = this._hash.words, D = h.words, S = p.words, L = c.words, P = u.words, H = f.words, M = d.words, B, W, R, O, N, z, I, te, ee, _e;
            z = B = k[0], I = W = k[1], te = R = k[2], ee = O = k[3], _e = N = k[4];
            for (var re, $ = 0; $ < 80; $ += 1)
              re = B + w[E + L[$]] | 0, $ < 16 ? re += v(W, R, O) + D[0] : $ < 32 ? re += m(W, R, O) + D[1] : $ < 48 ? re += x(W, R, O) + D[2] : $ < 64 ? re += _(W, R, O) + D[3] : re += y(W, R, O) + D[4], re = re | 0, re = b(re, H[$]), re = re + N | 0, B = N, N = O, O = b(R, 10), R = W, W = re, re = z + w[E + P[$]] | 0, $ < 16 ? re += y(I, te, ee) + S[0] : $ < 32 ? re += _(I, te, ee) + S[1] : $ < 48 ? re += x(I, te, ee) + S[2] : $ < 64 ? re += m(I, te, ee) + S[3] : re += v(I, te, ee) + S[4], re = re | 0, re = b(re, M[$]), re = re + _e | 0, z = _e, _e = ee, ee = b(te, 10), te = I, I = re;
            re = k[1] + R + ee | 0, k[1] = k[2] + O + _e | 0, k[2] = k[3] + N + z | 0, k[3] = k[4] + B + I | 0, k[4] = k[0] + W + te | 0, k[0] = re;
          },
          _doFinalize: function() {
            var w = this._data, E = w.words, $ = this._nDataBytes * 8, C = w.sigBytes * 8;
            E[C >>> 5] |= 128 << 24 - C % 32, E[(C + 64 >>> 9 << 4) + 14] = ($ << 8 | $ >>> 24) & 16711935 | ($ << 24 | $ >>> 8) & 4278255360, w.sigBytes = (E.length + 1) * 4, this._process();
            for (var A = this._hash, k = A.words, D = 0; D < 5; D++) {
              var S = k[D];
              k[D] = (S << 8 | S >>> 24) & 16711935 | (S << 24 | S >>> 8) & 4278255360;
            }
            return A;
          },
          clone: function() {
            var w = o.clone.call(this);
            return w._hash = this._hash.clone(), w;
          }
        });
        function v(w, E, $) {
          return w ^ E ^ $;
        }
        function m(w, E, $) {
          return w & E | ~w & $;
        }
        function x(w, E, $) {
          return (w | ~E) ^ $;
        }
        function _(w, E, $) {
          return w & $ | E & ~$;
        }
        function y(w, E, $) {
          return w ^ (E | ~$);
        }
        function b(w, E) {
          return w << E | w >>> 32 - E;
        }
        i.RIPEMD160 = o._createHelper(g), i.HmacRIPEMD160 = o._createHmacHelper(g);
      }(), n.RIPEMD160;
    });
  }(jf)), jf.exports;
}
var zf = { exports: {} }, Ox;
function vp() {
  return Ox || (Ox = 1, function(e, t) {
    (function(n, r) {
      e.exports = r(Se());
    })(ye, function(n) {
      (function() {
        var r = n, i = r.lib, s = i.Base, a = r.enc, o = a.Utf8, l = r.algo;
        l.HMAC = s.extend({
          /**
           * Initializes a newly created HMAC.
           *
           * @param {Hasher} hasher The hash algorithm to use.
           * @param {WordArray|string} key The secret key.
           *
           * @example
           *
           *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
           */
          init: function(c, u) {
            c = this._hasher = new c.init(), typeof u == "string" && (u = o.parse(u));
            var f = c.blockSize, d = f * 4;
            u.sigBytes > d && (u = c.finalize(u)), u.clamp();
            for (var h = this._oKey = u.clone(), p = this._iKey = u.clone(), g = h.words, v = p.words, m = 0; m < f; m++)
              g[m] ^= 1549556828, v[m] ^= 909522486;
            h.sigBytes = p.sigBytes = d, this.reset();
          },
          /**
           * Resets this HMAC to its initial state.
           *
           * @example
           *
           *     hmacHasher.reset();
           */
          reset: function() {
            var c = this._hasher;
            c.reset(), c.update(this._iKey);
          },
          /**
           * Updates this HMAC with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {HMAC} This HMAC instance.
           *
           * @example
           *
           *     hmacHasher.update('message');
           *     hmacHasher.update(wordArray);
           */
          update: function(c) {
            return this._hasher.update(c), this;
          },
          /**
           * Finalizes the HMAC computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The HMAC.
           *
           * @example
           *
           *     var hmac = hmacHasher.finalize();
           *     var hmac = hmacHasher.finalize('message');
           *     var hmac = hmacHasher.finalize(wordArray);
           */
          finalize: function(c) {
            var u = this._hasher, f = u.finalize(c);
            u.reset();
            var d = u.finalize(this._oKey.clone().concat(f));
            return d;
          }
        });
      })();
    });
  }(zf)), zf.exports;
}
var Vf = { exports: {} }, Mx;
function qJ() {
  return Mx || (Mx = 1, function(e, t) {
    (function(n, r, i) {
      e.exports = r(Se(), gp(), vp());
    })(ye, function(n) {
      return function() {
        var r = n, i = r.lib, s = i.Base, a = i.WordArray, o = r.algo, l = o.SHA256, c = o.HMAC, u = o.PBKDF2 = s.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hasher to use. Default: SHA256
           * @property {number} iterations The number of iterations to perform. Default: 250000
           */
          cfg: s.extend({
            keySize: 128 / 32,
            hasher: l,
            iterations: 25e4
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.PBKDF2.create();
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
           */
          init: function(f) {
            this.cfg = this.cfg.extend(f);
          },
          /**
           * Computes the Password-Based Key Derivation Function 2.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function(f, d) {
            for (var h = this.cfg, p = c.create(h.hasher, f), g = a.create(), v = a.create([1]), m = g.words, x = v.words, _ = h.keySize, y = h.iterations; m.length < _; ) {
              var b = p.update(d).finalize(v);
              p.reset();
              for (var w = b.words, E = w.length, $ = b, C = 1; C < y; C++) {
                $ = p.finalize($), p.reset();
                for (var A = $.words, k = 0; k < E; k++)
                  w[k] ^= A[k];
              }
              g.concat(b), x[0]++;
            }
            return g.sigBytes = _ * 4, g;
          }
        });
        r.PBKDF2 = function(f, d, h) {
          return u.create(h).compute(f, d);
        };
      }(), n.PBKDF2;
    });
  }(Vf)), Vf.exports;
}
var Hf = { exports: {} }, Fx;
function Wr() {
  return Fx || (Fx = 1, function(e, t) {
    (function(n, r, i) {
      e.exports = r(Se(), tE(), vp());
    })(ye, function(n) {
      return function() {
        var r = n, i = r.lib, s = i.Base, a = i.WordArray, o = r.algo, l = o.MD5, c = o.EvpKDF = s.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hash algorithm to use. Default: MD5
           * @property {number} iterations The number of iterations to perform. Default: 1
           */
          cfg: s.extend({
            keySize: 128 / 32,
            hasher: l,
            iterations: 1
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.EvpKDF.create();
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
           */
          init: function(u) {
            this.cfg = this.cfg.extend(u);
          },
          /**
           * Derives a key from a password.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function(u, f) {
            for (var d, h = this.cfg, p = h.hasher.create(), g = a.create(), v = g.words, m = h.keySize, x = h.iterations; v.length < m; ) {
              d && p.update(d), d = p.update(u).finalize(f), p.reset();
              for (var _ = 1; _ < x; _++)
                d = p.finalize(d), p.reset();
              g.concat(d);
            }
            return g.sigBytes = m * 4, g;
          }
        });
        r.EvpKDF = function(u, f, d) {
          return c.create(d).compute(u, f);
        };
      }(), n.EvpKDF;
    });
  }(Hf)), Hf.exports;
}
var Wf = { exports: {} }, Px;
function St() {
  return Px || (Px = 1, function(e, t) {
    (function(n, r, i) {
      e.exports = r(Se(), Wr());
    })(ye, function(n) {
      n.lib.Cipher || function(r) {
        var i = n, s = i.lib, a = s.Base, o = s.WordArray, l = s.BufferedBlockAlgorithm, c = i.enc;
        c.Utf8;
        var u = c.Base64, f = i.algo, d = f.EvpKDF, h = s.Cipher = l.extend({
          /**
           * Configuration options.
           *
           * @property {WordArray} iv The IV to use for this operation.
           */
          cfg: a.extend(),
          /**
           * Creates this cipher in encryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
           */
          createEncryptor: function(A, k) {
            return this.create(this._ENC_XFORM_MODE, A, k);
          },
          /**
           * Creates this cipher in decryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
           */
          createDecryptor: function(A, k) {
            return this.create(this._DEC_XFORM_MODE, A, k);
          },
          /**
           * Initializes a newly created cipher.
           *
           * @param {number} xformMode Either the encryption or decryption transormation mode constant.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
           */
          init: function(A, k, D) {
            this.cfg = this.cfg.extend(D), this._xformMode = A, this._key = k, this.reset();
          },
          /**
           * Resets this cipher to its initial state.
           *
           * @example
           *
           *     cipher.reset();
           */
          reset: function() {
            l.reset.call(this), this._doReset();
          },
          /**
           * Adds data to be encrypted or decrypted.
           *
           * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
           *
           * @return {WordArray} The data after processing.
           *
           * @example
           *
           *     var encrypted = cipher.process('data');
           *     var encrypted = cipher.process(wordArray);
           */
          process: function(A) {
            return this._append(A), this._process();
          },
          /**
           * Finalizes the encryption or decryption process.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
           *
           * @return {WordArray} The data after final processing.
           *
           * @example
           *
           *     var encrypted = cipher.finalize();
           *     var encrypted = cipher.finalize('data');
           *     var encrypted = cipher.finalize(wordArray);
           */
          finalize: function(A) {
            A && this._append(A);
            var k = this._doFinalize();
            return k;
          },
          keySize: 128 / 32,
          ivSize: 128 / 32,
          _ENC_XFORM_MODE: 1,
          _DEC_XFORM_MODE: 2,
          /**
           * Creates shortcut functions to a cipher's object interface.
           *
           * @param {Cipher} cipher The cipher to create a helper for.
           *
           * @return {Object} An object with encrypt and decrypt shortcut functions.
           *
           * @static
           *
           * @example
           *
           *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
           */
          _createHelper: /* @__PURE__ */ function() {
            function A(k) {
              return typeof k == "string" ? C : w;
            }
            return function(k) {
              return {
                encrypt: function(D, S, L) {
                  return A(S).encrypt(k, D, S, L);
                },
                decrypt: function(D, S, L) {
                  return A(S).decrypt(k, D, S, L);
                }
              };
            };
          }()
        });
        s.StreamCipher = h.extend({
          _doFinalize: function() {
            var A = this._process(!0);
            return A;
          },
          blockSize: 1
        });
        var p = i.mode = {}, g = s.BlockCipherMode = a.extend({
          /**
           * Creates this mode for encryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
           */
          createEncryptor: function(A, k) {
            return this.Encryptor.create(A, k);
          },
          /**
           * Creates this mode for decryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
           */
          createDecryptor: function(A, k) {
            return this.Decryptor.create(A, k);
          },
          /**
           * Initializes a newly created mode.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
           */
          init: function(A, k) {
            this._cipher = A, this._iv = k;
          }
        }), v = p.CBC = function() {
          var A = g.extend();
          A.Encryptor = A.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function(D, S) {
              var L = this._cipher, P = L.blockSize;
              k.call(this, D, S, P), L.encryptBlock(D, S), this._prevBlock = D.slice(S, S + P);
            }
          }), A.Decryptor = A.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function(D, S) {
              var L = this._cipher, P = L.blockSize, H = D.slice(S, S + P);
              L.decryptBlock(D, S), k.call(this, D, S, P), this._prevBlock = H;
            }
          });
          function k(D, S, L) {
            var P, H = this._iv;
            H ? (P = H, this._iv = r) : P = this._prevBlock;
            for (var M = 0; M < L; M++)
              D[S + M] ^= P[M];
          }
          return A;
        }(), m = i.pad = {}, x = m.Pkcs7 = {
          /**
           * Pads data using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to pad.
           * @param {number} blockSize The multiple that the data should be padded to.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
           */
          pad: function(A, k) {
            for (var D = k * 4, S = D - A.sigBytes % D, L = S << 24 | S << 16 | S << 8 | S, P = [], H = 0; H < S; H += 4)
              P.push(L);
            var M = o.create(P, S);
            A.concat(M);
          },
          /**
           * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to unpad.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.unpad(wordArray);
           */
          unpad: function(A) {
            var k = A.words[A.sigBytes - 1 >>> 2] & 255;
            A.sigBytes -= k;
          }
        };
        s.BlockCipher = h.extend({
          /**
           * Configuration options.
           *
           * @property {Mode} mode The block mode to use. Default: CBC
           * @property {Padding} padding The padding strategy to use. Default: Pkcs7
           */
          cfg: h.cfg.extend({
            mode: v,
            padding: x
          }),
          reset: function() {
            var A;
            h.reset.call(this);
            var k = this.cfg, D = k.iv, S = k.mode;
            this._xformMode == this._ENC_XFORM_MODE ? A = S.createEncryptor : (A = S.createDecryptor, this._minBufferSize = 1), this._mode && this._mode.__creator == A ? this._mode.init(this, D && D.words) : (this._mode = A.call(S, this, D && D.words), this._mode.__creator = A);
          },
          _doProcessBlock: function(A, k) {
            this._mode.processBlock(A, k);
          },
          _doFinalize: function() {
            var A, k = this.cfg.padding;
            return this._xformMode == this._ENC_XFORM_MODE ? (k.pad(this._data, this.blockSize), A = this._process(!0)) : (A = this._process(!0), k.unpad(A)), A;
          },
          blockSize: 128 / 32
        });
        var _ = s.CipherParams = a.extend({
          /**
           * Initializes a newly created cipher params object.
           *
           * @param {Object} cipherParams An object with any of the possible cipher parameters.
           *
           * @example
           *
           *     var cipherParams = CryptoJS.lib.CipherParams.create({
           *         ciphertext: ciphertextWordArray,
           *         key: keyWordArray,
           *         iv: ivWordArray,
           *         salt: saltWordArray,
           *         algorithm: CryptoJS.algo.AES,
           *         mode: CryptoJS.mode.CBC,
           *         padding: CryptoJS.pad.PKCS7,
           *         blockSize: 4,
           *         formatter: CryptoJS.format.OpenSSL
           *     });
           */
          init: function(A) {
            this.mixIn(A);
          },
          /**
           * Converts this cipher params object to a string.
           *
           * @param {Format} formatter (Optional) The formatting strategy to use.
           *
           * @return {string} The stringified cipher params.
           *
           * @throws Error If neither the formatter nor the default formatter is set.
           *
           * @example
           *
           *     var string = cipherParams + '';
           *     var string = cipherParams.toString();
           *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
           */
          toString: function(A) {
            return (A || this.formatter).stringify(this);
          }
        }), y = i.format = {}, b = y.OpenSSL = {
          /**
           * Converts a cipher params object to an OpenSSL-compatible string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The OpenSSL-compatible string.
           *
           * @static
           *
           * @example
           *
           *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
           */
          stringify: function(A) {
            var k, D = A.ciphertext, S = A.salt;
            return S ? k = o.create([1398893684, 1701076831]).concat(S).concat(D) : k = D, k.toString(u);
          },
          /**
           * Converts an OpenSSL-compatible string to a cipher params object.
           *
           * @param {string} openSSLStr The OpenSSL-compatible string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
           */
          parse: function(A) {
            var k, D = u.parse(A), S = D.words;
            return S[0] == 1398893684 && S[1] == 1701076831 && (k = o.create(S.slice(2, 4)), S.splice(0, 4), D.sigBytes -= 16), _.create({ ciphertext: D, salt: k });
          }
        }, w = s.SerializableCipher = a.extend({
          /**
           * Configuration options.
           *
           * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
           */
          cfg: a.extend({
            format: b
          }),
          /**
           * Encrypts a message.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          encrypt: function(A, k, D, S) {
            S = this.cfg.extend(S);
            var L = A.createEncryptor(D, S), P = L.finalize(k), H = L.cfg;
            return _.create({
              ciphertext: P,
              key: D,
              iv: H.iv,
              algorithm: A,
              mode: H.mode,
              padding: H.padding,
              blockSize: A.blockSize,
              formatter: S.format
            });
          },
          /**
           * Decrypts serialized ciphertext.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          decrypt: function(A, k, D, S) {
            S = this.cfg.extend(S), k = this._parse(k, S.format);
            var L = A.createDecryptor(D, S).finalize(k.ciphertext);
            return L;
          },
          /**
           * Converts serialized ciphertext to CipherParams,
           * else assumed CipherParams already and returns ciphertext unchanged.
           *
           * @param {CipherParams|string} ciphertext The ciphertext.
           * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
           *
           * @return {CipherParams} The unserialized ciphertext.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
           */
          _parse: function(A, k) {
            return typeof A == "string" ? k.parse(A, this) : A;
          }
        }), E = i.kdf = {}, $ = E.OpenSSL = {
          /**
           * Derives a key and IV from a password.
           *
           * @param {string} password The password to derive from.
           * @param {number} keySize The size in words of the key to generate.
           * @param {number} ivSize The size in words of the IV to generate.
           * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
           *
           * @return {CipherParams} A cipher params object with the key, IV, and salt.
           *
           * @static
           *
           * @example
           *
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
           */
          execute: function(A, k, D, S, L) {
            if (S || (S = o.random(64 / 8)), L)
              var P = d.create({ keySize: k + D, hasher: L }).compute(A, S);
            else
              var P = d.create({ keySize: k + D }).compute(A, S);
            var H = o.create(P.words.slice(k), D * 4);
            return P.sigBytes = k * 4, _.create({ key: P, iv: H, salt: S });
          }
        }, C = s.PasswordBasedCipher = w.extend({
          /**
           * Configuration options.
           *
           * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
           */
          cfg: w.cfg.extend({
            kdf: $
          }),
          /**
           * Encrypts a message using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
           */
          encrypt: function(A, k, D, S) {
            S = this.cfg.extend(S);
            var L = S.kdf.execute(D, A.keySize, A.ivSize, S.salt, S.hasher);
            S.iv = L.iv;
            var P = w.encrypt.call(this, A, k, L.key, S);
            return P.mixIn(L), P;
          },
          /**
           * Decrypts serialized ciphertext using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
           */
          decrypt: function(A, k, D, S) {
            S = this.cfg.extend(S), k = this._parse(k, S.format);
            var L = S.kdf.execute(D, A.keySize, A.ivSize, k.salt, S.hasher);
            S.iv = L.iv;
            var P = w.decrypt.call(this, A, k, L.key, S);
            return P;
          }
        });
      }();
    });
  }(Wf)), Wf.exports;
}
var Uf = { exports: {} }, Ix;
function GJ() {
  return Ix || (Ix = 1, function(e, t) {
    (function(n, r, i) {
      e.exports = r(Se(), St());
    })(ye, function(n) {
      return n.mode.CFB = function() {
        var r = n.lib.BlockCipherMode.extend();
        r.Encryptor = r.extend({
          processBlock: function(s, a) {
            var o = this._cipher, l = o.blockSize;
            i.call(this, s, a, l, o), this._prevBlock = s.slice(a, a + l);
          }
        }), r.Decryptor = r.extend({
          processBlock: function(s, a) {
            var o = this._cipher, l = o.blockSize, c = s.slice(a, a + l);
            i.call(this, s, a, l, o), this._prevBlock = c;
          }
        });
        function i(s, a, o, l) {
          var c, u = this._iv;
          u ? (c = u.slice(0), this._iv = void 0) : c = this._prevBlock, l.encryptBlock(c, 0);
          for (var f = 0; f < o; f++)
            s[a + f] ^= c[f];
        }
        return r;
      }(), n.mode.CFB;
    });
  }(Uf)), Uf.exports;
}
var Yf = { exports: {} }, Rx;
function XJ() {
  return Rx || (Rx = 1, function(e, t) {
    (function(n, r, i) {
      e.exports = r(Se(), St());
    })(ye, function(n) {
      return n.mode.CTR = function() {
        var r = n.lib.BlockCipherMode.extend(), i = r.Encryptor = r.extend({
          processBlock: function(s, a) {
            var o = this._cipher, l = o.blockSize, c = this._iv, u = this._counter;
            c && (u = this._counter = c.slice(0), this._iv = void 0);
            var f = u.slice(0);
            o.encryptBlock(f, 0), u[l - 1] = u[l - 1] + 1 | 0;
            for (var d = 0; d < l; d++)
              s[a + d] ^= f[d];
          }
        });
        return r.Decryptor = i, r;
      }(), n.mode.CTR;
    });
  }(Yf)), Yf.exports;
}
var qf = { exports: {} }, Bx;
function ZJ() {
  return Bx || (Bx = 1, function(e, t) {
    (function(n, r, i) {
      e.exports = r(Se(), St());
    })(ye, function(n) {
      /** @preserve
       * Counter block mode compatible with  Dr Brian Gladman fileenc.c
       * derived from CryptoJS.mode.CTR
       * Jan Hruby jhruby.web@gmail.com
       */
      return n.mode.CTRGladman = function() {
        var r = n.lib.BlockCipherMode.extend();
        function i(o) {
          if ((o >> 24 & 255) === 255) {
            var l = o >> 16 & 255, c = o >> 8 & 255, u = o & 255;
            l === 255 ? (l = 0, c === 255 ? (c = 0, u === 255 ? u = 0 : ++u) : ++c) : ++l, o = 0, o += l << 16, o += c << 8, o += u;
          } else
            o += 1 << 24;
          return o;
        }
        function s(o) {
          return (o[0] = i(o[0])) === 0 && (o[1] = i(o[1])), o;
        }
        var a = r.Encryptor = r.extend({
          processBlock: function(o, l) {
            var c = this._cipher, u = c.blockSize, f = this._iv, d = this._counter;
            f && (d = this._counter = f.slice(0), this._iv = void 0), s(d);
            var h = d.slice(0);
            c.encryptBlock(h, 0);
            for (var p = 0; p < u; p++)
              o[l + p] ^= h[p];
          }
        });
        return r.Decryptor = a, r;
      }(), n.mode.CTRGladman;
    });
  }(qf)), qf.exports;
}
var Gf = { exports: {} }, Nx;
function KJ() {
  return Nx || (Nx = 1, function(e, t) {
    (function(n, r, i) {
      e.exports = r(Se(), St());
    })(ye, function(n) {
      return n.mode.OFB = function() {
        var r = n.lib.BlockCipherMode.extend(), i = r.Encryptor = r.extend({
          processBlock: function(s, a) {
            var o = this._cipher, l = o.blockSize, c = this._iv, u = this._keystream;
            c && (u = this._keystream = c.slice(0), this._iv = void 0), o.encryptBlock(u, 0);
            for (var f = 0; f < l; f++)
              s[a + f] ^= u[f];
          }
        });
        return r.Decryptor = i, r;
      }(), n.mode.OFB;
    });
  }(Gf)), Gf.exports;
}
var Xf = { exports: {} }, Lx;
function JJ() {
  return Lx || (Lx = 1, function(e, t) {
    (function(n, r, i) {
      e.exports = r(Se(), St());
    })(ye, function(n) {
      return n.mode.ECB = function() {
        var r = n.lib.BlockCipherMode.extend();
        return r.Encryptor = r.extend({
          processBlock: function(i, s) {
            this._cipher.encryptBlock(i, s);
          }
        }), r.Decryptor = r.extend({
          processBlock: function(i, s) {
            this._cipher.decryptBlock(i, s);
          }
        }), r;
      }(), n.mode.ECB;
    });
  }(Xf)), Xf.exports;
}
var Zf = { exports: {} }, jx;
function QJ() {
  return jx || (jx = 1, function(e, t) {
    (function(n, r, i) {
      e.exports = r(Se(), St());
    })(ye, function(n) {
      return n.pad.AnsiX923 = {
        pad: function(r, i) {
          var s = r.sigBytes, a = i * 4, o = a - s % a, l = s + o - 1;
          r.clamp(), r.words[l >>> 2] |= o << 24 - l % 4 * 8, r.sigBytes += o;
        },
        unpad: function(r) {
          var i = r.words[r.sigBytes - 1 >>> 2] & 255;
          r.sigBytes -= i;
        }
      }, n.pad.Ansix923;
    });
  }(Zf)), Zf.exports;
}
var Kf = { exports: {} }, zx;
function eQ() {
  return zx || (zx = 1, function(e, t) {
    (function(n, r, i) {
      e.exports = r(Se(), St());
    })(ye, function(n) {
      return n.pad.Iso10126 = {
        pad: function(r, i) {
          var s = i * 4, a = s - r.sigBytes % s;
          r.concat(n.lib.WordArray.random(a - 1)).concat(n.lib.WordArray.create([a << 24], 1));
        },
        unpad: function(r) {
          var i = r.words[r.sigBytes - 1 >>> 2] & 255;
          r.sigBytes -= i;
        }
      }, n.pad.Iso10126;
    });
  }(Kf)), Kf.exports;
}
var Jf = { exports: {} }, Vx;
function tQ() {
  return Vx || (Vx = 1, function(e, t) {
    (function(n, r, i) {
      e.exports = r(Se(), St());
    })(ye, function(n) {
      return n.pad.Iso97971 = {
        pad: function(r, i) {
          r.concat(n.lib.WordArray.create([2147483648], 1)), n.pad.ZeroPadding.pad(r, i);
        },
        unpad: function(r) {
          n.pad.ZeroPadding.unpad(r), r.sigBytes--;
        }
      }, n.pad.Iso97971;
    });
  }(Jf)), Jf.exports;
}
var Qf = { exports: {} }, Hx;
function nQ() {
  return Hx || (Hx = 1, function(e, t) {
    (function(n, r, i) {
      e.exports = r(Se(), St());
    })(ye, function(n) {
      return n.pad.ZeroPadding = {
        pad: function(r, i) {
          var s = i * 4;
          r.clamp(), r.sigBytes += s - (r.sigBytes % s || s);
        },
        unpad: function(r) {
          for (var i = r.words, s = r.sigBytes - 1, s = r.sigBytes - 1; s >= 0; s--)
            if (i[s >>> 2] >>> 24 - s % 4 * 8 & 255) {
              r.sigBytes = s + 1;
              break;
            }
        }
      }, n.pad.ZeroPadding;
    });
  }(Qf)), Qf.exports;
}
var ed = { exports: {} }, Wx;
function rQ() {
  return Wx || (Wx = 1, function(e, t) {
    (function(n, r, i) {
      e.exports = r(Se(), St());
    })(ye, function(n) {
      return n.pad.NoPadding = {
        pad: function() {
        },
        unpad: function() {
        }
      }, n.pad.NoPadding;
    });
  }(ed)), ed.exports;
}
var td = { exports: {} }, Ux;
function iQ() {
  return Ux || (Ux = 1, function(e, t) {
    (function(n, r, i) {
      e.exports = r(Se(), St());
    })(ye, function(n) {
      return function(r) {
        var i = n, s = i.lib, a = s.CipherParams, o = i.enc, l = o.Hex, c = i.format;
        c.Hex = {
          /**
           * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The hexadecimally encoded string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
           */
          stringify: function(u) {
            return u.ciphertext.toString(l);
          },
          /**
           * Converts a hexadecimally encoded ciphertext string to a cipher params object.
           *
           * @param {string} input The hexadecimally encoded string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
           */
          parse: function(u) {
            var f = l.parse(u);
            return a.create({ ciphertext: f });
          }
        };
      }(), n.format.Hex;
    });
  }(td)), td.exports;
}
var nd = { exports: {} }, Yx;
function sQ() {
  return Yx || (Yx = 1, function(e, t) {
    (function(n, r, i) {
      e.exports = r(Se(), Bi(), Ni(), Wr(), St());
    })(ye, function(n) {
      return function() {
        var r = n, i = r.lib, s = i.BlockCipher, a = r.algo, o = [], l = [], c = [], u = [], f = [], d = [], h = [], p = [], g = [], v = [];
        (function() {
          for (var _ = [], y = 0; y < 256; y++)
            y < 128 ? _[y] = y << 1 : _[y] = y << 1 ^ 283;
          for (var b = 0, w = 0, y = 0; y < 256; y++) {
            var E = w ^ w << 1 ^ w << 2 ^ w << 3 ^ w << 4;
            E = E >>> 8 ^ E & 255 ^ 99, o[b] = E, l[E] = b;
            var $ = _[b], C = _[$], A = _[C], k = _[E] * 257 ^ E * 16843008;
            c[b] = k << 24 | k >>> 8, u[b] = k << 16 | k >>> 16, f[b] = k << 8 | k >>> 24, d[b] = k;
            var k = A * 16843009 ^ C * 65537 ^ $ * 257 ^ b * 16843008;
            h[E] = k << 24 | k >>> 8, p[E] = k << 16 | k >>> 16, g[E] = k << 8 | k >>> 24, v[E] = k, b ? (b = $ ^ _[_[_[A ^ $]]], w ^= _[_[w]]) : b = w = 1;
          }
        })();
        var m = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], x = a.AES = s.extend({
          _doReset: function() {
            var _;
            if (!(this._nRounds && this._keyPriorReset === this._key)) {
              for (var y = this._keyPriorReset = this._key, b = y.words, w = y.sigBytes / 4, E = this._nRounds = w + 6, $ = (E + 1) * 4, C = this._keySchedule = [], A = 0; A < $; A++)
                A < w ? C[A] = b[A] : (_ = C[A - 1], A % w ? w > 6 && A % w == 4 && (_ = o[_ >>> 24] << 24 | o[_ >>> 16 & 255] << 16 | o[_ >>> 8 & 255] << 8 | o[_ & 255]) : (_ = _ << 8 | _ >>> 24, _ = o[_ >>> 24] << 24 | o[_ >>> 16 & 255] << 16 | o[_ >>> 8 & 255] << 8 | o[_ & 255], _ ^= m[A / w | 0] << 24), C[A] = C[A - w] ^ _);
              for (var k = this._invKeySchedule = [], D = 0; D < $; D++) {
                var A = $ - D;
                if (D % 4)
                  var _ = C[A];
                else
                  var _ = C[A - 4];
                D < 4 || A <= 4 ? k[D] = _ : k[D] = h[o[_ >>> 24]] ^ p[o[_ >>> 16 & 255]] ^ g[o[_ >>> 8 & 255]] ^ v[o[_ & 255]];
              }
            }
          },
          encryptBlock: function(_, y) {
            this._doCryptBlock(_, y, this._keySchedule, c, u, f, d, o);
          },
          decryptBlock: function(_, y) {
            var b = _[y + 1];
            _[y + 1] = _[y + 3], _[y + 3] = b, this._doCryptBlock(_, y, this._invKeySchedule, h, p, g, v, l);
            var b = _[y + 1];
            _[y + 1] = _[y + 3], _[y + 3] = b;
          },
          _doCryptBlock: function(_, y, b, w, E, $, C, A) {
            for (var k = this._nRounds, D = _[y] ^ b[0], S = _[y + 1] ^ b[1], L = _[y + 2] ^ b[2], P = _[y + 3] ^ b[3], H = 4, M = 1; M < k; M++) {
              var B = w[D >>> 24] ^ E[S >>> 16 & 255] ^ $[L >>> 8 & 255] ^ C[P & 255] ^ b[H++], W = w[S >>> 24] ^ E[L >>> 16 & 255] ^ $[P >>> 8 & 255] ^ C[D & 255] ^ b[H++], R = w[L >>> 24] ^ E[P >>> 16 & 255] ^ $[D >>> 8 & 255] ^ C[S & 255] ^ b[H++], O = w[P >>> 24] ^ E[D >>> 16 & 255] ^ $[S >>> 8 & 255] ^ C[L & 255] ^ b[H++];
              D = B, S = W, L = R, P = O;
            }
            var B = (A[D >>> 24] << 24 | A[S >>> 16 & 255] << 16 | A[L >>> 8 & 255] << 8 | A[P & 255]) ^ b[H++], W = (A[S >>> 24] << 24 | A[L >>> 16 & 255] << 16 | A[P >>> 8 & 255] << 8 | A[D & 255]) ^ b[H++], R = (A[L >>> 24] << 24 | A[P >>> 16 & 255] << 16 | A[D >>> 8 & 255] << 8 | A[S & 255]) ^ b[H++], O = (A[P >>> 24] << 24 | A[D >>> 16 & 255] << 16 | A[S >>> 8 & 255] << 8 | A[L & 255]) ^ b[H++];
            _[y] = B, _[y + 1] = W, _[y + 2] = R, _[y + 3] = O;
          },
          keySize: 256 / 32
        });
        r.AES = s._createHelper(x);
      }(), n.AES;
    });
  }(nd)), nd.exports;
}
var rd = { exports: {} }, qx;
function aQ() {
  return qx || (qx = 1, function(e, t) {
    (function(n, r, i) {
      e.exports = r(Se(), Bi(), Ni(), Wr(), St());
    })(ye, function(n) {
      return function() {
        var r = n, i = r.lib, s = i.WordArray, a = i.BlockCipher, o = r.algo, l = [
          57,
          49,
          41,
          33,
          25,
          17,
          9,
          1,
          58,
          50,
          42,
          34,
          26,
          18,
          10,
          2,
          59,
          51,
          43,
          35,
          27,
          19,
          11,
          3,
          60,
          52,
          44,
          36,
          63,
          55,
          47,
          39,
          31,
          23,
          15,
          7,
          62,
          54,
          46,
          38,
          30,
          22,
          14,
          6,
          61,
          53,
          45,
          37,
          29,
          21,
          13,
          5,
          28,
          20,
          12,
          4
        ], c = [
          14,
          17,
          11,
          24,
          1,
          5,
          3,
          28,
          15,
          6,
          21,
          10,
          23,
          19,
          12,
          4,
          26,
          8,
          16,
          7,
          27,
          20,
          13,
          2,
          41,
          52,
          31,
          37,
          47,
          55,
          30,
          40,
          51,
          45,
          33,
          48,
          44,
          49,
          39,
          56,
          34,
          53,
          46,
          42,
          50,
          36,
          29,
          32
        ], u = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28], f = [
          {
            0: 8421888,
            268435456: 32768,
            536870912: 8421378,
            805306368: 2,
            1073741824: 512,
            1342177280: 8421890,
            1610612736: 8389122,
            1879048192: 8388608,
            2147483648: 514,
            2415919104: 8389120,
            2684354560: 33280,
            2952790016: 8421376,
            3221225472: 32770,
            3489660928: 8388610,
            3758096384: 0,
            4026531840: 33282,
            134217728: 0,
            402653184: 8421890,
            671088640: 33282,
            939524096: 32768,
            1207959552: 8421888,
            1476395008: 512,
            1744830464: 8421378,
            2013265920: 2,
            2281701376: 8389120,
            2550136832: 33280,
            2818572288: 8421376,
            3087007744: 8389122,
            3355443200: 8388610,
            3623878656: 32770,
            3892314112: 514,
            4160749568: 8388608,
            1: 32768,
            268435457: 2,
            536870913: 8421888,
            805306369: 8388608,
            1073741825: 8421378,
            1342177281: 33280,
            1610612737: 512,
            1879048193: 8389122,
            2147483649: 8421890,
            2415919105: 8421376,
            2684354561: 8388610,
            2952790017: 33282,
            3221225473: 514,
            3489660929: 8389120,
            3758096385: 32770,
            4026531841: 0,
            134217729: 8421890,
            402653185: 8421376,
            671088641: 8388608,
            939524097: 512,
            1207959553: 32768,
            1476395009: 8388610,
            1744830465: 2,
            2013265921: 33282,
            2281701377: 32770,
            2550136833: 8389122,
            2818572289: 514,
            3087007745: 8421888,
            3355443201: 8389120,
            3623878657: 0,
            3892314113: 33280,
            4160749569: 8421378
          },
          {
            0: 1074282512,
            16777216: 16384,
            33554432: 524288,
            50331648: 1074266128,
            67108864: 1073741840,
            83886080: 1074282496,
            100663296: 1073758208,
            117440512: 16,
            134217728: 540672,
            150994944: 1073758224,
            167772160: 1073741824,
            184549376: 540688,
            201326592: 524304,
            218103808: 0,
            234881024: 16400,
            251658240: 1074266112,
            8388608: 1073758208,
            25165824: 540688,
            41943040: 16,
            58720256: 1073758224,
            75497472: 1074282512,
            92274688: 1073741824,
            109051904: 524288,
            125829120: 1074266128,
            142606336: 524304,
            159383552: 0,
            176160768: 16384,
            192937984: 1074266112,
            209715200: 1073741840,
            226492416: 540672,
            243269632: 1074282496,
            260046848: 16400,
            268435456: 0,
            285212672: 1074266128,
            301989888: 1073758224,
            318767104: 1074282496,
            335544320: 1074266112,
            352321536: 16,
            369098752: 540688,
            385875968: 16384,
            402653184: 16400,
            419430400: 524288,
            436207616: 524304,
            452984832: 1073741840,
            469762048: 540672,
            486539264: 1073758208,
            503316480: 1073741824,
            520093696: 1074282512,
            276824064: 540688,
            293601280: 524288,
            310378496: 1074266112,
            327155712: 16384,
            343932928: 1073758208,
            360710144: 1074282512,
            377487360: 16,
            394264576: 1073741824,
            411041792: 1074282496,
            427819008: 1073741840,
            444596224: 1073758224,
            461373440: 524304,
            478150656: 0,
            494927872: 16400,
            511705088: 1074266128,
            528482304: 540672
          },
          {
            0: 260,
            1048576: 0,
            2097152: 67109120,
            3145728: 65796,
            4194304: 65540,
            5242880: 67108868,
            6291456: 67174660,
            7340032: 67174400,
            8388608: 67108864,
            9437184: 67174656,
            10485760: 65792,
            11534336: 67174404,
            12582912: 67109124,
            13631488: 65536,
            14680064: 4,
            15728640: 256,
            524288: 67174656,
            1572864: 67174404,
            2621440: 0,
            3670016: 67109120,
            4718592: 67108868,
            5767168: 65536,
            6815744: 65540,
            7864320: 260,
            8912896: 4,
            9961472: 256,
            11010048: 67174400,
            12058624: 65796,
            13107200: 65792,
            14155776: 67109124,
            15204352: 67174660,
            16252928: 67108864,
            16777216: 67174656,
            17825792: 65540,
            18874368: 65536,
            19922944: 67109120,
            20971520: 256,
            22020096: 67174660,
            23068672: 67108868,
            24117248: 0,
            25165824: 67109124,
            26214400: 67108864,
            27262976: 4,
            28311552: 65792,
            29360128: 67174400,
            30408704: 260,
            31457280: 65796,
            32505856: 67174404,
            17301504: 67108864,
            18350080: 260,
            19398656: 67174656,
            20447232: 0,
            21495808: 65540,
            22544384: 67109120,
            23592960: 256,
            24641536: 67174404,
            25690112: 65536,
            26738688: 67174660,
            27787264: 65796,
            28835840: 67108868,
            29884416: 67109124,
            30932992: 67174400,
            31981568: 4,
            33030144: 65792
          },
          {
            0: 2151682048,
            65536: 2147487808,
            131072: 4198464,
            196608: 2151677952,
            262144: 0,
            327680: 4198400,
            393216: 2147483712,
            458752: 4194368,
            524288: 2147483648,
            589824: 4194304,
            655360: 64,
            720896: 2147487744,
            786432: 2151678016,
            851968: 4160,
            917504: 4096,
            983040: 2151682112,
            32768: 2147487808,
            98304: 64,
            163840: 2151678016,
            229376: 2147487744,
            294912: 4198400,
            360448: 2151682112,
            425984: 0,
            491520: 2151677952,
            557056: 4096,
            622592: 2151682048,
            688128: 4194304,
            753664: 4160,
            819200: 2147483648,
            884736: 4194368,
            950272: 4198464,
            1015808: 2147483712,
            1048576: 4194368,
            1114112: 4198400,
            1179648: 2147483712,
            1245184: 0,
            1310720: 4160,
            1376256: 2151678016,
            1441792: 2151682048,
            1507328: 2147487808,
            1572864: 2151682112,
            1638400: 2147483648,
            1703936: 2151677952,
            1769472: 4198464,
            1835008: 2147487744,
            1900544: 4194304,
            1966080: 64,
            2031616: 4096,
            1081344: 2151677952,
            1146880: 2151682112,
            1212416: 0,
            1277952: 4198400,
            1343488: 4194368,
            1409024: 2147483648,
            1474560: 2147487808,
            1540096: 64,
            1605632: 2147483712,
            1671168: 4096,
            1736704: 2147487744,
            1802240: 2151678016,
            1867776: 4160,
            1933312: 2151682048,
            1998848: 4194304,
            2064384: 4198464
          },
          {
            0: 128,
            4096: 17039360,
            8192: 262144,
            12288: 536870912,
            16384: 537133184,
            20480: 16777344,
            24576: 553648256,
            28672: 262272,
            32768: 16777216,
            36864: 537133056,
            40960: 536871040,
            45056: 553910400,
            49152: 553910272,
            53248: 0,
            57344: 17039488,
            61440: 553648128,
            2048: 17039488,
            6144: 553648256,
            10240: 128,
            14336: 17039360,
            18432: 262144,
            22528: 537133184,
            26624: 553910272,
            30720: 536870912,
            34816: 537133056,
            38912: 0,
            43008: 553910400,
            47104: 16777344,
            51200: 536871040,
            55296: 553648128,
            59392: 16777216,
            63488: 262272,
            65536: 262144,
            69632: 128,
            73728: 536870912,
            77824: 553648256,
            81920: 16777344,
            86016: 553910272,
            90112: 537133184,
            94208: 16777216,
            98304: 553910400,
            102400: 553648128,
            106496: 17039360,
            110592: 537133056,
            114688: 262272,
            118784: 536871040,
            122880: 0,
            126976: 17039488,
            67584: 553648256,
            71680: 16777216,
            75776: 17039360,
            79872: 537133184,
            83968: 536870912,
            88064: 17039488,
            92160: 128,
            96256: 553910272,
            100352: 262272,
            104448: 553910400,
            108544: 0,
            112640: 553648128,
            116736: 16777344,
            120832: 262144,
            124928: 537133056,
            129024: 536871040
          },
          {
            0: 268435464,
            256: 8192,
            512: 270532608,
            768: 270540808,
            1024: 268443648,
            1280: 2097152,
            1536: 2097160,
            1792: 268435456,
            2048: 0,
            2304: 268443656,
            2560: 2105344,
            2816: 8,
            3072: 270532616,
            3328: 2105352,
            3584: 8200,
            3840: 270540800,
            128: 270532608,
            384: 270540808,
            640: 8,
            896: 2097152,
            1152: 2105352,
            1408: 268435464,
            1664: 268443648,
            1920: 8200,
            2176: 2097160,
            2432: 8192,
            2688: 268443656,
            2944: 270532616,
            3200: 0,
            3456: 270540800,
            3712: 2105344,
            3968: 268435456,
            4096: 268443648,
            4352: 270532616,
            4608: 270540808,
            4864: 8200,
            5120: 2097152,
            5376: 268435456,
            5632: 268435464,
            5888: 2105344,
            6144: 2105352,
            6400: 0,
            6656: 8,
            6912: 270532608,
            7168: 8192,
            7424: 268443656,
            7680: 270540800,
            7936: 2097160,
            4224: 8,
            4480: 2105344,
            4736: 2097152,
            4992: 268435464,
            5248: 268443648,
            5504: 8200,
            5760: 270540808,
            6016: 270532608,
            6272: 270540800,
            6528: 270532616,
            6784: 8192,
            7040: 2105352,
            7296: 2097160,
            7552: 0,
            7808: 268435456,
            8064: 268443656
          },
          {
            0: 1048576,
            16: 33555457,
            32: 1024,
            48: 1049601,
            64: 34604033,
            80: 0,
            96: 1,
            112: 34603009,
            128: 33555456,
            144: 1048577,
            160: 33554433,
            176: 34604032,
            192: 34603008,
            208: 1025,
            224: 1049600,
            240: 33554432,
            8: 34603009,
            24: 0,
            40: 33555457,
            56: 34604032,
            72: 1048576,
            88: 33554433,
            104: 33554432,
            120: 1025,
            136: 1049601,
            152: 33555456,
            168: 34603008,
            184: 1048577,
            200: 1024,
            216: 34604033,
            232: 1,
            248: 1049600,
            256: 33554432,
            272: 1048576,
            288: 33555457,
            304: 34603009,
            320: 1048577,
            336: 33555456,
            352: 34604032,
            368: 1049601,
            384: 1025,
            400: 34604033,
            416: 1049600,
            432: 1,
            448: 0,
            464: 34603008,
            480: 33554433,
            496: 1024,
            264: 1049600,
            280: 33555457,
            296: 34603009,
            312: 1,
            328: 33554432,
            344: 1048576,
            360: 1025,
            376: 34604032,
            392: 33554433,
            408: 34603008,
            424: 0,
            440: 34604033,
            456: 1049601,
            472: 1024,
            488: 33555456,
            504: 1048577
          },
          {
            0: 134219808,
            1: 131072,
            2: 134217728,
            3: 32,
            4: 131104,
            5: 134350880,
            6: 134350848,
            7: 2048,
            8: 134348800,
            9: 134219776,
            10: 133120,
            11: 134348832,
            12: 2080,
            13: 0,
            14: 134217760,
            15: 133152,
            2147483648: 2048,
            2147483649: 134350880,
            2147483650: 134219808,
            2147483651: 134217728,
            2147483652: 134348800,
            2147483653: 133120,
            2147483654: 133152,
            2147483655: 32,
            2147483656: 134217760,
            2147483657: 2080,
            2147483658: 131104,
            2147483659: 134350848,
            2147483660: 0,
            2147483661: 134348832,
            2147483662: 134219776,
            2147483663: 131072,
            16: 133152,
            17: 134350848,
            18: 32,
            19: 2048,
            20: 134219776,
            21: 134217760,
            22: 134348832,
            23: 131072,
            24: 0,
            25: 131104,
            26: 134348800,
            27: 134219808,
            28: 134350880,
            29: 133120,
            30: 2080,
            31: 134217728,
            2147483664: 131072,
            2147483665: 2048,
            2147483666: 134348832,
            2147483667: 133152,
            2147483668: 32,
            2147483669: 134348800,
            2147483670: 134217728,
            2147483671: 134219808,
            2147483672: 134350880,
            2147483673: 134217760,
            2147483674: 134219776,
            2147483675: 0,
            2147483676: 133120,
            2147483677: 2080,
            2147483678: 131104,
            2147483679: 134350848
          }
        ], d = [
          4160749569,
          528482304,
          33030144,
          2064384,
          129024,
          8064,
          504,
          2147483679
        ], h = o.DES = a.extend({
          _doReset: function() {
            for (var m = this._key, x = m.words, _ = [], y = 0; y < 56; y++) {
              var b = l[y] - 1;
              _[y] = x[b >>> 5] >>> 31 - b % 32 & 1;
            }
            for (var w = this._subKeys = [], E = 0; E < 16; E++) {
              for (var $ = w[E] = [], C = u[E], y = 0; y < 24; y++)
                $[y / 6 | 0] |= _[(c[y] - 1 + C) % 28] << 31 - y % 6, $[4 + (y / 6 | 0)] |= _[28 + (c[y + 24] - 1 + C) % 28] << 31 - y % 6;
              $[0] = $[0] << 1 | $[0] >>> 31;
              for (var y = 1; y < 7; y++)
                $[y] = $[y] >>> (y - 1) * 4 + 3;
              $[7] = $[7] << 5 | $[7] >>> 27;
            }
            for (var A = this._invSubKeys = [], y = 0; y < 16; y++)
              A[y] = w[15 - y];
          },
          encryptBlock: function(m, x) {
            this._doCryptBlock(m, x, this._subKeys);
          },
          decryptBlock: function(m, x) {
            this._doCryptBlock(m, x, this._invSubKeys);
          },
          _doCryptBlock: function(m, x, _) {
            this._lBlock = m[x], this._rBlock = m[x + 1], p.call(this, 4, 252645135), p.call(this, 16, 65535), g.call(this, 2, 858993459), g.call(this, 8, 16711935), p.call(this, 1, 1431655765);
            for (var y = 0; y < 16; y++) {
              for (var b = _[y], w = this._lBlock, E = this._rBlock, $ = 0, C = 0; C < 8; C++)
                $ |= f[C][((E ^ b[C]) & d[C]) >>> 0];
              this._lBlock = E, this._rBlock = w ^ $;
            }
            var A = this._lBlock;
            this._lBlock = this._rBlock, this._rBlock = A, p.call(this, 1, 1431655765), g.call(this, 8, 16711935), g.call(this, 2, 858993459), p.call(this, 16, 65535), p.call(this, 4, 252645135), m[x] = this._lBlock, m[x + 1] = this._rBlock;
          },
          keySize: 64 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        function p(m, x) {
          var _ = (this._lBlock >>> m ^ this._rBlock) & x;
          this._rBlock ^= _, this._lBlock ^= _ << m;
        }
        function g(m, x) {
          var _ = (this._rBlock >>> m ^ this._lBlock) & x;
          this._lBlock ^= _, this._rBlock ^= _ << m;
        }
        r.DES = a._createHelper(h);
        var v = o.TripleDES = a.extend({
          _doReset: function() {
            var m = this._key, x = m.words;
            if (x.length !== 2 && x.length !== 4 && x.length < 6)
              throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
            var _ = x.slice(0, 2), y = x.length < 4 ? x.slice(0, 2) : x.slice(2, 4), b = x.length < 6 ? x.slice(0, 2) : x.slice(4, 6);
            this._des1 = h.createEncryptor(s.create(_)), this._des2 = h.createEncryptor(s.create(y)), this._des3 = h.createEncryptor(s.create(b));
          },
          encryptBlock: function(m, x) {
            this._des1.encryptBlock(m, x), this._des2.decryptBlock(m, x), this._des3.encryptBlock(m, x);
          },
          decryptBlock: function(m, x) {
            this._des3.decryptBlock(m, x), this._des2.encryptBlock(m, x), this._des1.decryptBlock(m, x);
          },
          keySize: 192 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        r.TripleDES = a._createHelper(v);
      }(), n.TripleDES;
    });
  }(rd)), rd.exports;
}
var id = { exports: {} }, Gx;
function oQ() {
  return Gx || (Gx = 1, function(e, t) {
    (function(n, r, i) {
      e.exports = r(Se(), Bi(), Ni(), Wr(), St());
    })(ye, function(n) {
      return function() {
        var r = n, i = r.lib, s = i.StreamCipher, a = r.algo, o = a.RC4 = s.extend({
          _doReset: function() {
            for (var u = this._key, f = u.words, d = u.sigBytes, h = this._S = [], p = 0; p < 256; p++)
              h[p] = p;
            for (var p = 0, g = 0; p < 256; p++) {
              var v = p % d, m = f[v >>> 2] >>> 24 - v % 4 * 8 & 255;
              g = (g + h[p] + m) % 256;
              var x = h[p];
              h[p] = h[g], h[g] = x;
            }
            this._i = this._j = 0;
          },
          _doProcessBlock: function(u, f) {
            u[f] ^= l.call(this);
          },
          keySize: 256 / 32,
          ivSize: 0
        });
        function l() {
          for (var u = this._S, f = this._i, d = this._j, h = 0, p = 0; p < 4; p++) {
            f = (f + 1) % 256, d = (d + u[f]) % 256;
            var g = u[f];
            u[f] = u[d], u[d] = g, h |= u[(u[f] + u[d]) % 256] << 24 - p * 8;
          }
          return this._i = f, this._j = d, h;
        }
        r.RC4 = s._createHelper(o);
        var c = a.RC4Drop = o.extend({
          /**
           * Configuration options.
           *
           * @property {number} drop The number of keystream words to drop. Default 192
           */
          cfg: o.cfg.extend({
            drop: 192
          }),
          _doReset: function() {
            o._doReset.call(this);
            for (var u = this.cfg.drop; u > 0; u--)
              l.call(this);
          }
        });
        r.RC4Drop = s._createHelper(c);
      }(), n.RC4;
    });
  }(id)), id.exports;
}
var sd = { exports: {} }, Xx;
function lQ() {
  return Xx || (Xx = 1, function(e, t) {
    (function(n, r, i) {
      e.exports = r(Se(), Bi(), Ni(), Wr(), St());
    })(ye, function(n) {
      return function() {
        var r = n, i = r.lib, s = i.StreamCipher, a = r.algo, o = [], l = [], c = [], u = a.Rabbit = s.extend({
          _doReset: function() {
            for (var d = this._key.words, h = this.cfg.iv, p = 0; p < 4; p++)
              d[p] = (d[p] << 8 | d[p] >>> 24) & 16711935 | (d[p] << 24 | d[p] >>> 8) & 4278255360;
            var g = this._X = [
              d[0],
              d[3] << 16 | d[2] >>> 16,
              d[1],
              d[0] << 16 | d[3] >>> 16,
              d[2],
              d[1] << 16 | d[0] >>> 16,
              d[3],
              d[2] << 16 | d[1] >>> 16
            ], v = this._C = [
              d[2] << 16 | d[2] >>> 16,
              d[0] & 4294901760 | d[1] & 65535,
              d[3] << 16 | d[3] >>> 16,
              d[1] & 4294901760 | d[2] & 65535,
              d[0] << 16 | d[0] >>> 16,
              d[2] & 4294901760 | d[3] & 65535,
              d[1] << 16 | d[1] >>> 16,
              d[3] & 4294901760 | d[0] & 65535
            ];
            this._b = 0;
            for (var p = 0; p < 4; p++)
              f.call(this);
            for (var p = 0; p < 8; p++)
              v[p] ^= g[p + 4 & 7];
            if (h) {
              var m = h.words, x = m[0], _ = m[1], y = (x << 8 | x >>> 24) & 16711935 | (x << 24 | x >>> 8) & 4278255360, b = (_ << 8 | _ >>> 24) & 16711935 | (_ << 24 | _ >>> 8) & 4278255360, w = y >>> 16 | b & 4294901760, E = b << 16 | y & 65535;
              v[0] ^= y, v[1] ^= w, v[2] ^= b, v[3] ^= E, v[4] ^= y, v[5] ^= w, v[6] ^= b, v[7] ^= E;
              for (var p = 0; p < 4; p++)
                f.call(this);
            }
          },
          _doProcessBlock: function(d, h) {
            var p = this._X;
            f.call(this), o[0] = p[0] ^ p[5] >>> 16 ^ p[3] << 16, o[1] = p[2] ^ p[7] >>> 16 ^ p[5] << 16, o[2] = p[4] ^ p[1] >>> 16 ^ p[7] << 16, o[3] = p[6] ^ p[3] >>> 16 ^ p[1] << 16;
            for (var g = 0; g < 4; g++)
              o[g] = (o[g] << 8 | o[g] >>> 24) & 16711935 | (o[g] << 24 | o[g] >>> 8) & 4278255360, d[h + g] ^= o[g];
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function f() {
          for (var d = this._X, h = this._C, p = 0; p < 8; p++)
            l[p] = h[p];
          h[0] = h[0] + 1295307597 + this._b | 0, h[1] = h[1] + 3545052371 + (h[0] >>> 0 < l[0] >>> 0 ? 1 : 0) | 0, h[2] = h[2] + 886263092 + (h[1] >>> 0 < l[1] >>> 0 ? 1 : 0) | 0, h[3] = h[3] + 1295307597 + (h[2] >>> 0 < l[2] >>> 0 ? 1 : 0) | 0, h[4] = h[4] + 3545052371 + (h[3] >>> 0 < l[3] >>> 0 ? 1 : 0) | 0, h[5] = h[5] + 886263092 + (h[4] >>> 0 < l[4] >>> 0 ? 1 : 0) | 0, h[6] = h[6] + 1295307597 + (h[5] >>> 0 < l[5] >>> 0 ? 1 : 0) | 0, h[7] = h[7] + 3545052371 + (h[6] >>> 0 < l[6] >>> 0 ? 1 : 0) | 0, this._b = h[7] >>> 0 < l[7] >>> 0 ? 1 : 0;
          for (var p = 0; p < 8; p++) {
            var g = d[p] + h[p], v = g & 65535, m = g >>> 16, x = ((v * v >>> 17) + v * m >>> 15) + m * m, _ = ((g & 4294901760) * g | 0) + ((g & 65535) * g | 0);
            c[p] = x ^ _;
          }
          d[0] = c[0] + (c[7] << 16 | c[7] >>> 16) + (c[6] << 16 | c[6] >>> 16) | 0, d[1] = c[1] + (c[0] << 8 | c[0] >>> 24) + c[7] | 0, d[2] = c[2] + (c[1] << 16 | c[1] >>> 16) + (c[0] << 16 | c[0] >>> 16) | 0, d[3] = c[3] + (c[2] << 8 | c[2] >>> 24) + c[1] | 0, d[4] = c[4] + (c[3] << 16 | c[3] >>> 16) + (c[2] << 16 | c[2] >>> 16) | 0, d[5] = c[5] + (c[4] << 8 | c[4] >>> 24) + c[3] | 0, d[6] = c[6] + (c[5] << 16 | c[5] >>> 16) + (c[4] << 16 | c[4] >>> 16) | 0, d[7] = c[7] + (c[6] << 8 | c[6] >>> 24) + c[5] | 0;
        }
        r.Rabbit = s._createHelper(u);
      }(), n.Rabbit;
    });
  }(sd)), sd.exports;
}
var ad = { exports: {} }, Zx;
function cQ() {
  return Zx || (Zx = 1, function(e, t) {
    (function(n, r, i) {
      e.exports = r(Se(), Bi(), Ni(), Wr(), St());
    })(ye, function(n) {
      return function() {
        var r = n, i = r.lib, s = i.StreamCipher, a = r.algo, o = [], l = [], c = [], u = a.RabbitLegacy = s.extend({
          _doReset: function() {
            var d = this._key.words, h = this.cfg.iv, p = this._X = [
              d[0],
              d[3] << 16 | d[2] >>> 16,
              d[1],
              d[0] << 16 | d[3] >>> 16,
              d[2],
              d[1] << 16 | d[0] >>> 16,
              d[3],
              d[2] << 16 | d[1] >>> 16
            ], g = this._C = [
              d[2] << 16 | d[2] >>> 16,
              d[0] & 4294901760 | d[1] & 65535,
              d[3] << 16 | d[3] >>> 16,
              d[1] & 4294901760 | d[2] & 65535,
              d[0] << 16 | d[0] >>> 16,
              d[2] & 4294901760 | d[3] & 65535,
              d[1] << 16 | d[1] >>> 16,
              d[3] & 4294901760 | d[0] & 65535
            ];
            this._b = 0;
            for (var v = 0; v < 4; v++)
              f.call(this);
            for (var v = 0; v < 8; v++)
              g[v] ^= p[v + 4 & 7];
            if (h) {
              var m = h.words, x = m[0], _ = m[1], y = (x << 8 | x >>> 24) & 16711935 | (x << 24 | x >>> 8) & 4278255360, b = (_ << 8 | _ >>> 24) & 16711935 | (_ << 24 | _ >>> 8) & 4278255360, w = y >>> 16 | b & 4294901760, E = b << 16 | y & 65535;
              g[0] ^= y, g[1] ^= w, g[2] ^= b, g[3] ^= E, g[4] ^= y, g[5] ^= w, g[6] ^= b, g[7] ^= E;
              for (var v = 0; v < 4; v++)
                f.call(this);
            }
          },
          _doProcessBlock: function(d, h) {
            var p = this._X;
            f.call(this), o[0] = p[0] ^ p[5] >>> 16 ^ p[3] << 16, o[1] = p[2] ^ p[7] >>> 16 ^ p[5] << 16, o[2] = p[4] ^ p[1] >>> 16 ^ p[7] << 16, o[3] = p[6] ^ p[3] >>> 16 ^ p[1] << 16;
            for (var g = 0; g < 4; g++)
              o[g] = (o[g] << 8 | o[g] >>> 24) & 16711935 | (o[g] << 24 | o[g] >>> 8) & 4278255360, d[h + g] ^= o[g];
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function f() {
          for (var d = this._X, h = this._C, p = 0; p < 8; p++)
            l[p] = h[p];
          h[0] = h[0] + 1295307597 + this._b | 0, h[1] = h[1] + 3545052371 + (h[0] >>> 0 < l[0] >>> 0 ? 1 : 0) | 0, h[2] = h[2] + 886263092 + (h[1] >>> 0 < l[1] >>> 0 ? 1 : 0) | 0, h[3] = h[3] + 1295307597 + (h[2] >>> 0 < l[2] >>> 0 ? 1 : 0) | 0, h[4] = h[4] + 3545052371 + (h[3] >>> 0 < l[3] >>> 0 ? 1 : 0) | 0, h[5] = h[5] + 886263092 + (h[4] >>> 0 < l[4] >>> 0 ? 1 : 0) | 0, h[6] = h[6] + 1295307597 + (h[5] >>> 0 < l[5] >>> 0 ? 1 : 0) | 0, h[7] = h[7] + 3545052371 + (h[6] >>> 0 < l[6] >>> 0 ? 1 : 0) | 0, this._b = h[7] >>> 0 < l[7] >>> 0 ? 1 : 0;
          for (var p = 0; p < 8; p++) {
            var g = d[p] + h[p], v = g & 65535, m = g >>> 16, x = ((v * v >>> 17) + v * m >>> 15) + m * m, _ = ((g & 4294901760) * g | 0) + ((g & 65535) * g | 0);
            c[p] = x ^ _;
          }
          d[0] = c[0] + (c[7] << 16 | c[7] >>> 16) + (c[6] << 16 | c[6] >>> 16) | 0, d[1] = c[1] + (c[0] << 8 | c[0] >>> 24) + c[7] | 0, d[2] = c[2] + (c[1] << 16 | c[1] >>> 16) + (c[0] << 16 | c[0] >>> 16) | 0, d[3] = c[3] + (c[2] << 8 | c[2] >>> 24) + c[1] | 0, d[4] = c[4] + (c[3] << 16 | c[3] >>> 16) + (c[2] << 16 | c[2] >>> 16) | 0, d[5] = c[5] + (c[4] << 8 | c[4] >>> 24) + c[3] | 0, d[6] = c[6] + (c[5] << 16 | c[5] >>> 16) + (c[4] << 16 | c[4] >>> 16) | 0, d[7] = c[7] + (c[6] << 8 | c[6] >>> 24) + c[5] | 0;
        }
        r.RabbitLegacy = s._createHelper(u);
      }(), n.RabbitLegacy;
    });
  }(ad)), ad.exports;
}
var od = { exports: {} }, Kx;
function uQ() {
  return Kx || (Kx = 1, function(e, t) {
    (function(n, r, i) {
      e.exports = r(Se(), Bi(), Ni(), Wr(), St());
    })(ye, function(n) {
      return function() {
        var r = n, i = r.lib, s = i.BlockCipher, a = r.algo;
        const o = 16, l = [
          608135816,
          2242054355,
          320440878,
          57701188,
          2752067618,
          698298832,
          137296536,
          3964562569,
          1160258022,
          953160567,
          3193202383,
          887688300,
          3232508343,
          3380367581,
          1065670069,
          3041331479,
          2450970073,
          2306472731
        ], c = [
          [
            3509652390,
            2564797868,
            805139163,
            3491422135,
            3101798381,
            1780907670,
            3128725573,
            4046225305,
            614570311,
            3012652279,
            134345442,
            2240740374,
            1667834072,
            1901547113,
            2757295779,
            4103290238,
            227898511,
            1921955416,
            1904987480,
            2182433518,
            2069144605,
            3260701109,
            2620446009,
            720527379,
            3318853667,
            677414384,
            3393288472,
            3101374703,
            2390351024,
            1614419982,
            1822297739,
            2954791486,
            3608508353,
            3174124327,
            2024746970,
            1432378464,
            3864339955,
            2857741204,
            1464375394,
            1676153920,
            1439316330,
            715854006,
            3033291828,
            289532110,
            2706671279,
            2087905683,
            3018724369,
            1668267050,
            732546397,
            1947742710,
            3462151702,
            2609353502,
            2950085171,
            1814351708,
            2050118529,
            680887927,
            999245976,
            1800124847,
            3300911131,
            1713906067,
            1641548236,
            4213287313,
            1216130144,
            1575780402,
            4018429277,
            3917837745,
            3693486850,
            3949271944,
            596196993,
            3549867205,
            258830323,
            2213823033,
            772490370,
            2760122372,
            1774776394,
            2652871518,
            566650946,
            4142492826,
            1728879713,
            2882767088,
            1783734482,
            3629395816,
            2517608232,
            2874225571,
            1861159788,
            326777828,
            3124490320,
            2130389656,
            2716951837,
            967770486,
            1724537150,
            2185432712,
            2364442137,
            1164943284,
            2105845187,
            998989502,
            3765401048,
            2244026483,
            1075463327,
            1455516326,
            1322494562,
            910128902,
            469688178,
            1117454909,
            936433444,
            3490320968,
            3675253459,
            1240580251,
            122909385,
            2157517691,
            634681816,
            4142456567,
            3825094682,
            3061402683,
            2540495037,
            79693498,
            3249098678,
            1084186820,
            1583128258,
            426386531,
            1761308591,
            1047286709,
            322548459,
            995290223,
            1845252383,
            2603652396,
            3431023940,
            2942221577,
            3202600964,
            3727903485,
            1712269319,
            422464435,
            3234572375,
            1170764815,
            3523960633,
            3117677531,
            1434042557,
            442511882,
            3600875718,
            1076654713,
            1738483198,
            4213154764,
            2393238008,
            3677496056,
            1014306527,
            4251020053,
            793779912,
            2902807211,
            842905082,
            4246964064,
            1395751752,
            1040244610,
            2656851899,
            3396308128,
            445077038,
            3742853595,
            3577915638,
            679411651,
            2892444358,
            2354009459,
            1767581616,
            3150600392,
            3791627101,
            3102740896,
            284835224,
            4246832056,
            1258075500,
            768725851,
            2589189241,
            3069724005,
            3532540348,
            1274779536,
            3789419226,
            2764799539,
            1660621633,
            3471099624,
            4011903706,
            913787905,
            3497959166,
            737222580,
            2514213453,
            2928710040,
            3937242737,
            1804850592,
            3499020752,
            2949064160,
            2386320175,
            2390070455,
            2415321851,
            4061277028,
            2290661394,
            2416832540,
            1336762016,
            1754252060,
            3520065937,
            3014181293,
            791618072,
            3188594551,
            3933548030,
            2332172193,
            3852520463,
            3043980520,
            413987798,
            3465142937,
            3030929376,
            4245938359,
            2093235073,
            3534596313,
            375366246,
            2157278981,
            2479649556,
            555357303,
            3870105701,
            2008414854,
            3344188149,
            4221384143,
            3956125452,
            2067696032,
            3594591187,
            2921233993,
            2428461,
            544322398,
            577241275,
            1471733935,
            610547355,
            4027169054,
            1432588573,
            1507829418,
            2025931657,
            3646575487,
            545086370,
            48609733,
            2200306550,
            1653985193,
            298326376,
            1316178497,
            3007786442,
            2064951626,
            458293330,
            2589141269,
            3591329599,
            3164325604,
            727753846,
            2179363840,
            146436021,
            1461446943,
            4069977195,
            705550613,
            3059967265,
            3887724982,
            4281599278,
            3313849956,
            1404054877,
            2845806497,
            146425753,
            1854211946
          ],
          [
            1266315497,
            3048417604,
            3681880366,
            3289982499,
            290971e4,
            1235738493,
            2632868024,
            2414719590,
            3970600049,
            1771706367,
            1449415276,
            3266420449,
            422970021,
            1963543593,
            2690192192,
            3826793022,
            1062508698,
            1531092325,
            1804592342,
            2583117782,
            2714934279,
            4024971509,
            1294809318,
            4028980673,
            1289560198,
            2221992742,
            1669523910,
            35572830,
            157838143,
            1052438473,
            1016535060,
            1802137761,
            1753167236,
            1386275462,
            3080475397,
            2857371447,
            1040679964,
            2145300060,
            2390574316,
            1461121720,
            2956646967,
            4031777805,
            4028374788,
            33600511,
            2920084762,
            1018524850,
            629373528,
            3691585981,
            3515945977,
            2091462646,
            2486323059,
            586499841,
            988145025,
            935516892,
            3367335476,
            2599673255,
            2839830854,
            265290510,
            3972581182,
            2759138881,
            3795373465,
            1005194799,
            847297441,
            406762289,
            1314163512,
            1332590856,
            1866599683,
            4127851711,
            750260880,
            613907577,
            1450815602,
            3165620655,
            3734664991,
            3650291728,
            3012275730,
            3704569646,
            1427272223,
            778793252,
            1343938022,
            2676280711,
            2052605720,
            1946737175,
            3164576444,
            3914038668,
            3967478842,
            3682934266,
            1661551462,
            3294938066,
            4011595847,
            840292616,
            3712170807,
            616741398,
            312560963,
            711312465,
            1351876610,
            322626781,
            1910503582,
            271666773,
            2175563734,
            1594956187,
            70604529,
            3617834859,
            1007753275,
            1495573769,
            4069517037,
            2549218298,
            2663038764,
            504708206,
            2263041392,
            3941167025,
            2249088522,
            1514023603,
            1998579484,
            1312622330,
            694541497,
            2582060303,
            2151582166,
            1382467621,
            776784248,
            2618340202,
            3323268794,
            2497899128,
            2784771155,
            503983604,
            4076293799,
            907881277,
            423175695,
            432175456,
            1378068232,
            4145222326,
            3954048622,
            3938656102,
            3820766613,
            2793130115,
            2977904593,
            26017576,
            3274890735,
            3194772133,
            1700274565,
            1756076034,
            4006520079,
            3677328699,
            720338349,
            1533947780,
            354530856,
            688349552,
            3973924725,
            1637815568,
            332179504,
            3949051286,
            53804574,
            2852348879,
            3044236432,
            1282449977,
            3583942155,
            3416972820,
            4006381244,
            1617046695,
            2628476075,
            3002303598,
            1686838959,
            431878346,
            2686675385,
            1700445008,
            1080580658,
            1009431731,
            832498133,
            3223435511,
            2605976345,
            2271191193,
            2516031870,
            1648197032,
            4164389018,
            2548247927,
            300782431,
            375919233,
            238389289,
            3353747414,
            2531188641,
            2019080857,
            1475708069,
            455242339,
            2609103871,
            448939670,
            3451063019,
            1395535956,
            2413381860,
            1841049896,
            1491858159,
            885456874,
            4264095073,
            4001119347,
            1565136089,
            3898914787,
            1108368660,
            540939232,
            1173283510,
            2745871338,
            3681308437,
            4207628240,
            3343053890,
            4016749493,
            1699691293,
            1103962373,
            3625875870,
            2256883143,
            3830138730,
            1031889488,
            3479347698,
            1535977030,
            4236805024,
            3251091107,
            2132092099,
            1774941330,
            1199868427,
            1452454533,
            157007616,
            2904115357,
            342012276,
            595725824,
            1480756522,
            206960106,
            497939518,
            591360097,
            863170706,
            2375253569,
            3596610801,
            1814182875,
            2094937945,
            3421402208,
            1082520231,
            3463918190,
            2785509508,
            435703966,
            3908032597,
            1641649973,
            2842273706,
            3305899714,
            1510255612,
            2148256476,
            2655287854,
            3276092548,
            4258621189,
            236887753,
            3681803219,
            274041037,
            1734335097,
            3815195456,
            3317970021,
            1899903192,
            1026095262,
            4050517792,
            356393447,
            2410691914,
            3873677099,
            3682840055
          ],
          [
            3913112168,
            2491498743,
            4132185628,
            2489919796,
            1091903735,
            1979897079,
            3170134830,
            3567386728,
            3557303409,
            857797738,
            1136121015,
            1342202287,
            507115054,
            2535736646,
            337727348,
            3213592640,
            1301675037,
            2528481711,
            1895095763,
            1721773893,
            3216771564,
            62756741,
            2142006736,
            835421444,
            2531993523,
            1442658625,
            3659876326,
            2882144922,
            676362277,
            1392781812,
            170690266,
            3921047035,
            1759253602,
            3611846912,
            1745797284,
            664899054,
            1329594018,
            3901205900,
            3045908486,
            2062866102,
            2865634940,
            3543621612,
            3464012697,
            1080764994,
            553557557,
            3656615353,
            3996768171,
            991055499,
            499776247,
            1265440854,
            648242737,
            3940784050,
            980351604,
            3713745714,
            1749149687,
            3396870395,
            4211799374,
            3640570775,
            1161844396,
            3125318951,
            1431517754,
            545492359,
            4268468663,
            3499529547,
            1437099964,
            2702547544,
            3433638243,
            2581715763,
            2787789398,
            1060185593,
            1593081372,
            2418618748,
            4260947970,
            69676912,
            2159744348,
            86519011,
            2512459080,
            3838209314,
            1220612927,
            3339683548,
            133810670,
            1090789135,
            1078426020,
            1569222167,
            845107691,
            3583754449,
            4072456591,
            1091646820,
            628848692,
            1613405280,
            3757631651,
            526609435,
            236106946,
            48312990,
            2942717905,
            3402727701,
            1797494240,
            859738849,
            992217954,
            4005476642,
            2243076622,
            3870952857,
            3732016268,
            765654824,
            3490871365,
            2511836413,
            1685915746,
            3888969200,
            1414112111,
            2273134842,
            3281911079,
            4080962846,
            172450625,
            2569994100,
            980381355,
            4109958455,
            2819808352,
            2716589560,
            2568741196,
            3681446669,
            3329971472,
            1835478071,
            660984891,
            3704678404,
            4045999559,
            3422617507,
            3040415634,
            1762651403,
            1719377915,
            3470491036,
            2693910283,
            3642056355,
            3138596744,
            1364962596,
            2073328063,
            1983633131,
            926494387,
            3423689081,
            2150032023,
            4096667949,
            1749200295,
            3328846651,
            309677260,
            2016342300,
            1779581495,
            3079819751,
            111262694,
            1274766160,
            443224088,
            298511866,
            1025883608,
            3806446537,
            1145181785,
            168956806,
            3641502830,
            3584813610,
            1689216846,
            3666258015,
            3200248200,
            1692713982,
            2646376535,
            4042768518,
            1618508792,
            1610833997,
            3523052358,
            4130873264,
            2001055236,
            3610705100,
            2202168115,
            4028541809,
            2961195399,
            1006657119,
            2006996926,
            3186142756,
            1430667929,
            3210227297,
            1314452623,
            4074634658,
            4101304120,
            2273951170,
            1399257539,
            3367210612,
            3027628629,
            1190975929,
            2062231137,
            2333990788,
            2221543033,
            2438960610,
            1181637006,
            548689776,
            2362791313,
            3372408396,
            3104550113,
            3145860560,
            296247880,
            1970579870,
            3078560182,
            3769228297,
            1714227617,
            3291629107,
            3898220290,
            166772364,
            1251581989,
            493813264,
            448347421,
            195405023,
            2709975567,
            677966185,
            3703036547,
            1463355134,
            2715995803,
            1338867538,
            1343315457,
            2802222074,
            2684532164,
            233230375,
            2599980071,
            2000651841,
            3277868038,
            1638401717,
            4028070440,
            3237316320,
            6314154,
            819756386,
            300326615,
            590932579,
            1405279636,
            3267499572,
            3150704214,
            2428286686,
            3959192993,
            3461946742,
            1862657033,
            1266418056,
            963775037,
            2089974820,
            2263052895,
            1917689273,
            448879540,
            3550394620,
            3981727096,
            150775221,
            3627908307,
            1303187396,
            508620638,
            2975983352,
            2726630617,
            1817252668,
            1876281319,
            1457606340,
            908771278,
            3720792119,
            3617206836,
            2455994898,
            1729034894,
            1080033504
          ],
          [
            976866871,
            3556439503,
            2881648439,
            1522871579,
            1555064734,
            1336096578,
            3548522304,
            2579274686,
            3574697629,
            3205460757,
            3593280638,
            3338716283,
            3079412587,
            564236357,
            2993598910,
            1781952180,
            1464380207,
            3163844217,
            3332601554,
            1699332808,
            1393555694,
            1183702653,
            3581086237,
            1288719814,
            691649499,
            2847557200,
            2895455976,
            3193889540,
            2717570544,
            1781354906,
            1676643554,
            2592534050,
            3230253752,
            1126444790,
            2770207658,
            2633158820,
            2210423226,
            2615765581,
            2414155088,
            3127139286,
            673620729,
            2805611233,
            1269405062,
            4015350505,
            3341807571,
            4149409754,
            1057255273,
            2012875353,
            2162469141,
            2276492801,
            2601117357,
            993977747,
            3918593370,
            2654263191,
            753973209,
            36408145,
            2530585658,
            25011837,
            3520020182,
            2088578344,
            530523599,
            2918365339,
            1524020338,
            1518925132,
            3760827505,
            3759777254,
            1202760957,
            3985898139,
            3906192525,
            674977740,
            4174734889,
            2031300136,
            2019492241,
            3983892565,
            4153806404,
            3822280332,
            352677332,
            2297720250,
            60907813,
            90501309,
            3286998549,
            1016092578,
            2535922412,
            2839152426,
            457141659,
            509813237,
            4120667899,
            652014361,
            1966332200,
            2975202805,
            55981186,
            2327461051,
            676427537,
            3255491064,
            2882294119,
            3433927263,
            1307055953,
            942726286,
            933058658,
            2468411793,
            3933900994,
            4215176142,
            1361170020,
            2001714738,
            2830558078,
            3274259782,
            1222529897,
            1679025792,
            2729314320,
            3714953764,
            1770335741,
            151462246,
            3013232138,
            1682292957,
            1483529935,
            471910574,
            1539241949,
            458788160,
            3436315007,
            1807016891,
            3718408830,
            978976581,
            1043663428,
            3165965781,
            1927990952,
            4200891579,
            2372276910,
            3208408903,
            3533431907,
            1412390302,
            2931980059,
            4132332400,
            1947078029,
            3881505623,
            4168226417,
            2941484381,
            1077988104,
            1320477388,
            886195818,
            18198404,
            3786409e3,
            2509781533,
            112762804,
            3463356488,
            1866414978,
            891333506,
            18488651,
            661792760,
            1628790961,
            3885187036,
            3141171499,
            876946877,
            2693282273,
            1372485963,
            791857591,
            2686433993,
            3759982718,
            3167212022,
            3472953795,
            2716379847,
            445679433,
            3561995674,
            3504004811,
            3574258232,
            54117162,
            3331405415,
            2381918588,
            3769707343,
            4154350007,
            1140177722,
            4074052095,
            668550556,
            3214352940,
            367459370,
            261225585,
            2610173221,
            4209349473,
            3468074219,
            3265815641,
            314222801,
            3066103646,
            3808782860,
            282218597,
            3406013506,
            3773591054,
            379116347,
            1285071038,
            846784868,
            2669647154,
            3771962079,
            3550491691,
            2305946142,
            453669953,
            1268987020,
            3317592352,
            3279303384,
            3744833421,
            2610507566,
            3859509063,
            266596637,
            3847019092,
            517658769,
            3462560207,
            3443424879,
            370717030,
            4247526661,
            2224018117,
            4143653529,
            4112773975,
            2788324899,
            2477274417,
            1456262402,
            2901442914,
            1517677493,
            1846949527,
            2295493580,
            3734397586,
            2176403920,
            1280348187,
            1908823572,
            3871786941,
            846861322,
            1172426758,
            3287448474,
            3383383037,
            1655181056,
            3139813346,
            901632758,
            1897031941,
            2986607138,
            3066810236,
            3447102507,
            1393639104,
            373351379,
            950779232,
            625454576,
            3124240540,
            4148612726,
            2007998917,
            544563296,
            2244738638,
            2330496472,
            2058025392,
            1291430526,
            424198748,
            50039436,
            29584100,
            3605783033,
            2429876329,
            2791104160,
            1057563949,
            3255363231,
            3075367218,
            3463963227,
            1469046755,
            985887462
          ]
        ];
        var u = {
          pbox: [],
          sbox: []
        };
        function f(v, m) {
          let x = m >> 24 & 255, _ = m >> 16 & 255, y = m >> 8 & 255, b = m & 255, w = v.sbox[0][x] + v.sbox[1][_];
          return w = w ^ v.sbox[2][y], w = w + v.sbox[3][b], w;
        }
        function d(v, m, x) {
          let _ = m, y = x, b;
          for (let w = 0; w < o; ++w)
            _ = _ ^ v.pbox[w], y = f(v, _) ^ y, b = _, _ = y, y = b;
          return b = _, _ = y, y = b, y = y ^ v.pbox[o], _ = _ ^ v.pbox[o + 1], { left: _, right: y };
        }
        function h(v, m, x) {
          let _ = m, y = x, b;
          for (let w = o + 1; w > 1; --w)
            _ = _ ^ v.pbox[w], y = f(v, _) ^ y, b = _, _ = y, y = b;
          return b = _, _ = y, y = b, y = y ^ v.pbox[1], _ = _ ^ v.pbox[0], { left: _, right: y };
        }
        function p(v, m, x) {
          for (let E = 0; E < 4; E++) {
            v.sbox[E] = [];
            for (let $ = 0; $ < 256; $++)
              v.sbox[E][$] = c[E][$];
          }
          let _ = 0;
          for (let E = 0; E < o + 2; E++)
            v.pbox[E] = l[E] ^ m[_], _++, _ >= x && (_ = 0);
          let y = 0, b = 0, w = 0;
          for (let E = 0; E < o + 2; E += 2)
            w = d(v, y, b), y = w.left, b = w.right, v.pbox[E] = y, v.pbox[E + 1] = b;
          for (let E = 0; E < 4; E++)
            for (let $ = 0; $ < 256; $ += 2)
              w = d(v, y, b), y = w.left, b = w.right, v.sbox[E][$] = y, v.sbox[E][$ + 1] = b;
          return !0;
        }
        var g = a.Blowfish = s.extend({
          _doReset: function() {
            if (this._keyPriorReset !== this._key) {
              var v = this._keyPriorReset = this._key, m = v.words, x = v.sigBytes / 4;
              p(u, m, x);
            }
          },
          encryptBlock: function(v, m) {
            var x = d(u, v[m], v[m + 1]);
            v[m] = x.left, v[m + 1] = x.right;
          },
          decryptBlock: function(v, m) {
            var x = h(u, v[m], v[m + 1]);
            v[m] = x.left, v[m + 1] = x.right;
          },
          blockSize: 64 / 32,
          keySize: 128 / 32,
          ivSize: 64 / 32
        });
        r.Blowfish = s._createHelper(g);
      }(), n.Blowfish;
    });
  }(od)), od.exports;
}
(function(e, t) {
  (function(n, r, i) {
    e.exports = r(Se(), Su(), jJ(), zJ(), Bi(), VJ(), Ni(), tE(), gp(), HJ(), nE(), WJ(), UJ(), YJ(), vp(), qJ(), Wr(), St(), GJ(), XJ(), ZJ(), KJ(), JJ(), QJ(), eQ(), tQ(), nQ(), rQ(), iQ(), sQ(), aQ(), oQ(), lQ(), cQ(), uQ());
  })(ye, function(n) {
    return n;
  });
})(eE);
var Gn = eE.exports;
const fQ = yn.checkout("CryptoAES");
class ho {
  static decrypt(t, n, r) {
    if (t === "php-encryption") {
      let { iv: i, value: s } = JSON.parse(Gn.enc.Base64.parse(n).toString(Gn.enc.Utf8)), a = Gn.enc.Base64.parse(i), o = Gn.enc.Utf8.parse(r);
      return Gn.AES.decrypt(s, o, { iv: a }).toString(Gn.enc.Utf8);
    } else
      return Gn.AES.decrypt(n, r).toString(Gn.enc.Utf8);
  }
  static encrypt(t, n, r) {
    if (t === "php-encryption")
      throw fQ.create("CryptoAES encrypt not support php-encryption");
    return Gn.AES.encrypt(n, r).toString();
  }
}
function rE(e, t) {
  return function() {
    return e.apply(t, arguments);
  };
}
const { toString: dQ } = Object.prototype, { getPrototypeOf: mp } = Object, Tu = /* @__PURE__ */ ((e) => (t) => {
  const n = dQ.call(t);
  return e[n] || (e[n] = n.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), Yn = (e) => (e = e.toLowerCase(), (t) => Tu(t) === e), Ou = (e) => (t) => typeof t === e, { isArray: Ys } = Array, po = Ou("undefined");
function hQ(e) {
  return e !== null && !po(e) && e.constructor !== null && !po(e.constructor) && gn(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const iE = Yn("ArrayBuffer");
function pQ(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && iE(e.buffer), t;
}
const gQ = Ou("string"), gn = Ou("function"), sE = Ou("number"), Mu = (e) => e !== null && typeof e == "object", vQ = (e) => e === !0 || e === !1, Hl = (e) => {
  if (Tu(e) !== "object")
    return !1;
  const t = mp(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}, mQ = Yn("Date"), yQ = Yn("File"), xQ = Yn("Blob"), bQ = Yn("FileList"), _Q = (e) => Mu(e) && gn(e.pipe), wQ = (e) => {
  let t;
  return e && (typeof FormData == "function" && e instanceof FormData || gn(e.append) && ((t = Tu(e)) === "formdata" || // detect form-data instance
  t === "object" && gn(e.toString) && e.toString() === "[object FormData]"));
}, $Q = Yn("URLSearchParams"), EQ = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function Mo(e, t, { allOwnKeys: n = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let r, i;
  if (typeof e != "object" && (e = [e]), Ys(e))
    for (r = 0, i = e.length; r < i; r++)
      t.call(null, e[r], r, e);
  else {
    const s = n ? Object.getOwnPropertyNames(e) : Object.keys(e), a = s.length;
    let o;
    for (r = 0; r < a; r++)
      o = s[r], t.call(null, e[o], o, e);
  }
}
function aE(e, t) {
  t = t.toLowerCase();
  const n = Object.keys(e);
  let r = n.length, i;
  for (; r-- > 0; )
    if (i = n[r], t === i.toLowerCase())
      return i;
  return null;
}
const oE = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, lE = (e) => !po(e) && e !== oE;
function y0() {
  const { caseless: e } = lE(this) && this || {}, t = {}, n = (r, i) => {
    const s = e && aE(t, i) || i;
    Hl(t[s]) && Hl(r) ? t[s] = y0(t[s], r) : Hl(r) ? t[s] = y0({}, r) : Ys(r) ? t[s] = r.slice() : t[s] = r;
  };
  for (let r = 0, i = arguments.length; r < i; r++)
    arguments[r] && Mo(arguments[r], n);
  return t;
}
const AQ = (e, t, n, { allOwnKeys: r } = {}) => (Mo(t, (i, s) => {
  n && gn(i) ? e[s] = rE(i, n) : e[s] = i;
}, { allOwnKeys: r }), e), kQ = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), CQ = (e, t, n, r) => {
  e.prototype = Object.create(t.prototype, r), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: t.prototype
  }), n && Object.assign(e.prototype, n);
}, DQ = (e, t, n, r) => {
  let i, s, a;
  const o = {};
  if (t = t || {}, e == null)
    return t;
  do {
    for (i = Object.getOwnPropertyNames(e), s = i.length; s-- > 0; )
      a = i[s], (!r || r(a, e, t)) && !o[a] && (t[a] = e[a], o[a] = !0);
    e = n !== !1 && mp(e);
  } while (e && (!n || n(e, t)) && e !== Object.prototype);
  return t;
}, SQ = (e, t, n) => {
  e = String(e), (n === void 0 || n > e.length) && (n = e.length), n -= t.length;
  const r = e.indexOf(t, n);
  return r !== -1 && r === n;
}, TQ = (e) => {
  if (!e)
    return null;
  if (Ys(e))
    return e;
  let t = e.length;
  if (!sE(t))
    return null;
  const n = new Array(t);
  for (; t-- > 0; )
    n[t] = e[t];
  return n;
}, OQ = /* @__PURE__ */ ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && mp(Uint8Array)), MQ = (e, t) => {
  const r = (e && e[Symbol.iterator]).call(e);
  let i;
  for (; (i = r.next()) && !i.done; ) {
    const s = i.value;
    t.call(e, s[0], s[1]);
  }
}, FQ = (e, t) => {
  let n;
  const r = [];
  for (; (n = e.exec(t)) !== null; )
    r.push(n);
  return r;
}, PQ = Yn("HTMLFormElement"), IQ = (e) => e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(n, r, i) {
    return r.toUpperCase() + i;
  }
), Jx = (({ hasOwnProperty: e }) => (t, n) => e.call(t, n))(Object.prototype), RQ = Yn("RegExp"), cE = (e, t) => {
  const n = Object.getOwnPropertyDescriptors(e), r = {};
  Mo(n, (i, s) => {
    let a;
    (a = t(i, s, e)) !== !1 && (r[s] = a || i);
  }), Object.defineProperties(e, r);
}, BQ = (e) => {
  cE(e, (t, n) => {
    if (gn(e) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
      return !1;
    const r = e[n];
    if (gn(r)) {
      if (t.enumerable = !1, "writable" in t) {
        t.writable = !1;
        return;
      }
      t.set || (t.set = () => {
        throw Error("Can not rewrite read-only method '" + n + "'");
      });
    }
  });
}, NQ = (e, t) => {
  const n = {}, r = (i) => {
    i.forEach((s) => {
      n[s] = !0;
    });
  };
  return Ys(e) ? r(e) : r(String(e).split(t)), n;
}, LQ = () => {
}, jQ = (e, t) => (e = +e, Number.isFinite(e) ? e : t), ld = "abcdefghijklmnopqrstuvwxyz", Qx = "0123456789", uE = {
  DIGIT: Qx,
  ALPHA: ld,
  ALPHA_DIGIT: ld + ld.toUpperCase() + Qx
}, zQ = (e = 16, t = uE.ALPHA_DIGIT) => {
  let n = "";
  const { length: r } = t;
  for (; e--; )
    n += t[Math.random() * r | 0];
  return n;
};
function VQ(e) {
  return !!(e && gn(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator]);
}
const HQ = (e) => {
  const t = new Array(10), n = (r, i) => {
    if (Mu(r)) {
      if (t.indexOf(r) >= 0)
        return;
      if (!("toJSON" in r)) {
        t[i] = r;
        const s = Ys(r) ? [] : {};
        return Mo(r, (a, o) => {
          const l = n(a, i + 1);
          !po(l) && (s[o] = l);
        }), t[i] = void 0, s;
      }
    }
    return r;
  };
  return n(e, 0);
}, WQ = Yn("AsyncFunction"), UQ = (e) => e && (Mu(e) || gn(e)) && gn(e.then) && gn(e.catch), Y = {
  isArray: Ys,
  isArrayBuffer: iE,
  isBuffer: hQ,
  isFormData: wQ,
  isArrayBufferView: pQ,
  isString: gQ,
  isNumber: sE,
  isBoolean: vQ,
  isObject: Mu,
  isPlainObject: Hl,
  isUndefined: po,
  isDate: mQ,
  isFile: yQ,
  isBlob: xQ,
  isRegExp: RQ,
  isFunction: gn,
  isStream: _Q,
  isURLSearchParams: $Q,
  isTypedArray: OQ,
  isFileList: bQ,
  forEach: Mo,
  merge: y0,
  extend: AQ,
  trim: EQ,
  stripBOM: kQ,
  inherits: CQ,
  toFlatObject: DQ,
  kindOf: Tu,
  kindOfTest: Yn,
  endsWith: SQ,
  toArray: TQ,
  forEachEntry: MQ,
  matchAll: FQ,
  isHTMLForm: PQ,
  hasOwnProperty: Jx,
  hasOwnProp: Jx,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: cE,
  freezeMethods: BQ,
  toObjectSet: NQ,
  toCamelCase: IQ,
  noop: LQ,
  toFiniteNumber: jQ,
  findKey: aE,
  global: oE,
  isContextDefined: lE,
  ALPHABET: uE,
  generateString: zQ,
  isSpecCompliantForm: VQ,
  toJSONObject: HQ,
  isAsyncFn: WQ,
  isThenable: UQ
};
function Te(e, t, n, r, i) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), r && (this.request = r), i && (this.response = i);
}
Y.inherits(Te, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: Y.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const fE = Te.prototype, dE = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  dE[e] = { value: e };
});
Object.defineProperties(Te, dE);
Object.defineProperty(fE, "isAxiosError", { value: !0 });
Te.from = (e, t, n, r, i, s) => {
  const a = Object.create(fE);
  return Y.toFlatObject(e, a, function(l) {
    return l !== Error.prototype;
  }, (o) => o !== "isAxiosError"), Te.call(a, e.message, t, n, r, i), a.cause = e, a.name = e.name, s && Object.assign(a, s), a;
};
const YQ = null;
function x0(e) {
  return Y.isPlainObject(e) || Y.isArray(e);
}
function hE(e) {
  return Y.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function e1(e, t, n) {
  return e ? e.concat(t).map(function(i, s) {
    return i = hE(i), !n && s ? "[" + i + "]" : i;
  }).join(n ? "." : "") : t;
}
function qQ(e) {
  return Y.isArray(e) && !e.some(x0);
}
const GQ = Y.toFlatObject(Y, {}, null, function(t) {
  return /^is[A-Z]/.test(t);
});
function Fu(e, t, n) {
  if (!Y.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new FormData(), n = Y.toFlatObject(n, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(g, v) {
    return !Y.isUndefined(v[g]);
  });
  const r = n.metaTokens, i = n.visitor || u, s = n.dots, a = n.indexes, l = (n.Blob || typeof Blob < "u" && Blob) && Y.isSpecCompliantForm(t);
  if (!Y.isFunction(i))
    throw new TypeError("visitor must be a function");
  function c(p) {
    if (p === null)
      return "";
    if (Y.isDate(p))
      return p.toISOString();
    if (!l && Y.isBlob(p))
      throw new Te("Blob is not supported. Use a Buffer instead.");
    return Y.isArrayBuffer(p) || Y.isTypedArray(p) ? l && typeof Blob == "function" ? new Blob([p]) : Buffer.from(p) : p;
  }
  function u(p, g, v) {
    let m = p;
    if (p && !v && typeof p == "object") {
      if (Y.endsWith(g, "{}"))
        g = r ? g : g.slice(0, -2), p = JSON.stringify(p);
      else if (Y.isArray(p) && qQ(p) || (Y.isFileList(p) || Y.endsWith(g, "[]")) && (m = Y.toArray(p)))
        return g = hE(g), m.forEach(function(_, y) {
          !(Y.isUndefined(_) || _ === null) && t.append(
            // eslint-disable-next-line no-nested-ternary
            a === !0 ? e1([g], y, s) : a === null ? g : g + "[]",
            c(_)
          );
        }), !1;
    }
    return x0(p) ? !0 : (t.append(e1(v, g, s), c(p)), !1);
  }
  const f = [], d = Object.assign(GQ, {
    defaultVisitor: u,
    convertValue: c,
    isVisitable: x0
  });
  function h(p, g) {
    if (!Y.isUndefined(p)) {
      if (f.indexOf(p) !== -1)
        throw Error("Circular reference detected in " + g.join("."));
      f.push(p), Y.forEach(p, function(m, x) {
        (!(Y.isUndefined(m) || m === null) && i.call(
          t,
          m,
          Y.isString(x) ? x.trim() : x,
          g,
          d
        )) === !0 && h(m, g ? g.concat(x) : [x]);
      }), f.pop();
    }
  }
  if (!Y.isObject(e))
    throw new TypeError("data must be an object");
  return h(e), t;
}
function t1(e) {
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(r) {
    return t[r];
  });
}
function yp(e, t) {
  this._pairs = [], e && Fu(e, this, t);
}
const pE = yp.prototype;
pE.append = function(t, n) {
  this._pairs.push([t, n]);
};
pE.toString = function(t) {
  const n = t ? function(r) {
    return t.call(this, r, t1);
  } : t1;
  return this._pairs.map(function(i) {
    return n(i[0]) + "=" + n(i[1]);
  }, "").join("&");
};
function XQ(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function gE(e, t, n) {
  if (!t)
    return e;
  const r = n && n.encode || XQ, i = n && n.serialize;
  let s;
  if (i ? s = i(t, n) : s = Y.isURLSearchParams(t) ? t.toString() : new yp(t, n).toString(r), s) {
    const a = e.indexOf("#");
    a !== -1 && (e = e.slice(0, a)), e += (e.indexOf("?") === -1 ? "?" : "&") + s;
  }
  return e;
}
class n1 {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(t, n, r) {
    return this.handlers.push({
      fulfilled: t,
      rejected: n,
      synchronous: r ? r.synchronous : !1,
      runWhen: r ? r.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(t) {
    Y.forEach(this.handlers, function(r) {
      r !== null && t(r);
    });
  }
}
const vE = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, ZQ = typeof URLSearchParams < "u" ? URLSearchParams : yp, KQ = typeof FormData < "u" ? FormData : null, JQ = typeof Blob < "u" ? Blob : null, QQ = {
  isBrowser: !0,
  classes: {
    URLSearchParams: ZQ,
    FormData: KQ,
    Blob: JQ
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, mE = typeof window < "u" && typeof document < "u", eee = ((e) => mE && ["ReactNative", "NativeScript", "NS"].indexOf(e) < 0)(typeof navigator < "u" && navigator.product), tee = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", nee = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: mE,
  hasStandardBrowserEnv: eee,
  hasStandardBrowserWebWorkerEnv: tee
}, Symbol.toStringTag, { value: "Module" })), Ln = {
  ...nee,
  ...QQ
};
function ree(e, t) {
  return Fu(e, new Ln.classes.URLSearchParams(), Object.assign({
    visitor: function(n, r, i, s) {
      return Ln.isNode && Y.isBuffer(n) ? (this.append(r, n.toString("base64")), !1) : s.defaultVisitor.apply(this, arguments);
    }
  }, t));
}
function iee(e) {
  return Y.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
}
function see(e) {
  const t = {}, n = Object.keys(e);
  let r;
  const i = n.length;
  let s;
  for (r = 0; r < i; r++)
    s = n[r], t[s] = e[s];
  return t;
}
function yE(e) {
  function t(n, r, i, s) {
    let a = n[s++];
    if (a === "__proto__")
      return !0;
    const o = Number.isFinite(+a), l = s >= n.length;
    return a = !a && Y.isArray(i) ? i.length : a, l ? (Y.hasOwnProp(i, a) ? i[a] = [i[a], r] : i[a] = r, !o) : ((!i[a] || !Y.isObject(i[a])) && (i[a] = []), t(n, r, i[a], s) && Y.isArray(i[a]) && (i[a] = see(i[a])), !o);
  }
  if (Y.isFormData(e) && Y.isFunction(e.entries)) {
    const n = {};
    return Y.forEachEntry(e, (r, i) => {
      t(iee(r), i, n, 0);
    }), n;
  }
  return null;
}
function aee(e, t, n) {
  if (Y.isString(e))
    try {
      return (t || JSON.parse)(e), Y.trim(e);
    } catch (r) {
      if (r.name !== "SyntaxError")
        throw r;
    }
  return (n || JSON.stringify)(e);
}
const xp = {
  transitional: vE,
  adapter: ["xhr", "http"],
  transformRequest: [function(t, n) {
    const r = n.getContentType() || "", i = r.indexOf("application/json") > -1, s = Y.isObject(t);
    if (s && Y.isHTMLForm(t) && (t = new FormData(t)), Y.isFormData(t))
      return i && i ? JSON.stringify(yE(t)) : t;
    if (Y.isArrayBuffer(t) || Y.isBuffer(t) || Y.isStream(t) || Y.isFile(t) || Y.isBlob(t))
      return t;
    if (Y.isArrayBufferView(t))
      return t.buffer;
    if (Y.isURLSearchParams(t))
      return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString();
    let o;
    if (s) {
      if (r.indexOf("application/x-www-form-urlencoded") > -1)
        return ree(t, this.formSerializer).toString();
      if ((o = Y.isFileList(t)) || r.indexOf("multipart/form-data") > -1) {
        const l = this.env && this.env.FormData;
        return Fu(
          o ? { "files[]": t } : t,
          l && new l(),
          this.formSerializer
        );
      }
    }
    return s || i ? (n.setContentType("application/json", !1), aee(t)) : t;
  }],
  transformResponse: [function(t) {
    const n = this.transitional || xp.transitional, r = n && n.forcedJSONParsing, i = this.responseType === "json";
    if (t && Y.isString(t) && (r && !this.responseType || i)) {
      const a = !(n && n.silentJSONParsing) && i;
      try {
        return JSON.parse(t);
      } catch (o) {
        if (a)
          throw o.name === "SyntaxError" ? Te.from(o, Te.ERR_BAD_RESPONSE, this, null, this.response) : o;
      }
    }
    return t;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: Ln.classes.FormData,
    Blob: Ln.classes.Blob
  },
  validateStatus: function(t) {
    return t >= 200 && t < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
Y.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
  xp.headers[e] = {};
});
const bp = xp, oee = Y.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), lee = (e) => {
  const t = {};
  let n, r, i;
  return e && e.split(`
`).forEach(function(a) {
    i = a.indexOf(":"), n = a.substring(0, i).trim().toLowerCase(), r = a.substring(i + 1).trim(), !(!n || t[n] && oee[n]) && (n === "set-cookie" ? t[n] ? t[n].push(r) : t[n] = [r] : t[n] = t[n] ? t[n] + ", " + r : r);
  }), t;
}, r1 = Symbol("internals");
function pa(e) {
  return e && String(e).trim().toLowerCase();
}
function Wl(e) {
  return e === !1 || e == null ? e : Y.isArray(e) ? e.map(Wl) : String(e);
}
function cee(e) {
  const t = /* @__PURE__ */ Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let r;
  for (; r = n.exec(e); )
    t[r[1]] = r[2];
  return t;
}
const uee = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function cd(e, t, n, r, i) {
  if (Y.isFunction(r))
    return r.call(this, t, n);
  if (i && (t = n), !!Y.isString(t)) {
    if (Y.isString(r))
      return t.indexOf(r) !== -1;
    if (Y.isRegExp(r))
      return r.test(t);
  }
}
function fee(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, n, r) => n.toUpperCase() + r);
}
function dee(e, t) {
  const n = Y.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((r) => {
    Object.defineProperty(e, r + n, {
      value: function(i, s, a) {
        return this[r].call(this, t, i, s, a);
      },
      configurable: !0
    });
  });
}
class Pu {
  constructor(t) {
    t && this.set(t);
  }
  set(t, n, r) {
    const i = this;
    function s(o, l, c) {
      const u = pa(l);
      if (!u)
        throw new Error("header name must be a non-empty string");
      const f = Y.findKey(i, u);
      (!f || i[f] === void 0 || c === !0 || c === void 0 && i[f] !== !1) && (i[f || l] = Wl(o));
    }
    const a = (o, l) => Y.forEach(o, (c, u) => s(c, u, l));
    return Y.isPlainObject(t) || t instanceof this.constructor ? a(t, n) : Y.isString(t) && (t = t.trim()) && !uee(t) ? a(lee(t), n) : t != null && s(n, t, r), this;
  }
  get(t, n) {
    if (t = pa(t), t) {
      const r = Y.findKey(this, t);
      if (r) {
        const i = this[r];
        if (!n)
          return i;
        if (n === !0)
          return cee(i);
        if (Y.isFunction(n))
          return n.call(this, i, r);
        if (Y.isRegExp(n))
          return n.exec(i);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(t, n) {
    if (t = pa(t), t) {
      const r = Y.findKey(this, t);
      return !!(r && this[r] !== void 0 && (!n || cd(this, this[r], r, n)));
    }
    return !1;
  }
  delete(t, n) {
    const r = this;
    let i = !1;
    function s(a) {
      if (a = pa(a), a) {
        const o = Y.findKey(r, a);
        o && (!n || cd(r, r[o], o, n)) && (delete r[o], i = !0);
      }
    }
    return Y.isArray(t) ? t.forEach(s) : s(t), i;
  }
  clear(t) {
    const n = Object.keys(this);
    let r = n.length, i = !1;
    for (; r--; ) {
      const s = n[r];
      (!t || cd(this, this[s], s, t, !0)) && (delete this[s], i = !0);
    }
    return i;
  }
  normalize(t) {
    const n = this, r = {};
    return Y.forEach(this, (i, s) => {
      const a = Y.findKey(r, s);
      if (a) {
        n[a] = Wl(i), delete n[s];
        return;
      }
      const o = t ? fee(s) : String(s).trim();
      o !== s && delete n[s], n[o] = Wl(i), r[o] = !0;
    }), this;
  }
  concat(...t) {
    return this.constructor.concat(this, ...t);
  }
  toJSON(t) {
    const n = /* @__PURE__ */ Object.create(null);
    return Y.forEach(this, (r, i) => {
      r != null && r !== !1 && (n[i] = t && Y.isArray(r) ? r.join(", ") : r);
    }), n;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([t, n]) => t + ": " + n).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(t) {
    return t instanceof this ? t : new this(t);
  }
  static concat(t, ...n) {
    const r = new this(t);
    return n.forEach((i) => r.set(i)), r;
  }
  static accessor(t) {
    const r = (this[r1] = this[r1] = {
      accessors: {}
    }).accessors, i = this.prototype;
    function s(a) {
      const o = pa(a);
      r[o] || (dee(i, a), r[o] = !0);
    }
    return Y.isArray(t) ? t.forEach(s) : s(t), this;
  }
}
Pu.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
Y.reduceDescriptors(Pu.prototype, ({ value: e }, t) => {
  let n = t[0].toUpperCase() + t.slice(1);
  return {
    get: () => e,
    set(r) {
      this[n] = r;
    }
  };
});
Y.freezeMethods(Pu);
const ir = Pu;
function ud(e, t) {
  const n = this || bp, r = t || n, i = ir.from(r.headers);
  let s = r.data;
  return Y.forEach(e, function(o) {
    s = o.call(n, s, i.normalize(), t ? t.status : void 0);
  }), i.normalize(), s;
}
function xE(e) {
  return !!(e && e.__CANCEL__);
}
function Fo(e, t, n) {
  Te.call(this, e ?? "canceled", Te.ERR_CANCELED, t, n), this.name = "CanceledError";
}
Y.inherits(Fo, Te, {
  __CANCEL__: !0
});
function hee(e, t, n) {
  const r = n.config.validateStatus;
  !n.status || !r || r(n.status) ? e(n) : t(new Te(
    "Request failed with status code " + n.status,
    [Te.ERR_BAD_REQUEST, Te.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],
    n.config,
    n.request,
    n
  ));
}
const pee = Ln.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(e, t, n, r, i, s) {
      const a = [e + "=" + encodeURIComponent(t)];
      Y.isNumber(n) && a.push("expires=" + new Date(n).toGMTString()), Y.isString(r) && a.push("path=" + r), Y.isString(i) && a.push("domain=" + i), s === !0 && a.push("secure"), document.cookie = a.join("; ");
    },
    read(e) {
      const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
      return t ? decodeURIComponent(t[3]) : null;
    },
    remove(e) {
      this.write(e, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function gee(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function vee(e, t) {
  return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function bE(e, t) {
  return e && !gee(t) ? vee(e, t) : t;
}
const mee = Ln.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function() {
    const t = /(msie|trident)/i.test(navigator.userAgent), n = document.createElement("a");
    let r;
    function i(s) {
      let a = s;
      return t && (n.setAttribute("href", a), a = n.href), n.setAttribute("href", a), {
        href: n.href,
        protocol: n.protocol ? n.protocol.replace(/:$/, "") : "",
        host: n.host,
        search: n.search ? n.search.replace(/^\?/, "") : "",
        hash: n.hash ? n.hash.replace(/^#/, "") : "",
        hostname: n.hostname,
        port: n.port,
        pathname: n.pathname.charAt(0) === "/" ? n.pathname : "/" + n.pathname
      };
    }
    return r = i(window.location.href), function(a) {
      const o = Y.isString(a) ? i(a) : a;
      return o.protocol === r.protocol && o.host === r.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  /* @__PURE__ */ function() {
    return function() {
      return !0;
    };
  }()
);
function yee(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || "";
}
function xee(e, t) {
  e = e || 10;
  const n = new Array(e), r = new Array(e);
  let i = 0, s = 0, a;
  return t = t !== void 0 ? t : 1e3, function(l) {
    const c = Date.now(), u = r[s];
    a || (a = c), n[i] = l, r[i] = c;
    let f = s, d = 0;
    for (; f !== i; )
      d += n[f++], f = f % e;
    if (i = (i + 1) % e, i === s && (s = (s + 1) % e), c - a < t)
      return;
    const h = u && c - u;
    return h ? Math.round(d * 1e3 / h) : void 0;
  };
}
function i1(e, t) {
  let n = 0;
  const r = xee(50, 250);
  return (i) => {
    const s = i.loaded, a = i.lengthComputable ? i.total : void 0, o = s - n, l = r(o), c = s <= a;
    n = s;
    const u = {
      loaded: s,
      total: a,
      progress: a ? s / a : void 0,
      bytes: o,
      rate: l || void 0,
      estimated: l && a && c ? (a - s) / l : void 0,
      event: i
    };
    u[t ? "download" : "upload"] = !0, e(u);
  };
}
const bee = typeof XMLHttpRequest < "u", _ee = bee && function(e) {
  return new Promise(function(n, r) {
    let i = e.data;
    const s = ir.from(e.headers).normalize();
    let { responseType: a, withXSRFToken: o } = e, l;
    function c() {
      e.cancelToken && e.cancelToken.unsubscribe(l), e.signal && e.signal.removeEventListener("abort", l);
    }
    let u;
    if (Y.isFormData(i)) {
      if (Ln.hasStandardBrowserEnv || Ln.hasStandardBrowserWebWorkerEnv)
        s.setContentType(!1);
      else if ((u = s.getContentType()) !== !1) {
        const [g, ...v] = u ? u.split(";").map((m) => m.trim()).filter(Boolean) : [];
        s.setContentType([g || "multipart/form-data", ...v].join("; "));
      }
    }
    let f = new XMLHttpRequest();
    if (e.auth) {
      const g = e.auth.username || "", v = e.auth.password ? unescape(encodeURIComponent(e.auth.password)) : "";
      s.set("Authorization", "Basic " + btoa(g + ":" + v));
    }
    const d = bE(e.baseURL, e.url);
    f.open(e.method.toUpperCase(), gE(d, e.params, e.paramsSerializer), !0), f.timeout = e.timeout;
    function h() {
      if (!f)
        return;
      const g = ir.from(
        "getAllResponseHeaders" in f && f.getAllResponseHeaders()
      ), m = {
        data: !a || a === "text" || a === "json" ? f.responseText : f.response,
        status: f.status,
        statusText: f.statusText,
        headers: g,
        config: e,
        request: f
      };
      hee(function(_) {
        n(_), c();
      }, function(_) {
        r(_), c();
      }, m), f = null;
    }
    if ("onloadend" in f ? f.onloadend = h : f.onreadystatechange = function() {
      !f || f.readyState !== 4 || f.status === 0 && !(f.responseURL && f.responseURL.indexOf("file:") === 0) || setTimeout(h);
    }, f.onabort = function() {
      f && (r(new Te("Request aborted", Te.ECONNABORTED, e, f)), f = null);
    }, f.onerror = function() {
      r(new Te("Network Error", Te.ERR_NETWORK, e, f)), f = null;
    }, f.ontimeout = function() {
      let v = e.timeout ? "timeout of " + e.timeout + "ms exceeded" : "timeout exceeded";
      const m = e.transitional || vE;
      e.timeoutErrorMessage && (v = e.timeoutErrorMessage), r(new Te(
        v,
        m.clarifyTimeoutError ? Te.ETIMEDOUT : Te.ECONNABORTED,
        e,
        f
      )), f = null;
    }, Ln.hasStandardBrowserEnv && (o && Y.isFunction(o) && (o = o(e)), o || o !== !1 && mee(d))) {
      const g = e.xsrfHeaderName && e.xsrfCookieName && pee.read(e.xsrfCookieName);
      g && s.set(e.xsrfHeaderName, g);
    }
    i === void 0 && s.setContentType(null), "setRequestHeader" in f && Y.forEach(s.toJSON(), function(v, m) {
      f.setRequestHeader(m, v);
    }), Y.isUndefined(e.withCredentials) || (f.withCredentials = !!e.withCredentials), a && a !== "json" && (f.responseType = e.responseType), typeof e.onDownloadProgress == "function" && f.addEventListener("progress", i1(e.onDownloadProgress, !0)), typeof e.onUploadProgress == "function" && f.upload && f.upload.addEventListener("progress", i1(e.onUploadProgress)), (e.cancelToken || e.signal) && (l = (g) => {
      f && (r(!g || g.type ? new Fo(null, e, f) : g), f.abort(), f = null);
    }, e.cancelToken && e.cancelToken.subscribe(l), e.signal && (e.signal.aborted ? l() : e.signal.addEventListener("abort", l)));
    const p = yee(d);
    if (p && Ln.protocols.indexOf(p) === -1) {
      r(new Te("Unsupported protocol " + p + ":", Te.ERR_BAD_REQUEST, e));
      return;
    }
    f.send(i || null);
  });
}, b0 = {
  http: YQ,
  xhr: _ee
};
Y.forEach(b0, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: t });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: t });
  }
});
const s1 = (e) => `- ${e}`, wee = (e) => Y.isFunction(e) || e === null || e === !1, _E = {
  getAdapter: (e) => {
    e = Y.isArray(e) ? e : [e];
    const { length: t } = e;
    let n, r;
    const i = {};
    for (let s = 0; s < t; s++) {
      n = e[s];
      let a;
      if (r = n, !wee(n) && (r = b0[(a = String(n)).toLowerCase()], r === void 0))
        throw new Te(`Unknown adapter '${a}'`);
      if (r)
        break;
      i[a || "#" + s] = r;
    }
    if (!r) {
      const s = Object.entries(i).map(
        ([o, l]) => `adapter ${o} ` + (l === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let a = t ? s.length > 1 ? `since :
` + s.map(s1).join(`
`) : " " + s1(s[0]) : "as no adapter specified";
      throw new Te(
        "There is no suitable adapter to dispatch the request " + a,
        "ERR_NOT_SUPPORT"
      );
    }
    return r;
  },
  adapters: b0
};
function fd(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new Fo(null, e);
}
function a1(e) {
  return fd(e), e.headers = ir.from(e.headers), e.data = ud.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), _E.getAdapter(e.adapter || bp.adapter)(e).then(function(r) {
    return fd(e), r.data = ud.call(
      e,
      e.transformResponse,
      r
    ), r.headers = ir.from(r.headers), r;
  }, function(r) {
    return xE(r) || (fd(e), r && r.response && (r.response.data = ud.call(
      e,
      e.transformResponse,
      r.response
    ), r.response.headers = ir.from(r.response.headers))), Promise.reject(r);
  });
}
const o1 = (e) => e instanceof ir ? e.toJSON() : e;
function Os(e, t) {
  t = t || {};
  const n = {};
  function r(c, u, f) {
    return Y.isPlainObject(c) && Y.isPlainObject(u) ? Y.merge.call({ caseless: f }, c, u) : Y.isPlainObject(u) ? Y.merge({}, u) : Y.isArray(u) ? u.slice() : u;
  }
  function i(c, u, f) {
    if (Y.isUndefined(u)) {
      if (!Y.isUndefined(c))
        return r(void 0, c, f);
    } else
      return r(c, u, f);
  }
  function s(c, u) {
    if (!Y.isUndefined(u))
      return r(void 0, u);
  }
  function a(c, u) {
    if (Y.isUndefined(u)) {
      if (!Y.isUndefined(c))
        return r(void 0, c);
    } else
      return r(void 0, u);
  }
  function o(c, u, f) {
    if (f in t)
      return r(c, u);
    if (f in e)
      return r(void 0, c);
  }
  const l = {
    url: s,
    method: s,
    data: s,
    baseURL: a,
    transformRequest: a,
    transformResponse: a,
    paramsSerializer: a,
    timeout: a,
    timeoutMessage: a,
    withCredentials: a,
    withXSRFToken: a,
    adapter: a,
    responseType: a,
    xsrfCookieName: a,
    xsrfHeaderName: a,
    onUploadProgress: a,
    onDownloadProgress: a,
    decompress: a,
    maxContentLength: a,
    maxBodyLength: a,
    beforeRedirect: a,
    transport: a,
    httpAgent: a,
    httpsAgent: a,
    cancelToken: a,
    socketPath: a,
    responseEncoding: a,
    validateStatus: o,
    headers: (c, u) => i(o1(c), o1(u), !0)
  };
  return Y.forEach(Object.keys(Object.assign({}, e, t)), function(u) {
    const f = l[u] || i, d = f(e[u], t[u], u);
    Y.isUndefined(d) && f !== o || (n[u] = d);
  }), n;
}
const wE = "1.6.5", _p = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  _p[e] = function(r) {
    return typeof r === e || "a" + (t < 1 ? "n " : " ") + e;
  };
});
const l1 = {};
_p.transitional = function(t, n, r) {
  function i(s, a) {
    return "[Axios v" + wE + "] Transitional option '" + s + "'" + a + (r ? ". " + r : "");
  }
  return (s, a, o) => {
    if (t === !1)
      throw new Te(
        i(a, " has been removed" + (n ? " in " + n : "")),
        Te.ERR_DEPRECATED
      );
    return n && !l1[a] && (l1[a] = !0, console.warn(
      i(
        a,
        " has been deprecated since v" + n + " and will be removed in the near future"
      )
    )), t ? t(s, a, o) : !0;
  };
};
function $ee(e, t, n) {
  if (typeof e != "object")
    throw new Te("options must be an object", Te.ERR_BAD_OPTION_VALUE);
  const r = Object.keys(e);
  let i = r.length;
  for (; i-- > 0; ) {
    const s = r[i], a = t[s];
    if (a) {
      const o = e[s], l = o === void 0 || a(o, s, e);
      if (l !== !0)
        throw new Te("option " + s + " must be " + l, Te.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (n !== !0)
      throw new Te("Unknown option " + s, Te.ERR_BAD_OPTION);
  }
}
const _0 = {
  assertOptions: $ee,
  validators: _p
}, wr = _0.validators;
class Lc {
  constructor(t) {
    this.defaults = t, this.interceptors = {
      request: new n1(),
      response: new n1()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(t, n) {
    typeof t == "string" ? (n = n || {}, n.url = t) : n = t || {}, n = Os(this.defaults, n);
    const { transitional: r, paramsSerializer: i, headers: s } = n;
    r !== void 0 && _0.assertOptions(r, {
      silentJSONParsing: wr.transitional(wr.boolean),
      forcedJSONParsing: wr.transitional(wr.boolean),
      clarifyTimeoutError: wr.transitional(wr.boolean)
    }, !1), i != null && (Y.isFunction(i) ? n.paramsSerializer = {
      serialize: i
    } : _0.assertOptions(i, {
      encode: wr.function,
      serialize: wr.function
    }, !0)), n.method = (n.method || this.defaults.method || "get").toLowerCase();
    let a = s && Y.merge(
      s.common,
      s[n.method]
    );
    s && Y.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (p) => {
        delete s[p];
      }
    ), n.headers = ir.concat(a, s);
    const o = [];
    let l = !0;
    this.interceptors.request.forEach(function(g) {
      typeof g.runWhen == "function" && g.runWhen(n) === !1 || (l = l && g.synchronous, o.unshift(g.fulfilled, g.rejected));
    });
    const c = [];
    this.interceptors.response.forEach(function(g) {
      c.push(g.fulfilled, g.rejected);
    });
    let u, f = 0, d;
    if (!l) {
      const p = [a1.bind(this), void 0];
      for (p.unshift.apply(p, o), p.push.apply(p, c), d = p.length, u = Promise.resolve(n); f < d; )
        u = u.then(p[f++], p[f++]);
      return u;
    }
    d = o.length;
    let h = n;
    for (f = 0; f < d; ) {
      const p = o[f++], g = o[f++];
      try {
        h = p(h);
      } catch (v) {
        g.call(this, v);
        break;
      }
    }
    try {
      u = a1.call(this, h);
    } catch (p) {
      return Promise.reject(p);
    }
    for (f = 0, d = c.length; f < d; )
      u = u.then(c[f++], c[f++]);
    return u;
  }
  getUri(t) {
    t = Os(this.defaults, t);
    const n = bE(t.baseURL, t.url);
    return gE(n, t.params, t.paramsSerializer);
  }
}
Y.forEach(["delete", "get", "head", "options"], function(t) {
  Lc.prototype[t] = function(n, r) {
    return this.request(Os(r || {}, {
      method: t,
      url: n,
      data: (r || {}).data
    }));
  };
});
Y.forEach(["post", "put", "patch"], function(t) {
  function n(r) {
    return function(s, a, o) {
      return this.request(Os(o || {}, {
        method: t,
        headers: r ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: s,
        data: a
      }));
    };
  }
  Lc.prototype[t] = n(), Lc.prototype[t + "Form"] = n(!0);
});
const Ul = Lc;
class wp {
  constructor(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    let n;
    this.promise = new Promise(function(s) {
      n = s;
    });
    const r = this;
    this.promise.then((i) => {
      if (!r._listeners)
        return;
      let s = r._listeners.length;
      for (; s-- > 0; )
        r._listeners[s](i);
      r._listeners = null;
    }), this.promise.then = (i) => {
      let s;
      const a = new Promise((o) => {
        r.subscribe(o), s = o;
      }).then(i);
      return a.cancel = function() {
        r.unsubscribe(s);
      }, a;
    }, t(function(s, a, o) {
      r.reason || (r.reason = new Fo(s, a, o), n(r.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(t) {
    if (this.reason) {
      t(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(t) : this._listeners = [t];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(t) {
    if (!this._listeners)
      return;
    const n = this._listeners.indexOf(t);
    n !== -1 && this._listeners.splice(n, 1);
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let t;
    return {
      token: new wp(function(i) {
        t = i;
      }),
      cancel: t
    };
  }
}
const Eee = wp;
function Aee(e) {
  return function(n) {
    return e.apply(null, n);
  };
}
function kee(e) {
  return Y.isObject(e) && e.isAxiosError === !0;
}
const w0 = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(w0).forEach(([e, t]) => {
  w0[t] = e;
});
const Cee = w0;
function $E(e) {
  const t = new Ul(e), n = rE(Ul.prototype.request, t);
  return Y.extend(n, Ul.prototype, t, { allOwnKeys: !0 }), Y.extend(n, t, null, { allOwnKeys: !0 }), n.create = function(i) {
    return $E(Os(e, i));
  }, n;
}
const rt = $E(bp);
rt.Axios = Ul;
rt.CanceledError = Fo;
rt.CancelToken = Eee;
rt.isCancel = xE;
rt.VERSION = wE;
rt.toFormData = Fu;
rt.AxiosError = Te;
rt.Cancel = rt.CanceledError;
rt.all = function(t) {
  return Promise.all(t);
};
rt.spread = Aee;
rt.isAxiosError = kee;
rt.mergeConfig = Os;
rt.AxiosHeaders = ir;
rt.formToJSON = (e) => yE(Y.isHTMLForm(e) ? new FormData(e) : e);
rt.getAdapter = _E.getAdapter;
rt.HttpStatusCode = Cee;
rt.default = rt;
var $0 = function() {
  return $0 = Object.assign || function(t) {
    for (var n, r = 1, i = arguments.length; r < i; r++) {
      n = arguments[r];
      for (var s in n)
        Object.prototype.hasOwnProperty.call(n, s) && (t[s] = n[s]);
    }
    return t;
  }, $0.apply(this, arguments);
};
function vr(e, t, n, r) {
  function i(s) {
    return s instanceof n ? s : new n(function(a) {
      a(s);
    });
  }
  return new (n || (n = Promise))(function(s, a) {
    function o(u) {
      try {
        c(r.next(u));
      } catch (f) {
        a(f);
      }
    }
    function l(u) {
      try {
        c(r.throw(u));
      } catch (f) {
        a(f);
      }
    }
    function c(u) {
      u.done ? s(u.value) : i(u.value).then(o, l);
    }
    c((r = r.apply(e, t || [])).next());
  });
}
function mr(e, t) {
  var n = { label: 0, sent: function() {
    if (s[0] & 1)
      throw s[1];
    return s[1];
  }, trys: [], ops: [] }, r, i, s, a;
  return a = { next: o(0), throw: o(1), return: o(2) }, typeof Symbol == "function" && (a[Symbol.iterator] = function() {
    return this;
  }), a;
  function o(c) {
    return function(u) {
      return l([c, u]);
    };
  }
  function l(c) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; a && (a = 0, c[0] && (n = 0)), n; )
      try {
        if (r = 1, i && (s = c[0] & 2 ? i.return : c[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, c[1])).done)
          return s;
        switch (i = 0, s && (c = [c[0] & 2, s.value]), c[0]) {
          case 0:
          case 1:
            s = c;
            break;
          case 4:
            return n.label++, { value: c[1], done: !1 };
          case 5:
            n.label++, i = c[1], c = [0];
            continue;
          case 7:
            c = n.ops.pop(), n.trys.pop();
            continue;
          default:
            if (s = n.trys, !(s = s.length > 0 && s[s.length - 1]) && (c[0] === 6 || c[0] === 2)) {
              n = 0;
              continue;
            }
            if (c[0] === 3 && (!s || c[1] > s[0] && c[1] < s[3])) {
              n.label = c[1];
              break;
            }
            if (c[0] === 6 && n.label < s[1]) {
              n.label = s[1], s = c;
              break;
            }
            if (s && n.label < s[2]) {
              n.label = s[2], n.ops.push(c);
              break;
            }
            s[2] && n.ops.pop(), n.trys.pop();
            continue;
        }
        c = t.call(e, n);
      } catch (u) {
        c = [6, u], i = 0;
      } finally {
        r = s = 0;
      }
    if (c[0] & 5)
      throw c[1];
    return { value: c[0] ? c[1] : void 0, done: !0 };
  }
}
function EE(e, t, n) {
  if (n || arguments.length === 2)
    for (var r = 0, i = t.length, s; r < i; r++)
      (s || !(r in t)) && (s || (s = Array.prototype.slice.call(t, 0, r)), s[r] = t[r]);
  return e.concat(s || Array.prototype.slice.call(t));
}
var AE = "3.4.2";
function go(e, t) {
  return new Promise(function(n) {
    return setTimeout(n, e, t);
  });
}
function Dee(e, t) {
  t === void 0 && (t = 1 / 0);
  var n = window.requestIdleCallback;
  return n ? new Promise(function(r) {
    return n.call(window, function() {
      return r();
    }, { timeout: t });
  }) : go(Math.min(e, t));
}
function kE(e) {
  return !!e && typeof e.then == "function";
}
function c1(e, t) {
  try {
    var n = e();
    kE(n) ? n.then(function(r) {
      return t(!0, r);
    }, function(r) {
      return t(!1, r);
    }) : t(!0, n);
  } catch (r) {
    t(!1, r);
  }
}
function u1(e, t, n) {
  return n === void 0 && (n = 16), vr(this, void 0, void 0, function() {
    var r, i, s, a;
    return mr(this, function(o) {
      switch (o.label) {
        case 0:
          r = Array(e.length), i = Date.now(), s = 0, o.label = 1;
        case 1:
          return s < e.length ? (r[s] = t(e[s], s), a = Date.now(), a >= i + n ? (i = a, [4, go(0)]) : [3, 3]) : [3, 4];
        case 2:
          o.sent(), o.label = 3;
        case 3:
          return ++s, [3, 1];
        case 4:
          return [2, r];
      }
    });
  });
}
function vo(e) {
  e.then(void 0, function() {
  });
}
function $r(e, t) {
  e = [e[0] >>> 16, e[0] & 65535, e[1] >>> 16, e[1] & 65535], t = [t[0] >>> 16, t[0] & 65535, t[1] >>> 16, t[1] & 65535];
  var n = [0, 0, 0, 0];
  return n[3] += e[3] + t[3], n[2] += n[3] >>> 16, n[3] &= 65535, n[2] += e[2] + t[2], n[1] += n[2] >>> 16, n[2] &= 65535, n[1] += e[1] + t[1], n[0] += n[1] >>> 16, n[1] &= 65535, n[0] += e[0] + t[0], n[0] &= 65535, [n[0] << 16 | n[1], n[2] << 16 | n[3]];
}
function ln(e, t) {
  e = [e[0] >>> 16, e[0] & 65535, e[1] >>> 16, e[1] & 65535], t = [t[0] >>> 16, t[0] & 65535, t[1] >>> 16, t[1] & 65535];
  var n = [0, 0, 0, 0];
  return n[3] += e[3] * t[3], n[2] += n[3] >>> 16, n[3] &= 65535, n[2] += e[2] * t[3], n[1] += n[2] >>> 16, n[2] &= 65535, n[2] += e[3] * t[2], n[1] += n[2] >>> 16, n[2] &= 65535, n[1] += e[1] * t[3], n[0] += n[1] >>> 16, n[1] &= 65535, n[1] += e[2] * t[2], n[0] += n[1] >>> 16, n[1] &= 65535, n[1] += e[3] * t[1], n[0] += n[1] >>> 16, n[1] &= 65535, n[0] += e[0] * t[3] + e[1] * t[2] + e[2] * t[1] + e[3] * t[0], n[0] &= 65535, [n[0] << 16 | n[1], n[2] << 16 | n[3]];
}
function Xi(e, t) {
  return t %= 64, t === 32 ? [e[1], e[0]] : t < 32 ? [e[0] << t | e[1] >>> 32 - t, e[1] << t | e[0] >>> 32 - t] : (t -= 32, [e[1] << t | e[0] >>> 32 - t, e[0] << t | e[1] >>> 32 - t]);
}
function Qt(e, t) {
  return t %= 64, t === 0 ? e : t < 32 ? [e[0] << t | e[1] >>> 32 - t, e[1] << t] : [e[1] << t - 32, 0];
}
function Je(e, t) {
  return [e[0] ^ t[0], e[1] ^ t[1]];
}
function f1(e) {
  return e = Je(e, [0, e[0] >>> 1]), e = ln(e, [4283543511, 3981806797]), e = Je(e, [0, e[0] >>> 1]), e = ln(e, [3301882366, 444984403]), e = Je(e, [0, e[0] >>> 1]), e;
}
function See(e, t) {
  e = e || "", t = t || 0;
  var n = e.length % 16, r = e.length - n, i = [0, t], s = [0, t], a = [0, 0], o = [0, 0], l = [2277735313, 289559509], c = [1291169091, 658871167], u;
  for (u = 0; u < r; u = u + 16)
    a = [
      e.charCodeAt(u + 4) & 255 | (e.charCodeAt(u + 5) & 255) << 8 | (e.charCodeAt(u + 6) & 255) << 16 | (e.charCodeAt(u + 7) & 255) << 24,
      e.charCodeAt(u) & 255 | (e.charCodeAt(u + 1) & 255) << 8 | (e.charCodeAt(u + 2) & 255) << 16 | (e.charCodeAt(u + 3) & 255) << 24
    ], o = [
      e.charCodeAt(u + 12) & 255 | (e.charCodeAt(u + 13) & 255) << 8 | (e.charCodeAt(u + 14) & 255) << 16 | (e.charCodeAt(u + 15) & 255) << 24,
      e.charCodeAt(u + 8) & 255 | (e.charCodeAt(u + 9) & 255) << 8 | (e.charCodeAt(u + 10) & 255) << 16 | (e.charCodeAt(u + 11) & 255) << 24
    ], a = ln(a, l), a = Xi(a, 31), a = ln(a, c), i = Je(i, a), i = Xi(i, 27), i = $r(i, s), i = $r(ln(i, [0, 5]), [0, 1390208809]), o = ln(o, c), o = Xi(o, 33), o = ln(o, l), s = Je(s, o), s = Xi(s, 31), s = $r(s, i), s = $r(ln(s, [0, 5]), [0, 944331445]);
  switch (a = [0, 0], o = [0, 0], n) {
    case 15:
      o = Je(o, Qt([0, e.charCodeAt(u + 14)], 48));
    case 14:
      o = Je(o, Qt([0, e.charCodeAt(u + 13)], 40));
    case 13:
      o = Je(o, Qt([0, e.charCodeAt(u + 12)], 32));
    case 12:
      o = Je(o, Qt([0, e.charCodeAt(u + 11)], 24));
    case 11:
      o = Je(o, Qt([0, e.charCodeAt(u + 10)], 16));
    case 10:
      o = Je(o, Qt([0, e.charCodeAt(u + 9)], 8));
    case 9:
      o = Je(o, [0, e.charCodeAt(u + 8)]), o = ln(o, c), o = Xi(o, 33), o = ln(o, l), s = Je(s, o);
    case 8:
      a = Je(a, Qt([0, e.charCodeAt(u + 7)], 56));
    case 7:
      a = Je(a, Qt([0, e.charCodeAt(u + 6)], 48));
    case 6:
      a = Je(a, Qt([0, e.charCodeAt(u + 5)], 40));
    case 5:
      a = Je(a, Qt([0, e.charCodeAt(u + 4)], 32));
    case 4:
      a = Je(a, Qt([0, e.charCodeAt(u + 3)], 24));
    case 3:
      a = Je(a, Qt([0, e.charCodeAt(u + 2)], 16));
    case 2:
      a = Je(a, Qt([0, e.charCodeAt(u + 1)], 8));
    case 1:
      a = Je(a, [0, e.charCodeAt(u)]), a = ln(a, l), a = Xi(a, 31), a = ln(a, c), i = Je(i, a);
  }
  return i = Je(i, [0, e.length]), s = Je(s, [0, e.length]), i = $r(i, s), s = $r(s, i), i = f1(i), s = f1(s), i = $r(i, s), s = $r(s, i), ("00000000" + (i[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (i[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (s[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (s[1] >>> 0).toString(16)).slice(-8);
}
function Tee(e) {
  var t;
  return $0({ name: e.name, message: e.message, stack: (t = e.stack) === null || t === void 0 ? void 0 : t.split(`
`) }, e);
}
function Oee(e, t) {
  for (var n = 0, r = e.length; n < r; ++n)
    if (e[n] === t)
      return !0;
  return !1;
}
function Mee(e, t) {
  return !Oee(e, t);
}
function $p(e) {
  return parseInt(e);
}
function $n(e) {
  return parseFloat(e);
}
function Qn(e, t) {
  return typeof e == "number" && isNaN(e) ? t : e;
}
function Tn(e) {
  return e.reduce(function(t, n) {
    return t + (n ? 1 : 0);
  }, 0);
}
function CE(e, t) {
  if (t === void 0 && (t = 1), Math.abs(t) >= 1)
    return Math.round(e / t) * t;
  var n = 1 / t;
  return Math.round(e * n) / n;
}
function Fee(e) {
  for (var t, n, r = "Unexpected syntax '".concat(e, "'"), i = /^\s*([a-z-]*)(.*)$/i.exec(e), s = i[1] || void 0, a = {}, o = /([.:#][\w-]+|\[.+?\])/gi, l = function(d, h) {
    a[d] = a[d] || [], a[d].push(h);
  }; ; ) {
    var c = o.exec(i[2]);
    if (!c)
      break;
    var u = c[0];
    switch (u[0]) {
      case ".":
        l("class", u.slice(1));
        break;
      case "#":
        l("id", u.slice(1));
        break;
      case "[": {
        var f = /^\[([\w-]+)([~|^$*]?=("(.*?)"|([\w-]+)))?(\s+[is])?\]$/.exec(u);
        if (f)
          l(f[1], (n = (t = f[4]) !== null && t !== void 0 ? t : f[5]) !== null && n !== void 0 ? n : "");
        else
          throw new Error(r);
        break;
      }
      default:
        throw new Error(r);
    }
  }
  return [s, a];
}
function d1(e) {
  return e && typeof e == "object" && "message" in e ? e : { message: e };
}
function Pee(e) {
  return typeof e != "function";
}
function Iee(e, t) {
  var n = new Promise(function(r) {
    var i = Date.now();
    c1(e.bind(null, t), function() {
      for (var s = [], a = 0; a < arguments.length; a++)
        s[a] = arguments[a];
      var o = Date.now() - i;
      if (!s[0])
        return r(function() {
          return { error: d1(s[1]), duration: o };
        });
      var l = s[1];
      if (Pee(l))
        return r(function() {
          return { value: l, duration: o };
        });
      r(function() {
        return new Promise(function(c) {
          var u = Date.now();
          c1(l, function() {
            for (var f = [], d = 0; d < arguments.length; d++)
              f[d] = arguments[d];
            var h = o + Date.now() - u;
            if (!f[0])
              return c({ error: d1(f[1]), duration: h });
            c({ value: f[1], duration: h });
          });
        });
      });
    });
  });
  return vo(n), function() {
    return n.then(function(i) {
      return i();
    });
  };
}
function Ree(e, t, n) {
  var r = Object.keys(e).filter(function(s) {
    return Mee(n, s);
  }), i = u1(r, function(s) {
    return Iee(e[s], t);
  });
  return vo(i), function() {
    return vr(this, void 0, void 0, function() {
      var a, o, l, c, u;
      return mr(this, function(f) {
        switch (f.label) {
          case 0:
            return [4, i];
          case 1:
            return a = f.sent(), [4, u1(a, function(d) {
              var h = d();
              return vo(h), h;
            })];
          case 2:
            return o = f.sent(), [
              4,
              Promise.all(o)
              // Keeping the component keys order the same as the source keys order
            ];
          case 3:
            for (l = f.sent(), c = {}, u = 0; u < r.length; ++u)
              c[r[u]] = l[u];
            return [2, c];
        }
      });
    });
  };
}
function DE() {
  var e = window, t = navigator;
  return Tn([
    "MSCSSMatrix" in e,
    "msSetImmediate" in e,
    "msIndexedDB" in e,
    "msMaxTouchPoints" in t,
    "msPointerEnabled" in t
  ]) >= 4;
}
function Bee() {
  var e = window, t = navigator;
  return Tn(["msWriteProfilerMark" in e, "MSStream" in e, "msLaunchUri" in t, "msSaveBlob" in t]) >= 3 && !DE();
}
function Ep() {
  var e = window, t = navigator;
  return Tn([
    "webkitPersistentStorage" in t,
    "webkitTemporaryStorage" in t,
    t.vendor.indexOf("Google") === 0,
    "webkitResolveLocalFileSystemURL" in e,
    "BatteryManager" in e,
    "webkitMediaStream" in e,
    "webkitSpeechGrammar" in e
  ]) >= 5;
}
function Po() {
  var e = window, t = navigator;
  return Tn([
    "ApplePayError" in e,
    "CSSPrimitiveValue" in e,
    "Counter" in e,
    t.vendor.indexOf("Apple") === 0,
    "getStorageUpdates" in t,
    "WebKitMediaKeys" in e
  ]) >= 4;
}
function Ap() {
  var e = window;
  return Tn([
    "safari" in e,
    !("DeviceMotionEvent" in e),
    !("ongestureend" in e),
    !("standalone" in navigator)
  ]) >= 3;
}
function Nee() {
  var e, t, n = window;
  return Tn([
    "buildID" in navigator,
    "MozAppearance" in ((t = (e = document.documentElement) === null || e === void 0 ? void 0 : e.style) !== null && t !== void 0 ? t : {}),
    "onmozfullscreenchange" in n,
    "mozInnerScreenX" in n,
    "CSSMozDocumentRule" in n,
    "CanvasCaptureMediaStream" in n
  ]) >= 4;
}
function Lee() {
  var e = window;
  return Tn([
    !("MediaSettingsRange" in e),
    "RTCEncodedAudioFrame" in e,
    "" + e.Intl == "[object Intl]",
    "" + e.Reflect == "[object Reflect]"
  ]) >= 3;
}
function jee() {
  var e = window;
  return Tn([
    "DOMRectList" in e,
    "RTCPeerConnectionIceEvent" in e,
    "SVGGeometryElement" in e,
    "ontransitioncancel" in e
  ]) >= 3;
}
function zee() {
  if (navigator.platform === "iPad")
    return !0;
  var e = screen, t = e.width / e.height;
  return Tn([
    "MediaSource" in window,
    !!Element.prototype.webkitRequestFullscreen,
    // iPhone 4S that runs iOS 9 matches this. But it won't match the criteria above, so it won't be detected as iPad.
    t > 0.65 && t < 1.53
  ]) >= 2;
}
function Vee() {
  var e = document;
  return e.fullscreenElement || e.msFullscreenElement || e.mozFullScreenElement || e.webkitFullscreenElement || null;
}
function Hee() {
  var e = document;
  return (e.exitFullscreen || e.msExitFullscreen || e.mozCancelFullScreen || e.webkitExitFullscreen).call(e);
}
function SE() {
  var e = Ep(), t = Nee();
  if (!e && !t)
    return !1;
  var n = window;
  return Tn([
    "onorientationchange" in n,
    "orientation" in n,
    e && !("SharedWorker" in n),
    t && /android/i.test(navigator.appVersion)
  ]) >= 2;
}
function Wee() {
  var e = window, t = e.OfflineAudioContext || e.webkitOfflineAudioContext;
  if (!t)
    return -2;
  if (Uee())
    return -1;
  var n = 4500, r = 5e3, i = new t(1, r, 44100), s = i.createOscillator();
  s.type = "triangle", s.frequency.value = 1e4;
  var a = i.createDynamicsCompressor();
  a.threshold.value = -50, a.knee.value = 40, a.ratio.value = 12, a.attack.value = 0, a.release.value = 0.25, s.connect(a), a.connect(i.destination), s.start(0);
  var o = Yee(i), l = o[0], c = o[1], u = l.then(function(f) {
    return qee(f.getChannelData(0).subarray(n));
  }, function(f) {
    if (f.name === "timeout" || f.name === "suspended")
      return -3;
    throw f;
  });
  return vo(u), function() {
    return c(), u;
  };
}
function Uee() {
  return Po() && !Ap() && !jee();
}
function Yee(e) {
  var t = 3, n = 500, r = 500, i = 5e3, s = function() {
  }, a = new Promise(function(o, l) {
    var c = !1, u = 0, f = 0;
    e.oncomplete = function(p) {
      return o(p.renderedBuffer);
    };
    var d = function() {
      setTimeout(function() {
        return l(h1(
          "timeout"
          /* InnerErrorName.Timeout */
        ));
      }, Math.min(r, f + i - Date.now()));
    }, h = function() {
      try {
        var p = e.startRendering();
        switch (kE(p) && vo(p), e.state) {
          case "running":
            f = Date.now(), c && d();
            break;
          case "suspended":
            document.hidden || u++, c && u >= t ? l(h1(
              "suspended"
              /* InnerErrorName.Suspended */
            )) : setTimeout(h, n);
            break;
        }
      } catch (g) {
        l(g);
      }
    };
    h(), s = function() {
      c || (c = !0, f > 0 && d());
    };
  });
  return [a, s];
}
function qee(e) {
  for (var t = 0, n = 0; n < e.length; ++n)
    t += Math.abs(e[n]);
  return t;
}
function h1(e) {
  var t = new Error(e);
  return t.name = e, t;
}
function TE(e, t, n) {
  var r, i, s;
  return n === void 0 && (n = 50), vr(this, void 0, void 0, function() {
    var a, o;
    return mr(this, function(l) {
      switch (l.label) {
        case 0:
          a = document, l.label = 1;
        case 1:
          return a.body ? [3, 3] : [4, go(n)];
        case 2:
          return l.sent(), [3, 1];
        case 3:
          o = a.createElement("iframe"), l.label = 4;
        case 4:
          return l.trys.push([4, , 10, 11]), [4, new Promise(function(c, u) {
            var f = !1, d = function() {
              f = !0, c();
            }, h = function(v) {
              f = !0, u(v);
            };
            o.onload = d, o.onerror = h;
            var p = o.style;
            p.setProperty("display", "block", "important"), p.position = "absolute", p.top = "0", p.left = "0", p.visibility = "hidden", t && "srcdoc" in o ? o.srcdoc = t : o.src = "about:blank", a.body.appendChild(o);
            var g = function() {
              var v, m;
              f || (((m = (v = o.contentWindow) === null || v === void 0 ? void 0 : v.document) === null || m === void 0 ? void 0 : m.readyState) === "complete" ? d() : setTimeout(g, 10));
            };
            g();
          })];
        case 5:
          l.sent(), l.label = 6;
        case 6:
          return !((i = (r = o.contentWindow) === null || r === void 0 ? void 0 : r.document) === null || i === void 0) && i.body ? [3, 8] : [4, go(n)];
        case 7:
          return l.sent(), [3, 6];
        case 8:
          return [4, e(o, o.contentWindow)];
        case 9:
          return [2, l.sent()];
        case 10:
          return (s = o.parentNode) === null || s === void 0 || s.removeChild(o), [
            7
            /*endfinally*/
          ];
        case 11:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function Gee(e) {
  for (var t = Fee(e), n = t[0], r = t[1], i = document.createElement(n ?? "div"), s = 0, a = Object.keys(r); s < a.length; s++) {
    var o = a[s], l = r[o].join(" ");
    o === "style" ? Xee(i.style, l) : i.setAttribute(o, l);
  }
  return i;
}
function Xee(e, t) {
  for (var n = 0, r = t.split(";"); n < r.length; n++) {
    var i = r[n], s = /^\s*([\w-]+)\s*:\s*(.+?)(\s*!([\w-]+))?\s*$/.exec(i);
    if (s) {
      var a = s[1], o = s[2], l = s[4];
      e.setProperty(a, o, l || "");
    }
  }
}
var Zee = "mmMwWLliI0O&1", Kee = "48px", Zi = ["monospace", "sans-serif", "serif"], p1 = [
  // This is android-specific font from "Roboto" family
  "sans-serif-thin",
  "ARNO PRO",
  "Agency FB",
  "Arabic Typesetting",
  "Arial Unicode MS",
  "AvantGarde Bk BT",
  "BankGothic Md BT",
  "Batang",
  "Bitstream Vera Sans Mono",
  "Calibri",
  "Century",
  "Century Gothic",
  "Clarendon",
  "EUROSTILE",
  "Franklin Gothic",
  "Futura Bk BT",
  "Futura Md BT",
  "GOTHAM",
  "Gill Sans",
  "HELV",
  "Haettenschweiler",
  "Helvetica Neue",
  "Humanst521 BT",
  "Leelawadee",
  "Letter Gothic",
  "Levenim MT",
  "Lucida Bright",
  "Lucida Sans",
  "Menlo",
  "MS Mincho",
  "MS Outlook",
  "MS Reference Specialty",
  "MS UI Gothic",
  "MT Extra",
  "MYRIAD PRO",
  "Marlett",
  "Meiryo UI",
  "Microsoft Uighur",
  "Minion Pro",
  "Monotype Corsiva",
  "PMingLiU",
  "Pristina",
  "SCRIPTINA",
  "Segoe UI Light",
  "Serifa",
  "SimHei",
  "Small Fonts",
  "Staccato222 BT",
  "TRAJAN PRO",
  "Univers CE 55 Medium",
  "Vrinda",
  "ZWAdobeF"
];
function Jee() {
  return TE(function(e, t) {
    var n = t.document, r = n.body;
    r.style.fontSize = Kee;
    var i = n.createElement("div"), s = {}, a = {}, o = function(g) {
      var v = n.createElement("span"), m = v.style;
      return m.position = "absolute", m.top = "0", m.left = "0", m.fontFamily = g, v.textContent = Zee, i.appendChild(v), v;
    }, l = function(g, v) {
      return o("'".concat(g, "',").concat(v));
    }, c = function() {
      return Zi.map(o);
    }, u = function() {
      for (var g = {}, v = function(y) {
        g[y] = Zi.map(function(b) {
          return l(y, b);
        });
      }, m = 0, x = p1; m < x.length; m++) {
        var _ = x[m];
        v(_);
      }
      return g;
    }, f = function(g) {
      return Zi.some(function(v, m) {
        return g[m].offsetWidth !== s[v] || g[m].offsetHeight !== a[v];
      });
    }, d = c(), h = u();
    r.appendChild(i);
    for (var p = 0; p < Zi.length; p++)
      s[Zi[p]] = d[p].offsetWidth, a[Zi[p]] = d[p].offsetHeight;
    return p1.filter(function(g) {
      return f(h[g]);
    });
  });
}
function Qee() {
  var e = navigator.plugins;
  if (e) {
    for (var t = [], n = 0; n < e.length; ++n) {
      var r = e[n];
      if (r) {
        for (var i = [], s = 0; s < r.length; ++s) {
          var a = r[s];
          i.push({
            type: a.type,
            suffixes: a.suffixes
          });
        }
        t.push({
          name: r.name,
          description: r.description,
          mimeTypes: i
        });
      }
    }
    return t;
  }
}
function ete() {
  var e = !1, t, n, r = tte(), i = r[0], s = r[1];
  if (!nte(i, s))
    t = n = "";
  else {
    e = rte(s), ite(i, s);
    var a = dd(i), o = dd(i);
    a !== o ? t = n = "unstable" : (n = a, ste(i, s), t = dd(i));
  }
  return { winding: e, geometry: t, text: n };
}
function tte() {
  var e = document.createElement("canvas");
  return e.width = 1, e.height = 1, [e, e.getContext("2d")];
}
function nte(e, t) {
  return !!(t && e.toDataURL);
}
function rte(e) {
  return e.rect(0, 0, 10, 10), e.rect(2, 2, 6, 6), !e.isPointInPath(5, 5, "evenodd");
}
function ite(e, t) {
  e.width = 240, e.height = 60, t.textBaseline = "alphabetic", t.fillStyle = "#f60", t.fillRect(100, 1, 62, 20), t.fillStyle = "#069", t.font = '11pt "Times New Roman"';
  var n = "Cwm fjordbank gly ".concat(
    "😃"
    /* 😃 */
  );
  t.fillText(n, 2, 15), t.fillStyle = "rgba(102, 204, 0, 0.2)", t.font = "18pt Arial", t.fillText(n, 4, 45);
}
function ste(e, t) {
  e.width = 122, e.height = 110, t.globalCompositeOperation = "multiply";
  for (var n = 0, r = [
    ["#f2f", 40, 40],
    ["#2ff", 80, 40],
    ["#ff2", 60, 80]
  ]; n < r.length; n++) {
    var i = r[n], s = i[0], a = i[1], o = i[2];
    t.fillStyle = s, t.beginPath(), t.arc(a, o, 40, 0, Math.PI * 2, !0), t.closePath(), t.fill();
  }
  t.fillStyle = "#f9c", t.arc(60, 60, 60, 0, Math.PI * 2, !0), t.arc(60, 60, 20, 0, Math.PI * 2, !0), t.fill("evenodd");
}
function dd(e) {
  return e.toDataURL();
}
function ate() {
  var e = navigator, t = 0, n;
  e.maxTouchPoints !== void 0 ? t = $p(e.maxTouchPoints) : e.msMaxTouchPoints !== void 0 && (t = e.msMaxTouchPoints);
  try {
    document.createEvent("TouchEvent"), n = !0;
  } catch {
    n = !1;
  }
  var r = "ontouchstart" in window;
  return {
    maxTouchPoints: t,
    touchEvent: n,
    touchStart: r
  };
}
function ote() {
  return navigator.oscpu;
}
function lte() {
  var e = navigator, t = [], n = e.language || e.userLanguage || e.browserLanguage || e.systemLanguage;
  if (n !== void 0 && t.push([n]), Array.isArray(e.languages))
    Ep() && Lee() || t.push(e.languages);
  else if (typeof e.languages == "string") {
    var r = e.languages;
    r && t.push(r.split(","));
  }
  return t;
}
function cte() {
  return window.screen.colorDepth;
}
function ute() {
  return Qn($n(navigator.deviceMemory), void 0);
}
function fte() {
  var e = screen, t = function(r) {
    return Qn($p(r), null);
  }, n = [t(e.width), t(e.height)];
  return n.sort().reverse(), n;
}
var dte = 2500, hte = 10, Yl, hd;
function pte() {
  if (hd === void 0) {
    var e = function() {
      var t = E0();
      A0(t) ? hd = setTimeout(e, dte) : (Yl = t, hd = void 0);
    };
    e();
  }
}
function gte() {
  var e = this;
  return pte(), function() {
    return vr(e, void 0, void 0, function() {
      var t;
      return mr(this, function(n) {
        switch (n.label) {
          case 0:
            return t = E0(), A0(t) ? Yl ? [2, EE([], Yl, !0)] : Vee() ? [4, Hee()] : [3, 2] : [3, 2];
          case 1:
            n.sent(), t = E0(), n.label = 2;
          case 2:
            return A0(t) || (Yl = t), [2, t];
        }
      });
    });
  };
}
function vte() {
  var e = this, t = gte();
  return function() {
    return vr(e, void 0, void 0, function() {
      var n, r;
      return mr(this, function(i) {
        switch (i.label) {
          case 0:
            return [4, t()];
          case 1:
            return n = i.sent(), r = function(s) {
              return s === null ? null : CE(s, hte);
            }, [2, [r(n[0]), r(n[1]), r(n[2]), r(n[3])]];
        }
      });
    });
  };
}
function E0() {
  var e = screen;
  return [
    Qn($n(e.availTop), null),
    Qn($n(e.width) - $n(e.availWidth) - Qn($n(e.availLeft), 0), null),
    Qn($n(e.height) - $n(e.availHeight) - Qn($n(e.availTop), 0), null),
    Qn($n(e.availLeft), null)
  ];
}
function A0(e) {
  for (var t = 0; t < 4; ++t)
    if (e[t])
      return !1;
  return !0;
}
function mte() {
  return Qn($p(navigator.hardwareConcurrency), void 0);
}
function yte() {
  var e, t = (e = window.Intl) === null || e === void 0 ? void 0 : e.DateTimeFormat;
  if (t) {
    var n = new t().resolvedOptions().timeZone;
    if (n)
      return n;
  }
  var r = -xte();
  return "UTC".concat(r >= 0 ? "+" : "").concat(Math.abs(r));
}
function xte() {
  var e = (/* @__PURE__ */ new Date()).getFullYear();
  return Math.max(
    // `getTimezoneOffset` returns a number as a string in some unidentified cases
    $n(new Date(e, 0, 1).getTimezoneOffset()),
    $n(new Date(e, 6, 1).getTimezoneOffset())
  );
}
function bte() {
  try {
    return !!window.sessionStorage;
  } catch {
    return !0;
  }
}
function _te() {
  try {
    return !!window.localStorage;
  } catch {
    return !0;
  }
}
function wte() {
  if (!(DE() || Bee()))
    try {
      return !!window.indexedDB;
    } catch {
      return !0;
    }
}
function $te() {
  return !!window.openDatabase;
}
function Ete() {
  return navigator.cpuClass;
}
function Ate() {
  var e = navigator.platform;
  return e === "MacIntel" && Po() && !Ap() ? zee() ? "iPad" : "iPhone" : e;
}
function kte() {
  return navigator.vendor || "";
}
function Cte() {
  for (var e = [], t = 0, n = [
    // Blink and some browsers on iOS
    "chrome",
    // Safari on macOS
    "safari",
    // Chrome on iOS (checked in 85 on 13 and 87 on 14)
    "__crWeb",
    "__gCrWeb",
    // Yandex Browser on iOS, macOS and Android (checked in 21.2 on iOS 14, macOS and Android)
    "yandex",
    // Yandex Browser on iOS (checked in 21.2 on 14)
    "__yb",
    "__ybro",
    // Firefox on iOS (checked in 32 on 14)
    "__firefox__",
    // Edge on iOS (checked in 46 on 14)
    "__edgeTrackingPreventionStatistics",
    "webkit",
    // Opera Touch on iOS (checked in 2.6 on 14)
    "oprt",
    // Samsung Internet on Android (checked in 11.1)
    "samsungAr",
    // UC Browser on Android (checked in 12.10 and 13.0)
    "ucweb",
    "UCShellJava",
    // Puffin on Android (checked in 9.0)
    "puffinDevice"
    // UC on iOS and Opera on Android have no specific global variables
    // Edge for Android isn't checked
  ]; t < n.length; t++) {
    var r = n[t], i = window[r];
    i && typeof i == "object" && e.push(r);
  }
  return e.sort();
}
function Dte() {
  var e = document;
  try {
    e.cookie = "cookietest=1; SameSite=Strict;";
    var t = e.cookie.indexOf("cookietest=") !== -1;
    return e.cookie = "cookietest=1; SameSite=Strict; expires=Thu, 01-Jan-1970 00:00:01 GMT", t;
  } catch {
    return !1;
  }
}
function Ste() {
  var e = atob;
  return {
    abpIndo: [
      "#Iklan-Melayang",
      "#Kolom-Iklan-728",
      "#SidebarIklan-wrapper",
      '[title="ALIENBOLA" i]',
      e("I0JveC1CYW5uZXItYWRz")
    ],
    abpvn: [".quangcao", "#mobileCatfish", e("LmNsb3NlLWFkcw=="), '[id^="bn_bottom_fixed_"]', "#pmadv"],
    adBlockFinland: [
      ".mainostila",
      e("LnNwb25zb3JpdA=="),
      ".ylamainos",
      e("YVtocmVmKj0iL2NsaWNrdGhyZ2guYXNwPyJd"),
      e("YVtocmVmXj0iaHR0cHM6Ly9hcHAucmVhZHBlYWsuY29tL2FkcyJd")
    ],
    adBlockPersian: [
      "#navbar_notice_50",
      ".kadr",
      'TABLE[width="140px"]',
      "#divAgahi",
      e("YVtocmVmXj0iaHR0cDovL2cxLnYuZndtcm0ubmV0L2FkLyJd")
    ],
    adBlockWarningRemoval: [
      "#adblock-honeypot",
      ".adblocker-root",
      ".wp_adblock_detect",
      e("LmhlYWRlci1ibG9ja2VkLWFk"),
      e("I2FkX2Jsb2NrZXI=")
    ],
    adGuardAnnoyances: [
      ".hs-sosyal",
      "#cookieconsentdiv",
      'div[class^="app_gdpr"]',
      ".as-oil",
      '[data-cypress="soft-push-notification-modal"]'
    ],
    adGuardBase: [
      ".BetterJsPopOverlay",
      e("I2FkXzMwMFgyNTA="),
      e("I2Jhbm5lcmZsb2F0MjI="),
      e("I2NhbXBhaWduLWJhbm5lcg=="),
      e("I0FkLUNvbnRlbnQ=")
    ],
    adGuardChinese: [
      e("LlppX2FkX2FfSA=="),
      e("YVtocmVmKj0iLmh0aGJldDM0LmNvbSJd"),
      "#widget-quan",
      e("YVtocmVmKj0iLzg0OTkyMDIwLnh5eiJd"),
      e("YVtocmVmKj0iLjE5NTZobC5jb20vIl0=")
    ],
    adGuardFrench: [
      "#pavePub",
      e("LmFkLWRlc2t0b3AtcmVjdGFuZ2xl"),
      ".mobile_adhesion",
      ".widgetadv",
      e("LmFkc19iYW4=")
    ],
    adGuardGerman: ['aside[data-portal-id="leaderboard"]'],
    adGuardJapanese: [
      "#kauli_yad_1",
      e("YVtocmVmXj0iaHR0cDovL2FkMi50cmFmZmljZ2F0ZS5uZXQvIl0="),
      e("Ll9wb3BJbl9pbmZpbml0ZV9hZA=="),
      e("LmFkZ29vZ2xl"),
      e("Ll9faXNib29zdFJldHVybkFk")
    ],
    adGuardMobile: [
      e("YW1wLWF1dG8tYWRz"),
      e("LmFtcF9hZA=="),
      'amp-embed[type="24smi"]',
      "#mgid_iframe1",
      e("I2FkX2ludmlld19hcmVh")
    ],
    adGuardRussian: [
      e("YVtocmVmXj0iaHR0cHM6Ly9hZC5sZXRtZWFkcy5jb20vIl0="),
      e("LnJlY2xhbWE="),
      'div[id^="smi2adblock"]',
      e("ZGl2W2lkXj0iQWRGb3hfYmFubmVyXyJd"),
      "#psyduckpockeball"
    ],
    adGuardSocial: [
      e("YVtocmVmXj0iLy93d3cuc3R1bWJsZXVwb24uY29tL3N1Ym1pdD91cmw9Il0="),
      e("YVtocmVmXj0iLy90ZWxlZ3JhbS5tZS9zaGFyZS91cmw/Il0="),
      ".etsy-tweet",
      "#inlineShare",
      ".popup-social"
    ],
    adGuardSpanishPortuguese: ["#barraPublicidade", "#Publicidade", "#publiEspecial", "#queTooltip", ".cnt-publi"],
    adGuardTrackingProtection: [
      "#qoo-counter",
      e("YVtocmVmXj0iaHR0cDovL2NsaWNrLmhvdGxvZy5ydS8iXQ=="),
      e("YVtocmVmXj0iaHR0cDovL2hpdGNvdW50ZXIucnUvdG9wL3N0YXQucGhwIl0="),
      e("YVtocmVmXj0iaHR0cDovL3RvcC5tYWlsLnJ1L2p1bXAiXQ=="),
      "#top100counter"
    ],
    adGuardTurkish: [
      "#backkapat",
      e("I3Jla2xhbWk="),
      e("YVtocmVmXj0iaHR0cDovL2Fkc2Vydi5vbnRlay5jb20udHIvIl0="),
      e("YVtocmVmXj0iaHR0cDovL2l6bGVuemkuY29tL2NhbXBhaWduLyJd"),
      e("YVtocmVmXj0iaHR0cDovL3d3dy5pbnN0YWxsYWRzLm5ldC8iXQ==")
    ],
    bulgarian: [e("dGQjZnJlZW5ldF90YWJsZV9hZHM="), "#ea_intext_div", ".lapni-pop-over", "#xenium_hot_offers"],
    easyList: [
      ".yb-floorad",
      e("LndpZGdldF9wb19hZHNfd2lkZ2V0"),
      e("LnRyYWZmaWNqdW5reS1hZA=="),
      ".textad_headline",
      e("LnNwb25zb3JlZC10ZXh0LWxpbmtz")
    ],
    easyListChina: [
      e("LmFwcGd1aWRlLXdyYXBbb25jbGljayo9ImJjZWJvcy5jb20iXQ=="),
      e("LmZyb250cGFnZUFkdk0="),
      "#taotaole",
      "#aafoot.top_box",
      ".cfa_popup"
    ],
    easyListCookie: [
      ".ezmob-footer",
      ".cc-CookieWarning",
      "[data-cookie-number]",
      e("LmF3LWNvb2tpZS1iYW5uZXI="),
      ".sygnal24-gdpr-modal-wrap"
    ],
    easyListCzechSlovak: [
      "#onlajny-stickers",
      e("I3Jla2xhbW5pLWJveA=="),
      e("LnJla2xhbWEtbWVnYWJvYXJk"),
      ".sklik",
      e("W2lkXj0ic2tsaWtSZWtsYW1hIl0=")
    ],
    easyListDutch: [
      e("I2FkdmVydGVudGll"),
      e("I3ZpcEFkbWFya3RCYW5uZXJCbG9jaw=="),
      ".adstekst",
      e("YVtocmVmXj0iaHR0cHM6Ly94bHR1YmUubmwvY2xpY2svIl0="),
      "#semilo-lrectangle"
    ],
    easyListGermany: [
      "#SSpotIMPopSlider",
      e("LnNwb25zb3JsaW5rZ3J1ZW4="),
      e("I3dlcmJ1bmdza3k="),
      e("I3Jla2xhbWUtcmVjaHRzLW1pdHRl"),
      e("YVtocmVmXj0iaHR0cHM6Ly9iZDc0Mi5jb20vIl0=")
    ],
    easyListItaly: [
      e("LmJveF9hZHZfYW5udW5jaQ=="),
      ".sb-box-pubbliredazionale",
      e("YVtocmVmXj0iaHR0cDovL2FmZmlsaWF6aW9uaWFkcy5zbmFpLml0LyJd"),
      e("YVtocmVmXj0iaHR0cHM6Ly9hZHNlcnZlci5odG1sLml0LyJd"),
      e("YVtocmVmXj0iaHR0cHM6Ly9hZmZpbGlhemlvbmlhZHMuc25haS5pdC8iXQ==")
    ],
    easyListLithuania: [
      e("LnJla2xhbW9zX3RhcnBhcw=="),
      e("LnJla2xhbW9zX251b3JvZG9z"),
      e("aW1nW2FsdD0iUmVrbGFtaW5pcyBza3lkZWxpcyJd"),
      e("aW1nW2FsdD0iRGVkaWt1b3RpLmx0IHNlcnZlcmlhaSJd"),
      e("aW1nW2FsdD0iSG9zdGluZ2FzIFNlcnZlcmlhaS5sdCJd")
    ],
    estonian: [e("QVtocmVmKj0iaHR0cDovL3BheTRyZXN1bHRzMjQuZXUiXQ==")],
    fanboyAnnoyances: ["#ac-lre-player", ".navigate-to-top", "#subscribe_popup", ".newsletter_holder", "#back-top"],
    fanboyAntiFacebook: [".util-bar-module-firefly-visible"],
    fanboyEnhancedTrackers: [
      ".open.pushModal",
      "#issuem-leaky-paywall-articles-zero-remaining-nag",
      "#sovrn_container",
      'div[class$="-hide"][zoompage-fontsize][style="display: block;"]',
      ".BlockNag__Card"
    ],
    fanboySocial: ["#FollowUs", "#meteored_share", "#social_follow", ".article-sharer", ".community__social-desc"],
    frellwitSwedish: [
      e("YVtocmVmKj0iY2FzaW5vcHJvLnNlIl1bdGFyZ2V0PSJfYmxhbmsiXQ=="),
      e("YVtocmVmKj0iZG9rdG9yLXNlLm9uZWxpbmsubWUiXQ=="),
      "article.category-samarbete",
      e("ZGl2LmhvbGlkQWRz"),
      "ul.adsmodern"
    ],
    greekAdBlock: [
      e("QVtocmVmKj0iYWRtYW4ub3RlbmV0LmdyL2NsaWNrPyJd"),
      e("QVtocmVmKj0iaHR0cDovL2F4aWFiYW5uZXJzLmV4b2R1cy5nci8iXQ=="),
      e("QVtocmVmKj0iaHR0cDovL2ludGVyYWN0aXZlLmZvcnRobmV0LmdyL2NsaWNrPyJd"),
      "DIV.agores300",
      "TABLE.advright"
    ],
    hungarian: [
      "#cemp_doboz",
      ".optimonk-iframe-container",
      e("LmFkX19tYWlu"),
      e("W2NsYXNzKj0iR29vZ2xlQWRzIl0="),
      "#hirdetesek_box"
    ],
    iDontCareAboutCookies: [
      '.alert-info[data-block-track*="CookieNotice"]',
      ".ModuleTemplateCookieIndicator",
      ".o--cookies--container",
      "#cookies-policy-sticky",
      "#stickyCookieBar"
    ],
    icelandicAbp: [e("QVtocmVmXj0iL2ZyYW1ld29yay9yZXNvdXJjZXMvZm9ybXMvYWRzLmFzcHgiXQ==")],
    latvian: [
      e("YVtocmVmPSJodHRwOi8vd3d3LnNhbGlkemluaS5sdi8iXVtzdHlsZT0iZGlzcGxheTogYmxvY2s7IHdpZHRoOiAxMjBweDsgaGVpZ2h0OiA0MHB4OyBvdmVyZmxvdzogaGlkZGVuOyBwb3NpdGlvbjogcmVsYXRpdmU7Il0="),
      e("YVtocmVmPSJodHRwOi8vd3d3LnNhbGlkemluaS5sdi8iXVtzdHlsZT0iZGlzcGxheTogYmxvY2s7IHdpZHRoOiA4OHB4OyBoZWlnaHQ6IDMxcHg7IG92ZXJmbG93OiBoaWRkZW47IHBvc2l0aW9uOiByZWxhdGl2ZTsiXQ==")
    ],
    listKr: [
      e("YVtocmVmKj0iLy9hZC5wbGFuYnBsdXMuY28ua3IvIl0="),
      e("I2xpdmVyZUFkV3JhcHBlcg=="),
      e("YVtocmVmKj0iLy9hZHYuaW1hZHJlcC5jby5rci8iXQ=="),
      e("aW5zLmZhc3R2aWV3LWFk"),
      ".revenue_unit_item.dable"
    ],
    listeAr: [
      e("LmdlbWluaUxCMUFk"),
      ".right-and-left-sponsers",
      e("YVtocmVmKj0iLmFmbGFtLmluZm8iXQ=="),
      e("YVtocmVmKj0iYm9vcmFxLm9yZyJd"),
      e("YVtocmVmKj0iZHViaXp6bGUuY29tL2FyLz91dG1fc291cmNlPSJd")
    ],
    listeFr: [
      e("YVtocmVmXj0iaHR0cDovL3Byb21vLnZhZG9yLmNvbS8iXQ=="),
      e("I2FkY29udGFpbmVyX3JlY2hlcmNoZQ=="),
      e("YVtocmVmKj0id2Vib3JhbWEuZnIvZmNnaS1iaW4vIl0="),
      ".site-pub-interstitiel",
      'div[id^="crt-"][data-criteo-id]'
    ],
    officialPolish: [
      "#ceneo-placeholder-ceneo-12",
      e("W2hyZWZePSJodHRwczovL2FmZi5zZW5kaHViLnBsLyJd"),
      e("YVtocmVmXj0iaHR0cDovL2Fkdm1hbmFnZXIudGVjaGZ1bi5wbC9yZWRpcmVjdC8iXQ=="),
      e("YVtocmVmXj0iaHR0cDovL3d3dy50cml6ZXIucGwvP3V0bV9zb3VyY2UiXQ=="),
      e("ZGl2I3NrYXBpZWNfYWQ=")
    ],
    ro: [
      e("YVtocmVmXj0iLy9hZmZ0cmsuYWx0ZXgucm8vQ291bnRlci9DbGljayJd"),
      e("YVtocmVmXj0iaHR0cHM6Ly9ibGFja2ZyaWRheXNhbGVzLnJvL3Ryay9zaG9wLyJd"),
      e("YVtocmVmXj0iaHR0cHM6Ly9ldmVudC4ycGVyZm9ybWFudC5jb20vZXZlbnRzL2NsaWNrIl0="),
      e("YVtocmVmXj0iaHR0cHM6Ly9sLnByb2ZpdHNoYXJlLnJvLyJd"),
      'a[href^="/url/"]'
    ],
    ruAd: [
      e("YVtocmVmKj0iLy9mZWJyYXJlLnJ1LyJd"),
      e("YVtocmVmKj0iLy91dGltZy5ydS8iXQ=="),
      e("YVtocmVmKj0iOi8vY2hpa2lkaWtpLnJ1Il0="),
      "#pgeldiz",
      ".yandex-rtb-block"
    ],
    thaiAds: [
      "a[href*=macau-uta-popup]",
      e("I2Fkcy1nb29nbGUtbWlkZGxlX3JlY3RhbmdsZS1ncm91cA=="),
      e("LmFkczMwMHM="),
      ".bumq",
      ".img-kosana"
    ],
    webAnnoyancesUltralist: [
      "#mod-social-share-2",
      "#social-tools",
      e("LmN0cGwtZnVsbGJhbm5lcg=="),
      ".zergnet-recommend",
      ".yt.btn-link.btn-md.btn"
    ]
  };
}
function Tte(e) {
  var t = e === void 0 ? {} : e, n = t.debug;
  return vr(this, void 0, void 0, function() {
    var r, i, s, a, o, l;
    return mr(this, function(c) {
      switch (c.label) {
        case 0:
          return Ote() ? (r = Ste(), i = Object.keys(r), s = (l = []).concat.apply(l, i.map(function(u) {
            return r[u];
          })), [4, Mte(s)]) : [2, void 0];
        case 1:
          return a = c.sent(), n && Fte(r, a), o = i.filter(function(u) {
            var f = r[u], d = Tn(f.map(function(h) {
              return a[h];
            }));
            return d > f.length * 0.6;
          }), o.sort(), [2, o];
      }
    });
  });
}
function Ote() {
  return Po() || SE();
}
function Mte(e) {
  var t;
  return vr(this, void 0, void 0, function() {
    var n, r, i, s, l, a, o, l;
    return mr(this, function(c) {
      switch (c.label) {
        case 0:
          for (n = document, r = n.createElement("div"), i = new Array(e.length), s = {}, g1(r), l = 0; l < e.length; ++l)
            a = Gee(e[l]), a.tagName === "DIALOG" && a.show(), o = n.createElement("div"), g1(o), o.appendChild(a), r.appendChild(o), i[l] = a;
          c.label = 1;
        case 1:
          return n.body ? [3, 3] : [4, go(50)];
        case 2:
          return c.sent(), [3, 1];
        case 3:
          n.body.appendChild(r);
          try {
            for (l = 0; l < e.length; ++l)
              i[l].offsetParent || (s[e[l]] = !0);
          } finally {
            (t = r.parentNode) === null || t === void 0 || t.removeChild(r);
          }
          return [2, s];
      }
    });
  });
}
function g1(e) {
  e.style.setProperty("display", "block", "important");
}
function Fte(e, t) {
  for (var n = "DOM blockers debug:\n```", r = 0, i = Object.keys(e); r < i.length; r++) {
    var s = i[r];
    n += `
`.concat(s, ":");
    for (var a = 0, o = e[s]; a < o.length; a++) {
      var l = o[a];
      n += `
  `.concat(t[l] ? "🚫" : "➡️", " ").concat(l);
    }
  }
  console.log("".concat(n, "\n```"));
}
function Pte() {
  for (var e = 0, t = ["rec2020", "p3", "srgb"]; e < t.length; e++) {
    var n = t[e];
    if (matchMedia("(color-gamut: ".concat(n, ")")).matches)
      return n;
  }
}
function Ite() {
  if (v1("inverted"))
    return !0;
  if (v1("none"))
    return !1;
}
function v1(e) {
  return matchMedia("(inverted-colors: ".concat(e, ")")).matches;
}
function Rte() {
  if (m1("active"))
    return !0;
  if (m1("none"))
    return !1;
}
function m1(e) {
  return matchMedia("(forced-colors: ".concat(e, ")")).matches;
}
var Bte = 100;
function Nte() {
  if (matchMedia("(min-monochrome: 0)").matches) {
    for (var e = 0; e <= Bte; ++e)
      if (matchMedia("(max-monochrome: ".concat(e, ")")).matches)
        return e;
    throw new Error("Too high value");
  }
}
function Lte() {
  if (Ki("no-preference"))
    return 0;
  if (Ki("high") || Ki("more"))
    return 1;
  if (Ki("low") || Ki("less"))
    return -1;
  if (Ki("forced"))
    return 10;
}
function Ki(e) {
  return matchMedia("(prefers-contrast: ".concat(e, ")")).matches;
}
function jte() {
  if (y1("reduce"))
    return !0;
  if (y1("no-preference"))
    return !1;
}
function y1(e) {
  return matchMedia("(prefers-reduced-motion: ".concat(e, ")")).matches;
}
function zte() {
  if (x1("high"))
    return !0;
  if (x1("standard"))
    return !1;
}
function x1(e) {
  return matchMedia("(dynamic-range: ".concat(e, ")")).matches;
}
var Pe = Math, Ut = function() {
  return 0;
};
function Vte() {
  var e = Pe.acos || Ut, t = Pe.acosh || Ut, n = Pe.asin || Ut, r = Pe.asinh || Ut, i = Pe.atanh || Ut, s = Pe.atan || Ut, a = Pe.sin || Ut, o = Pe.sinh || Ut, l = Pe.cos || Ut, c = Pe.cosh || Ut, u = Pe.tan || Ut, f = Pe.tanh || Ut, d = Pe.exp || Ut, h = Pe.expm1 || Ut, p = Pe.log1p || Ut, g = function($) {
    return Pe.pow(Pe.PI, $);
  }, v = function($) {
    return Pe.log($ + Pe.sqrt($ * $ - 1));
  }, m = function($) {
    return Pe.log($ + Pe.sqrt($ * $ + 1));
  }, x = function($) {
    return Pe.log((1 + $) / (1 - $)) / 2;
  }, _ = function($) {
    return Pe.exp($) - 1 / Pe.exp($) / 2;
  }, y = function($) {
    return (Pe.exp($) + 1 / Pe.exp($)) / 2;
  }, b = function($) {
    return Pe.exp($) - 1;
  }, w = function($) {
    return (Pe.exp(2 * $) - 1) / (Pe.exp(2 * $) + 1);
  }, E = function($) {
    return Pe.log(1 + $);
  };
  return {
    acos: e(0.12312423423423424),
    acosh: t(1e308),
    acoshPf: v(1e154),
    asin: n(0.12312423423423424),
    asinh: r(1),
    asinhPf: m(1),
    atanh: i(0.5),
    atanhPf: x(0.5),
    atan: s(0.5),
    sin: a(-1e300),
    sinh: o(1),
    sinhPf: _(1),
    cos: l(10.000000000123),
    cosh: c(1),
    coshPf: y(1),
    tan: u(-1e300),
    tanh: f(1),
    tanhPf: w(1),
    exp: d(1),
    expm1: h(1),
    expm1Pf: b(1),
    log1p: p(10),
    log1pPf: E(10),
    powPI: g(-100)
  };
}
var Hte = "mmMwWLliI0fiflO&1", pd = {
  /**
   * The default font. User can change it in desktop Chrome, desktop Firefox, IE 11,
   * Android Chrome (but only when the size is ≥ than the default) and Android Firefox.
   */
  default: [],
  /** OS font on macOS. User can change its size and weight. Applies after Safari restart. */
  apple: [{ font: "-apple-system-body" }],
  /** User can change it in desktop Chrome and desktop Firefox. */
  serif: [{ fontFamily: "serif" }],
  /** User can change it in desktop Chrome and desktop Firefox. */
  sans: [{ fontFamily: "sans-serif" }],
  /** User can change it in desktop Chrome and desktop Firefox. */
  mono: [{ fontFamily: "monospace" }],
  /**
   * Check the smallest allowed font size. User can change it in desktop Chrome, desktop Firefox and desktop Safari.
   * The height can be 0 in Chrome on a retina display.
   */
  min: [{ fontSize: "1px" }],
  /** Tells one OS from another in desktop Chrome. */
  system: [{ fontFamily: "system-ui" }]
};
function Wte() {
  return Ute(function(e, t) {
    for (var n = {}, r = {}, i = 0, s = Object.keys(pd); i < s.length; i++) {
      var a = s[i], o = pd[a], l = o[0], c = l === void 0 ? {} : l, u = o[1], f = u === void 0 ? Hte : u, d = e.createElement("span");
      d.textContent = f, d.style.whiteSpace = "nowrap";
      for (var h = 0, p = Object.keys(c); h < p.length; h++) {
        var g = p[h], v = c[g];
        v !== void 0 && (d.style[g] = v);
      }
      n[a] = d, t.appendChild(e.createElement("br")), t.appendChild(d);
    }
    for (var m = 0, x = Object.keys(pd); m < x.length; m++) {
      var a = x[m];
      r[a] = n[a].getBoundingClientRect().width;
    }
    return r;
  });
}
function Ute(e, t) {
  return t === void 0 && (t = 4e3), TE(function(n, r) {
    var i = r.document, s = i.body, a = s.style;
    a.width = "".concat(t, "px"), a.webkitTextSizeAdjust = a.textSizeAdjust = "none", Ep() ? s.style.zoom = "".concat(1 / r.devicePixelRatio) : Po() && (s.style.zoom = "reset");
    var o = i.createElement("div");
    return o.textContent = EE([], Array(t / 20 << 0), !0).map(function() {
      return "word";
    }).join(" "), s.appendChild(o), e(i, s);
  }, '<!doctype html><html><head><meta name="viewport" content="width=device-width, initial-scale=1">');
}
function Yte() {
  var e, t = document.createElement("canvas"), n = (e = t.getContext("webgl")) !== null && e !== void 0 ? e : t.getContext("experimental-webgl");
  if (n && "getExtension" in n) {
    var r = n.getExtension("WEBGL_debug_renderer_info");
    if (r)
      return {
        vendor: (n.getParameter(r.UNMASKED_VENDOR_WEBGL) || "").toString(),
        renderer: (n.getParameter(r.UNMASKED_RENDERER_WEBGL) || "").toString()
      };
  }
}
function qte() {
  return navigator.pdfViewerEnabled;
}
function Gte() {
  var e = new Float32Array(1), t = new Uint8Array(e.buffer);
  return e[0] = 1 / 0, e[0] = e[0] - e[0], t[3];
}
var Xte = {
  // READ FIRST:
  // See https://github.com/fingerprintjs/fingerprintjs/blob/master/contributing.md#how-to-make-an-entropy-source
  // to learn how entropy source works and how to make your own.
  // The sources run in this exact order.
  // The asynchronous sources are at the start to run in parallel with other sources.
  fonts: Jee,
  domBlockers: Tte,
  fontPreferences: Wte,
  audio: Wee,
  screenFrame: vte,
  osCpu: ote,
  languages: lte,
  colorDepth: cte,
  deviceMemory: ute,
  screenResolution: fte,
  hardwareConcurrency: mte,
  timezone: yte,
  sessionStorage: bte,
  localStorage: _te,
  indexedDB: wte,
  openDatabase: $te,
  cpuClass: Ete,
  platform: Ate,
  plugins: Qee,
  canvas: ete,
  touchSupport: ate,
  vendor: kte,
  vendorFlavors: Cte,
  cookiesEnabled: Dte,
  colorGamut: Pte,
  invertedColors: Ite,
  forcedColors: Rte,
  monochrome: Nte,
  contrast: Lte,
  reducedMotion: jte,
  hdr: zte,
  math: Vte,
  videoCard: Yte,
  pdfViewerEnabled: qte,
  architecture: Gte
};
function Zte(e) {
  return Ree(Xte, e, []);
}
var Kte = "$ if upgrade to Pro: https://fpjs.dev/pro";
function Jte(e) {
  var t = Qte(e), n = ene(t);
  return { score: t, comment: Kte.replace(/\$/g, "".concat(n)) };
}
function Qte(e) {
  if (SE())
    return 0.4;
  if (Po())
    return Ap() ? 0.5 : 0.3;
  var t = e.platform.value || "";
  return /^Win/.test(t) ? 0.6 : /^Mac/.test(t) ? 0.5 : 0.7;
}
function ene(e) {
  return CE(0.99 + 0.01 * e, 1e-4);
}
function tne(e) {
  for (var t = "", n = 0, r = Object.keys(e).sort(); n < r.length; n++) {
    var i = r[n], s = e[i], a = s.error ? "error" : JSON.stringify(s.value);
    t += "".concat(t ? "|" : "").concat(i.replace(/([:|\\])/g, "\\$1"), ":").concat(a);
  }
  return t;
}
function OE(e) {
  return JSON.stringify(e, function(t, n) {
    return n instanceof Error ? Tee(n) : n;
  }, 2);
}
function ME(e) {
  return See(tne(e));
}
function nne(e) {
  var t, n = Jte(e);
  return {
    get visitorId() {
      return t === void 0 && (t = ME(this.components)), t;
    },
    set visitorId(r) {
      t = r;
    },
    confidence: n,
    components: e,
    version: AE
  };
}
function rne(e) {
  return e === void 0 && (e = 50), Dee(e, e * 2);
}
function ine(e, t) {
  var n = Date.now();
  return {
    get: function(r) {
      return vr(this, void 0, void 0, function() {
        var i, s, a;
        return mr(this, function(o) {
          switch (o.label) {
            case 0:
              return i = Date.now(), [4, e()];
            case 1:
              return s = o.sent(), a = nne(s), (t || r != null && r.debug) && console.log("Copy the text below to get the debug data:\n\n```\nversion: ".concat(a.version, `
userAgent: `).concat(navigator.userAgent, `
timeBetweenLoadAndGet: `).concat(i - n, `
visitorId: `).concat(a.visitorId, `
components: `).concat(OE(s), "\n```")), [2, a];
          }
        });
      });
    }
  };
}
function sne() {
  if (!(window.__fpjs_d_m || Math.random() >= 1e-3))
    try {
      var e = new XMLHttpRequest();
      e.open("get", "https://m1.openfpcdn.io/fingerprintjs/v".concat(AE, "/npm-monitoring"), !0), e.send();
    } catch (t) {
      console.error(t);
    }
}
function ane(e) {
  var t = e === void 0 ? {} : e, n = t.delayFallback, r = t.debug, i = t.monitoring, s = i === void 0 ? !0 : i;
  return vr(this, void 0, void 0, function() {
    var a;
    return mr(this, function(o) {
      switch (o.label) {
        case 0:
          return s && sne(), [4, rne(n)];
        case 1:
          return o.sent(), a = Zte({ debug: r }), [2, ine(a, r)];
      }
    });
  });
}
var k0 = { load: ane, hashComponents: ME, componentsToDebugString: OE };
class one {
  constructor(t) {
    V(this, "params");
    V(this, "messages", []);
    V(this, "fingerId", "");
    V(this, "visitorId", Lr.createUuid());
    V(this, "jobsQueue", new Jc({
      concurrentExecutions: 1
    }));
    this.params = t;
  }
  get size() {
    return this.messages.length;
  }
  clearMessages() {
    const t = this.messages.slice(-this.params.limitSize);
    return this.messages = [], t;
  }
  collect(t) {
    const n = Ye();
    this.messages.push({
      ...t,
      url: n.location.href,
      time: Date.now()
    });
  }
  send() {
    this.jobsQueue.push("send", async () => {
      if (this.fingerId === "") {
        const s = await (await k0.load()).get();
        this.fingerId = s.visitorId;
      }
      const t = No(), n = this.clearMessages(), r = {
        fingerId: this.fingerId,
        clientId: this.params.clientId(),
        visitorId: this.visitorId,
        platform: this.params.platform,
        appVersion: await this.params.appVersion(),
        service: t.service,
        stage: t.stage,
        messages: n
      };
      n.length !== 0 && await rt.post(this.params.serverUrl(), r);
    });
  }
}
var C0;
try {
  C0 = Map;
} catch {
}
var D0;
try {
  D0 = Set;
} catch {
}
function FE(e, t, n) {
  if (!e || typeof e != "object" || typeof e == "function")
    return e;
  if (e.nodeType && "cloneNode" in e)
    return e.cloneNode(!0);
  if (e instanceof Date)
    return new Date(e.getTime());
  if (e instanceof RegExp)
    return new RegExp(e);
  if (Array.isArray(e))
    return e.map(S0);
  if (C0 && e instanceof C0)
    return new Map(Array.from(e.entries()));
  if (D0 && e instanceof D0)
    return new Set(Array.from(e.values()));
  if (e instanceof Object) {
    t.push(e);
    var r = Object.create(e);
    n.push(r);
    for (var i in e) {
      var s = t.findIndex(function(a) {
        return a === e[i];
      });
      r[i] = s > -1 ? n[s] : FE(e[i], t, n);
    }
    return r;
  }
  return e;
}
function S0(e) {
  return FE(e, [], []);
}
const lne = Object.prototype.toString, cne = Error.prototype.toString, une = RegExp.prototype.toString, fne = typeof Symbol < "u" ? Symbol.prototype.toString : () => "", dne = /^Symbol\((.*)\)(.*)$/;
function hne(e) {
  return e != +e ? "NaN" : e === 0 && 1 / e < 0 ? "-0" : "" + e;
}
function b1(e, t = !1) {
  if (e == null || e === !0 || e === !1)
    return "" + e;
  const n = typeof e;
  if (n === "number")
    return hne(e);
  if (n === "string")
    return t ? `"${e}"` : e;
  if (n === "function")
    return "[Function " + (e.name || "anonymous") + "]";
  if (n === "symbol")
    return fne.call(e).replace(dne, "Symbol($1)");
  const r = lne.call(e).slice(8, -1);
  return r === "Date" ? isNaN(e.getTime()) ? "" + e : e.toISOString(e) : r === "Error" || e instanceof Error ? "[" + cne.call(e) + "]" : r === "RegExp" ? une.call(e) : null;
}
function Ms(e, t) {
  let n = b1(e, t);
  return n !== null ? n : JSON.stringify(e, function(r, i) {
    let s = b1(this[r], t);
    return s !== null ? s : i;
  }, 2);
}
let ri = {
  default: "${path} is invalid",
  required: "${path} is a required field",
  oneOf: "${path} must be one of the following values: ${values}",
  notOneOf: "${path} must not be one of the following values: ${values}",
  notType: ({
    path: e,
    type: t,
    value: n,
    originalValue: r
  }) => {
    let i = r != null && r !== n, s = `${e} must be a \`${t}\` type, but the final value was: \`${Ms(n, !0)}\`` + (i ? ` (cast from the value \`${Ms(r, !0)}\`).` : ".");
    return n === null && (s += '\n If "null" is intended as an empty value be sure to mark the schema as `.nullable()`'), s;
  },
  defined: "${path} must be defined"
}, _n = {
  length: "${path} must be exactly ${length} characters",
  min: "${path} must be at least ${min} characters",
  max: "${path} must be at most ${max} characters",
  matches: '${path} must match the following: "${regex}"',
  email: "${path} must be a valid email",
  url: "${path} must be a valid URL",
  uuid: "${path} must be a valid UUID",
  trim: "${path} must be a trimmed string",
  lowercase: "${path} must be a lowercase string",
  uppercase: "${path} must be a upper case string"
}, Er = {
  min: "${path} must be greater than or equal to ${min}",
  max: "${path} must be less than or equal to ${max}",
  lessThan: "${path} must be less than ${less}",
  moreThan: "${path} must be greater than ${more}",
  positive: "${path} must be a positive number",
  negative: "${path} must be a negative number",
  integer: "${path} must be an integer"
}, T0 = {
  min: "${path} field must be later than ${min}",
  max: "${path} field must be at earlier than ${max}"
}, O0 = {
  isValue: "${path} field must be ${value}"
}, M0 = {
  noUnknown: "${path} field has unspecified keys: ${unknown}"
}, ql = {
  min: "${path} field must have at least ${min} items",
  max: "${path} field must have less than or equal to ${max} items",
  length: "${path} must have ${length} items"
};
const pne = Object.assign(/* @__PURE__ */ Object.create(null), {
  mixed: ri,
  string: _n,
  number: Er,
  date: T0,
  object: M0,
  array: ql,
  boolean: O0
});
var gne = Object.prototype, vne = gne.hasOwnProperty;
function mne(e, t) {
  return e != null && vne.call(e, t);
}
var yne = mne, xne = Array.isArray, Ur = xne, bne = typeof ye == "object" && ye && ye.Object === Object && ye, PE = bne, _ne = PE, wne = typeof self == "object" && self && self.Object === Object && self, $ne = _ne || wne || Function("return this")(), yr = $ne, Ene = yr, Ane = Ene.Symbol, Iu = Ane, _1 = Iu, IE = Object.prototype, kne = IE.hasOwnProperty, Cne = IE.toString, ga = _1 ? _1.toStringTag : void 0;
function Dne(e) {
  var t = kne.call(e, ga), n = e[ga];
  try {
    e[ga] = void 0;
    var r = !0;
  } catch {
  }
  var i = Cne.call(e);
  return r && (t ? e[ga] = n : delete e[ga]), i;
}
var Sne = Dne, Tne = Object.prototype, One = Tne.toString;
function Mne(e) {
  return One.call(e);
}
var Fne = Mne, w1 = Iu, Pne = Sne, Ine = Fne, Rne = "[object Null]", Bne = "[object Undefined]", $1 = w1 ? w1.toStringTag : void 0;
function Nne(e) {
  return e == null ? e === void 0 ? Bne : Rne : $1 && $1 in Object(e) ? Pne(e) : Ine(e);
}
var Io = Nne;
function Lne(e) {
  return e != null && typeof e == "object";
}
var Ro = Lne, jne = Io, zne = Ro, Vne = "[object Symbol]";
function Hne(e) {
  return typeof e == "symbol" || zne(e) && jne(e) == Vne;
}
var kp = Hne, Wne = Ur, Une = kp, Yne = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, qne = /^\w*$/;
function Gne(e, t) {
  if (Wne(e))
    return !1;
  var n = typeof e;
  return n == "number" || n == "symbol" || n == "boolean" || e == null || Une(e) ? !0 : qne.test(e) || !Yne.test(e) || t != null && e in Object(t);
}
var Cp = Gne;
function Xne(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var Dp = Xne, Zne = Io, Kne = Dp, Jne = "[object AsyncFunction]", Qne = "[object Function]", ere = "[object GeneratorFunction]", tre = "[object Proxy]";
function nre(e) {
  if (!Kne(e))
    return !1;
  var t = Zne(e);
  return t == Qne || t == ere || t == Jne || t == tre;
}
var RE = nre, rre = yr, ire = rre["__core-js_shared__"], sre = ire, gd = sre, E1 = function() {
  var e = /[^.]+$/.exec(gd && gd.keys && gd.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
}();
function are(e) {
  return !!E1 && E1 in e;
}
var ore = are, lre = Function.prototype, cre = lre.toString;
function ure(e) {
  if (e != null) {
    try {
      return cre.call(e);
    } catch {
    }
    try {
      return e + "";
    } catch {
    }
  }
  return "";
}
var BE = ure, fre = RE, dre = ore, hre = Dp, pre = BE, gre = /[\\^$.*+?()[\]{}|]/g, vre = /^\[object .+?Constructor\]$/, mre = Function.prototype, yre = Object.prototype, xre = mre.toString, bre = yre.hasOwnProperty, _re = RegExp(
  "^" + xre.call(bre).replace(gre, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function wre(e) {
  if (!hre(e) || dre(e))
    return !1;
  var t = fre(e) ? _re : vre;
  return t.test(pre(e));
}
var $re = wre;
function Ere(e, t) {
  return e == null ? void 0 : e[t];
}
var Are = Ere, kre = $re, Cre = Are;
function Dre(e, t) {
  var n = Cre(e, t);
  return kre(n) ? n : void 0;
}
var Li = Dre, Sre = Li, Tre = Sre(Object, "create"), Ru = Tre, A1 = Ru;
function Ore() {
  this.__data__ = A1 ? A1(null) : {}, this.size = 0;
}
var Mre = Ore;
function Fre(e) {
  var t = this.has(e) && delete this.__data__[e];
  return this.size -= t ? 1 : 0, t;
}
var Pre = Fre, Ire = Ru, Rre = "__lodash_hash_undefined__", Bre = Object.prototype, Nre = Bre.hasOwnProperty;
function Lre(e) {
  var t = this.__data__;
  if (Ire) {
    var n = t[e];
    return n === Rre ? void 0 : n;
  }
  return Nre.call(t, e) ? t[e] : void 0;
}
var jre = Lre, zre = Ru, Vre = Object.prototype, Hre = Vre.hasOwnProperty;
function Wre(e) {
  var t = this.__data__;
  return zre ? t[e] !== void 0 : Hre.call(t, e);
}
var Ure = Wre, Yre = Ru, qre = "__lodash_hash_undefined__";
function Gre(e, t) {
  var n = this.__data__;
  return this.size += this.has(e) ? 0 : 1, n[e] = Yre && t === void 0 ? qre : t, this;
}
var Xre = Gre, Zre = Mre, Kre = Pre, Jre = jre, Qre = Ure, eie = Xre;
function qs(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
qs.prototype.clear = Zre;
qs.prototype.delete = Kre;
qs.prototype.get = Jre;
qs.prototype.has = Qre;
qs.prototype.set = eie;
var tie = qs;
function nie() {
  this.__data__ = [], this.size = 0;
}
var rie = nie;
function iie(e, t) {
  return e === t || e !== e && t !== t;
}
var NE = iie, sie = NE;
function aie(e, t) {
  for (var n = e.length; n--; )
    if (sie(e[n][0], t))
      return n;
  return -1;
}
var Bu = aie, oie = Bu, lie = Array.prototype, cie = lie.splice;
function uie(e) {
  var t = this.__data__, n = oie(t, e);
  if (n < 0)
    return !1;
  var r = t.length - 1;
  return n == r ? t.pop() : cie.call(t, n, 1), --this.size, !0;
}
var fie = uie, die = Bu;
function hie(e) {
  var t = this.__data__, n = die(t, e);
  return n < 0 ? void 0 : t[n][1];
}
var pie = hie, gie = Bu;
function vie(e) {
  return gie(this.__data__, e) > -1;
}
var mie = vie, yie = Bu;
function xie(e, t) {
  var n = this.__data__, r = yie(n, e);
  return r < 0 ? (++this.size, n.push([e, t])) : n[r][1] = t, this;
}
var bie = xie, _ie = rie, wie = fie, $ie = pie, Eie = mie, Aie = bie;
function Gs(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
Gs.prototype.clear = _ie;
Gs.prototype.delete = wie;
Gs.prototype.get = $ie;
Gs.prototype.has = Eie;
Gs.prototype.set = Aie;
var Nu = Gs, kie = Li, Cie = yr, Die = kie(Cie, "Map"), Sp = Die, k1 = tie, Sie = Nu, Tie = Sp;
function Oie() {
  this.size = 0, this.__data__ = {
    hash: new k1(),
    map: new (Tie || Sie)(),
    string: new k1()
  };
}
var Mie = Oie;
function Fie(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
var Pie = Fie, Iie = Pie;
function Rie(e, t) {
  var n = e.__data__;
  return Iie(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map;
}
var Lu = Rie, Bie = Lu;
function Nie(e) {
  var t = Bie(this, e).delete(e);
  return this.size -= t ? 1 : 0, t;
}
var Lie = Nie, jie = Lu;
function zie(e) {
  return jie(this, e).get(e);
}
var Vie = zie, Hie = Lu;
function Wie(e) {
  return Hie(this, e).has(e);
}
var Uie = Wie, Yie = Lu;
function qie(e, t) {
  var n = Yie(this, e), r = n.size;
  return n.set(e, t), this.size += n.size == r ? 0 : 1, this;
}
var Gie = qie, Xie = Mie, Zie = Lie, Kie = Vie, Jie = Uie, Qie = Gie;
function Xs(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
Xs.prototype.clear = Xie;
Xs.prototype.delete = Zie;
Xs.prototype.get = Kie;
Xs.prototype.has = Jie;
Xs.prototype.set = Qie;
var Tp = Xs, LE = Tp, ese = "Expected a function";
function Op(e, t) {
  if (typeof e != "function" || t != null && typeof t != "function")
    throw new TypeError(ese);
  var n = function() {
    var r = arguments, i = t ? t.apply(this, r) : r[0], s = n.cache;
    if (s.has(i))
      return s.get(i);
    var a = e.apply(this, r);
    return n.cache = s.set(i, a) || s, a;
  };
  return n.cache = new (Op.Cache || LE)(), n;
}
Op.Cache = LE;
var tse = Op, nse = tse, rse = 500;
function ise(e) {
  var t = nse(e, function(r) {
    return n.size === rse && n.clear(), r;
  }), n = t.cache;
  return t;
}
var sse = ise, ase = sse, ose = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, lse = /\\(\\)?/g, cse = ase(function(e) {
  var t = [];
  return e.charCodeAt(0) === 46 && t.push(""), e.replace(ose, function(n, r, i, s) {
    t.push(i ? s.replace(lse, "$1") : r || n);
  }), t;
}), use = cse;
function fse(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length, i = Array(r); ++n < r; )
    i[n] = t(e[n], n, e);
  return i;
}
var dse = fse, C1 = Iu, hse = dse, pse = Ur, gse = kp, vse = 1 / 0, D1 = C1 ? C1.prototype : void 0, S1 = D1 ? D1.toString : void 0;
function jE(e) {
  if (typeof e == "string")
    return e;
  if (pse(e))
    return hse(e, jE) + "";
  if (gse(e))
    return S1 ? S1.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -vse ? "-0" : t;
}
var mse = jE, yse = mse;
function xse(e) {
  return e == null ? "" : yse(e);
}
var Bo = xse, bse = Ur, _se = Cp, wse = use, $se = Bo;
function Ese(e, t) {
  return bse(e) ? e : _se(e, t) ? [e] : wse($se(e));
}
var zE = Ese, Ase = Io, kse = Ro, Cse = "[object Arguments]";
function Dse(e) {
  return kse(e) && Ase(e) == Cse;
}
var Sse = Dse, T1 = Sse, Tse = Ro, VE = Object.prototype, Ose = VE.hasOwnProperty, Mse = VE.propertyIsEnumerable, Fse = T1(/* @__PURE__ */ function() {
  return arguments;
}()) ? T1 : function(e) {
  return Tse(e) && Ose.call(e, "callee") && !Mse.call(e, "callee");
}, HE = Fse, Pse = 9007199254740991, Ise = /^(?:0|[1-9]\d*)$/;
function Rse(e, t) {
  var n = typeof e;
  return t = t ?? Pse, !!t && (n == "number" || n != "symbol" && Ise.test(e)) && e > -1 && e % 1 == 0 && e < t;
}
var WE = Rse, Bse = 9007199254740991;
function Nse(e) {
  return typeof e == "number" && e > -1 && e % 1 == 0 && e <= Bse;
}
var Mp = Nse, Lse = kp, jse = 1 / 0;
function zse(e) {
  if (typeof e == "string" || Lse(e))
    return e;
  var t = e + "";
  return t == "0" && 1 / e == -jse ? "-0" : t;
}
var ju = zse, Vse = zE, Hse = HE, Wse = Ur, Use = WE, Yse = Mp, qse = ju;
function Gse(e, t, n) {
  t = Vse(t, e);
  for (var r = -1, i = t.length, s = !1; ++r < i; ) {
    var a = qse(t[r]);
    if (!(s = e != null && n(e, a)))
      break;
    e = e[a];
  }
  return s || ++r != i ? s : (i = e == null ? 0 : e.length, !!i && Yse(i) && Use(a, i) && (Wse(e) || Hse(e)));
}
var UE = Gse, Xse = yne, Zse = UE;
function Kse(e, t) {
  return e != null && Zse(e, t, Xse);
}
var Jse = Kse;
const jc = /* @__PURE__ */ Vr(Jse), Zs = (e) => e && e.__isYupSchema__;
class Qse {
  constructor(t, n) {
    if (this.fn = void 0, this.refs = t, this.refs = t, typeof n == "function") {
      this.fn = n;
      return;
    }
    if (!jc(n, "is"))
      throw new TypeError("`is:` is required for `when()` conditions");
    if (!n.then && !n.otherwise)
      throw new TypeError("either `then:` or `otherwise:` is required for `when()` conditions");
    let {
      is: r,
      then: i,
      otherwise: s
    } = n, a = typeof r == "function" ? r : (...o) => o.every((l) => l === r);
    this.fn = function(...o) {
      let l = o.pop(), c = o.pop(), u = a(...o) ? i : s;
      if (u)
        return typeof u == "function" ? u(c) : c.concat(u.resolve(l));
    };
  }
  resolve(t, n) {
    let r = this.refs.map((s) => s.getValue(n == null ? void 0 : n.value, n == null ? void 0 : n.parent, n == null ? void 0 : n.context)), i = this.fn.apply(t, r.concat(t, n));
    if (i === void 0 || i === t)
      return t;
    if (!Zs(i))
      throw new TypeError("conditions must return a schema object");
    return i.resolve(n);
  }
}
function YE(e) {
  return e == null ? [] : [].concat(e);
}
function F0() {
  return F0 = Object.assign || function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, F0.apply(this, arguments);
}
let eae = /\$\{\s*(\w+)\s*\}/g;
class qt extends Error {
  static formatError(t, n) {
    const r = n.label || n.path || "this";
    return r !== n.path && (n = F0({}, n, {
      path: r
    })), typeof t == "string" ? t.replace(eae, (i, s) => Ms(n[s])) : typeof t == "function" ? t(n) : t;
  }
  static isError(t) {
    return t && t.name === "ValidationError";
  }
  constructor(t, n, r, i) {
    super(), this.value = void 0, this.path = void 0, this.type = void 0, this.errors = void 0, this.params = void 0, this.inner = void 0, this.name = "ValidationError", this.value = n, this.path = r, this.type = i, this.errors = [], this.inner = [], YE(t).forEach((s) => {
      qt.isError(s) ? (this.errors.push(...s.errors), this.inner = this.inner.concat(s.inner.length ? s.inner : s)) : this.errors.push(s);
    }), this.message = this.errors.length > 1 ? `${this.errors.length} errors occurred` : this.errors[0], Error.captureStackTrace && Error.captureStackTrace(this, qt);
  }
}
const tae = (e) => {
  let t = !1;
  return (...n) => {
    t || (t = !0, e(...n));
  };
};
function zc(e, t) {
  let {
    endEarly: n,
    tests: r,
    args: i,
    value: s,
    errors: a,
    sort: o,
    path: l
  } = e, c = tae(t), u = r.length;
  const f = [];
  if (a = a || [], !u)
    return a.length ? c(new qt(a, s, l)) : c(null, s);
  for (let d = 0; d < r.length; d++) {
    const h = r[d];
    h(i, function(g) {
      if (g) {
        if (!qt.isError(g))
          return c(g, s);
        if (n)
          return g.value = s, c(g, s);
        f.push(g);
      }
      if (--u <= 0) {
        if (f.length && (o && f.sort(o), a.length && f.push(...a), a = f), a.length) {
          c(new qt(a, s, l), s);
          return;
        }
        c(null, s);
      }
    });
  }
}
var nae = Li, rae = function() {
  try {
    var e = nae(Object, "defineProperty");
    return e({}, "", {}), e;
  } catch {
  }
}(), iae = rae, O1 = iae;
function sae(e, t, n) {
  t == "__proto__" && O1 ? O1(e, t, {
    configurable: !0,
    enumerable: !0,
    value: n,
    writable: !0
  }) : e[t] = n;
}
var qE = sae;
function aae(e) {
  return function(t, n, r) {
    for (var i = -1, s = Object(t), a = r(t), o = a.length; o--; ) {
      var l = a[e ? o : ++i];
      if (n(s[l], l, s) === !1)
        break;
    }
    return t;
  };
}
var oae = aae, lae = oae, cae = lae(), uae = cae;
function fae(e, t) {
  for (var n = -1, r = Array(e); ++n < e; )
    r[n] = t(n);
  return r;
}
var dae = fae, Vc = { exports: {} };
function hae() {
  return !1;
}
var pae = hae;
Vc.exports;
(function(e, t) {
  var n = yr, r = pae, i = t && !t.nodeType && t, s = i && !0 && e && !e.nodeType && e, a = s && s.exports === i, o = a ? n.Buffer : void 0, l = o ? o.isBuffer : void 0, c = l || r;
  e.exports = c;
})(Vc, Vc.exports);
var GE = Vc.exports, gae = Io, vae = Mp, mae = Ro, yae = "[object Arguments]", xae = "[object Array]", bae = "[object Boolean]", _ae = "[object Date]", wae = "[object Error]", $ae = "[object Function]", Eae = "[object Map]", Aae = "[object Number]", kae = "[object Object]", Cae = "[object RegExp]", Dae = "[object Set]", Sae = "[object String]", Tae = "[object WeakMap]", Oae = "[object ArrayBuffer]", Mae = "[object DataView]", Fae = "[object Float32Array]", Pae = "[object Float64Array]", Iae = "[object Int8Array]", Rae = "[object Int16Array]", Bae = "[object Int32Array]", Nae = "[object Uint8Array]", Lae = "[object Uint8ClampedArray]", jae = "[object Uint16Array]", zae = "[object Uint32Array]", Xe = {};
Xe[Fae] = Xe[Pae] = Xe[Iae] = Xe[Rae] = Xe[Bae] = Xe[Nae] = Xe[Lae] = Xe[jae] = Xe[zae] = !0;
Xe[yae] = Xe[xae] = Xe[Oae] = Xe[bae] = Xe[Mae] = Xe[_ae] = Xe[wae] = Xe[$ae] = Xe[Eae] = Xe[Aae] = Xe[kae] = Xe[Cae] = Xe[Dae] = Xe[Sae] = Xe[Tae] = !1;
function Vae(e) {
  return mae(e) && vae(e.length) && !!Xe[gae(e)];
}
var Hae = Vae;
function Wae(e) {
  return function(t) {
    return e(t);
  };
}
var Uae = Wae, Hc = { exports: {} };
Hc.exports;
(function(e, t) {
  var n = PE, r = t && !t.nodeType && t, i = r && !0 && e && !e.nodeType && e, s = i && i.exports === r, a = s && n.process, o = function() {
    try {
      var l = i && i.require && i.require("util").types;
      return l || a && a.binding && a.binding("util");
    } catch {
    }
  }();
  e.exports = o;
})(Hc, Hc.exports);
var Yae = Hc.exports, qae = Hae, Gae = Uae, M1 = Yae, F1 = M1 && M1.isTypedArray, Xae = F1 ? Gae(F1) : qae, XE = Xae, Zae = dae, Kae = HE, Jae = Ur, Qae = GE, eoe = WE, toe = XE, noe = Object.prototype, roe = noe.hasOwnProperty;
function ioe(e, t) {
  var n = Jae(e), r = !n && Kae(e), i = !n && !r && Qae(e), s = !n && !r && !i && toe(e), a = n || r || i || s, o = a ? Zae(e.length, String) : [], l = o.length;
  for (var c in e)
    (t || roe.call(e, c)) && !(a && // Safari 9 has enumerable `arguments.length` in strict mode.
    (c == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    i && (c == "offset" || c == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    s && (c == "buffer" || c == "byteLength" || c == "byteOffset") || // Skip index properties.
    eoe(c, l))) && o.push(c);
  return o;
}
var soe = ioe, aoe = Object.prototype;
function ooe(e) {
  var t = e && e.constructor, n = typeof t == "function" && t.prototype || aoe;
  return e === n;
}
var loe = ooe;
function coe(e, t) {
  return function(n) {
    return e(t(n));
  };
}
var uoe = coe, foe = uoe, doe = foe(Object.keys, Object), hoe = doe, poe = loe, goe = hoe, voe = Object.prototype, moe = voe.hasOwnProperty;
function yoe(e) {
  if (!poe(e))
    return goe(e);
  var t = [];
  for (var n in Object(e))
    moe.call(e, n) && n != "constructor" && t.push(n);
  return t;
}
var xoe = yoe, boe = RE, _oe = Mp;
function woe(e) {
  return e != null && _oe(e.length) && !boe(e);
}
var $oe = woe, Eoe = soe, Aoe = xoe, koe = $oe;
function Coe(e) {
  return koe(e) ? Eoe(e) : Aoe(e);
}
var Fp = Coe, Doe = uae, Soe = Fp;
function Toe(e, t) {
  return e && Doe(e, t, Soe);
}
var ZE = Toe, Ooe = Nu;
function Moe() {
  this.__data__ = new Ooe(), this.size = 0;
}
var Foe = Moe;
function Poe(e) {
  var t = this.__data__, n = t.delete(e);
  return this.size = t.size, n;
}
var Ioe = Poe;
function Roe(e) {
  return this.__data__.get(e);
}
var Boe = Roe;
function Noe(e) {
  return this.__data__.has(e);
}
var Loe = Noe, joe = Nu, zoe = Sp, Voe = Tp, Hoe = 200;
function Woe(e, t) {
  var n = this.__data__;
  if (n instanceof joe) {
    var r = n.__data__;
    if (!zoe || r.length < Hoe - 1)
      return r.push([e, t]), this.size = ++n.size, this;
    n = this.__data__ = new Voe(r);
  }
  return n.set(e, t), this.size = n.size, this;
}
var Uoe = Woe, Yoe = Nu, qoe = Foe, Goe = Ioe, Xoe = Boe, Zoe = Loe, Koe = Uoe;
function Ks(e) {
  var t = this.__data__ = new Yoe(e);
  this.size = t.size;
}
Ks.prototype.clear = qoe;
Ks.prototype.delete = Goe;
Ks.prototype.get = Xoe;
Ks.prototype.has = Zoe;
Ks.prototype.set = Koe;
var KE = Ks, Joe = "__lodash_hash_undefined__";
function Qoe(e) {
  return this.__data__.set(e, Joe), this;
}
var ele = Qoe;
function tle(e) {
  return this.__data__.has(e);
}
var nle = tle, rle = Tp, ile = ele, sle = nle;
function Wc(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.__data__ = new rle(); ++t < n; )
    this.add(e[t]);
}
Wc.prototype.add = Wc.prototype.push = ile;
Wc.prototype.has = sle;
var ale = Wc;
function ole(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length; ++n < r; )
    if (t(e[n], n, e))
      return !0;
  return !1;
}
var lle = ole;
function cle(e, t) {
  return e.has(t);
}
var ule = cle, fle = ale, dle = lle, hle = ule, ple = 1, gle = 2;
function vle(e, t, n, r, i, s) {
  var a = n & ple, o = e.length, l = t.length;
  if (o != l && !(a && l > o))
    return !1;
  var c = s.get(e), u = s.get(t);
  if (c && u)
    return c == t && u == e;
  var f = -1, d = !0, h = n & gle ? new fle() : void 0;
  for (s.set(e, t), s.set(t, e); ++f < o; ) {
    var p = e[f], g = t[f];
    if (r)
      var v = a ? r(g, p, f, t, e, s) : r(p, g, f, e, t, s);
    if (v !== void 0) {
      if (v)
        continue;
      d = !1;
      break;
    }
    if (h) {
      if (!dle(t, function(m, x) {
        if (!hle(h, x) && (p === m || i(p, m, n, r, s)))
          return h.push(x);
      })) {
        d = !1;
        break;
      }
    } else if (!(p === g || i(p, g, n, r, s))) {
      d = !1;
      break;
    }
  }
  return s.delete(e), s.delete(t), d;
}
var JE = vle, mle = yr, yle = mle.Uint8Array, xle = yle;
function ble(e) {
  var t = -1, n = Array(e.size);
  return e.forEach(function(r, i) {
    n[++t] = [i, r];
  }), n;
}
var _le = ble;
function wle(e) {
  var t = -1, n = Array(e.size);
  return e.forEach(function(r) {
    n[++t] = r;
  }), n;
}
var $le = wle, P1 = Iu, I1 = xle, Ele = NE, Ale = JE, kle = _le, Cle = $le, Dle = 1, Sle = 2, Tle = "[object Boolean]", Ole = "[object Date]", Mle = "[object Error]", Fle = "[object Map]", Ple = "[object Number]", Ile = "[object RegExp]", Rle = "[object Set]", Ble = "[object String]", Nle = "[object Symbol]", Lle = "[object ArrayBuffer]", jle = "[object DataView]", R1 = P1 ? P1.prototype : void 0, vd = R1 ? R1.valueOf : void 0;
function zle(e, t, n, r, i, s, a) {
  switch (n) {
    case jle:
      if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
        return !1;
      e = e.buffer, t = t.buffer;
    case Lle:
      return !(e.byteLength != t.byteLength || !s(new I1(e), new I1(t)));
    case Tle:
    case Ole:
    case Ple:
      return Ele(+e, +t);
    case Mle:
      return e.name == t.name && e.message == t.message;
    case Ile:
    case Ble:
      return e == t + "";
    case Fle:
      var o = kle;
    case Rle:
      var l = r & Dle;
      if (o || (o = Cle), e.size != t.size && !l)
        return !1;
      var c = a.get(e);
      if (c)
        return c == t;
      r |= Sle, a.set(e, t);
      var u = Ale(o(e), o(t), r, i, s, a);
      return a.delete(e), u;
    case Nle:
      if (vd)
        return vd.call(e) == vd.call(t);
  }
  return !1;
}
var Vle = zle;
function Hle(e, t) {
  for (var n = -1, r = t.length, i = e.length; ++n < r; )
    e[i + n] = t[n];
  return e;
}
var Wle = Hle, Ule = Wle, Yle = Ur;
function qle(e, t, n) {
  var r = t(e);
  return Yle(e) ? r : Ule(r, n(e));
}
var Gle = qle;
function Xle(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length, i = 0, s = []; ++n < r; ) {
    var a = e[n];
    t(a, n, e) && (s[i++] = a);
  }
  return s;
}
var Zle = Xle;
function Kle() {
  return [];
}
var Jle = Kle, Qle = Zle, ece = Jle, tce = Object.prototype, nce = tce.propertyIsEnumerable, B1 = Object.getOwnPropertySymbols, rce = B1 ? function(e) {
  return e == null ? [] : (e = Object(e), Qle(B1(e), function(t) {
    return nce.call(e, t);
  }));
} : ece, ice = rce, sce = Gle, ace = ice, oce = Fp;
function lce(e) {
  return sce(e, oce, ace);
}
var cce = lce, N1 = cce, uce = 1, fce = Object.prototype, dce = fce.hasOwnProperty;
function hce(e, t, n, r, i, s) {
  var a = n & uce, o = N1(e), l = o.length, c = N1(t), u = c.length;
  if (l != u && !a)
    return !1;
  for (var f = l; f--; ) {
    var d = o[f];
    if (!(a ? d in t : dce.call(t, d)))
      return !1;
  }
  var h = s.get(e), p = s.get(t);
  if (h && p)
    return h == t && p == e;
  var g = !0;
  s.set(e, t), s.set(t, e);
  for (var v = a; ++f < l; ) {
    d = o[f];
    var m = e[d], x = t[d];
    if (r)
      var _ = a ? r(x, m, d, t, e, s) : r(m, x, d, e, t, s);
    if (!(_ === void 0 ? m === x || i(m, x, n, r, s) : _)) {
      g = !1;
      break;
    }
    v || (v = d == "constructor");
  }
  if (g && !v) {
    var y = e.constructor, b = t.constructor;
    y != b && "constructor" in e && "constructor" in t && !(typeof y == "function" && y instanceof y && typeof b == "function" && b instanceof b) && (g = !1);
  }
  return s.delete(e), s.delete(t), g;
}
var pce = hce, gce = Li, vce = yr, mce = gce(vce, "DataView"), yce = mce, xce = Li, bce = yr, _ce = xce(bce, "Promise"), wce = _ce, $ce = Li, Ece = yr, Ace = $ce(Ece, "Set"), kce = Ace, Cce = Li, Dce = yr, Sce = Cce(Dce, "WeakMap"), Tce = Sce, P0 = yce, I0 = Sp, R0 = wce, B0 = kce, N0 = Tce, QE = Io, Js = BE, L1 = "[object Map]", Oce = "[object Object]", j1 = "[object Promise]", z1 = "[object Set]", V1 = "[object WeakMap]", H1 = "[object DataView]", Mce = Js(P0), Fce = Js(I0), Pce = Js(R0), Ice = Js(B0), Rce = Js(N0), ii = QE;
(P0 && ii(new P0(new ArrayBuffer(1))) != H1 || I0 && ii(new I0()) != L1 || R0 && ii(R0.resolve()) != j1 || B0 && ii(new B0()) != z1 || N0 && ii(new N0()) != V1) && (ii = function(e) {
  var t = QE(e), n = t == Oce ? e.constructor : void 0, r = n ? Js(n) : "";
  if (r)
    switch (r) {
      case Mce:
        return H1;
      case Fce:
        return L1;
      case Pce:
        return j1;
      case Ice:
        return z1;
      case Rce:
        return V1;
    }
  return t;
});
var Bce = ii, md = KE, Nce = JE, Lce = Vle, jce = pce, W1 = Bce, U1 = Ur, Y1 = GE, zce = XE, Vce = 1, q1 = "[object Arguments]", G1 = "[object Array]", xl = "[object Object]", Hce = Object.prototype, X1 = Hce.hasOwnProperty;
function Wce(e, t, n, r, i, s) {
  var a = U1(e), o = U1(t), l = a ? G1 : W1(e), c = o ? G1 : W1(t);
  l = l == q1 ? xl : l, c = c == q1 ? xl : c;
  var u = l == xl, f = c == xl, d = l == c;
  if (d && Y1(e)) {
    if (!Y1(t))
      return !1;
    a = !0, u = !1;
  }
  if (d && !u)
    return s || (s = new md()), a || zce(e) ? Nce(e, t, n, r, i, s) : Lce(e, t, l, n, r, i, s);
  if (!(n & Vce)) {
    var h = u && X1.call(e, "__wrapped__"), p = f && X1.call(t, "__wrapped__");
    if (h || p) {
      var g = h ? e.value() : e, v = p ? t.value() : t;
      return s || (s = new md()), i(g, v, n, r, s);
    }
  }
  return d ? (s || (s = new md()), jce(e, t, n, r, i, s)) : !1;
}
var Uce = Wce, Yce = Uce, Z1 = Ro;
function eA(e, t, n, r, i) {
  return e === t ? !0 : e == null || t == null || !Z1(e) && !Z1(t) ? e !== e && t !== t : Yce(e, t, n, r, eA, i);
}
var tA = eA, qce = KE, Gce = tA, Xce = 1, Zce = 2;
function Kce(e, t, n, r) {
  var i = n.length, s = i, a = !r;
  if (e == null)
    return !s;
  for (e = Object(e); i--; ) {
    var o = n[i];
    if (a && o[2] ? o[1] !== e[o[0]] : !(o[0] in e))
      return !1;
  }
  for (; ++i < s; ) {
    o = n[i];
    var l = o[0], c = e[l], u = o[1];
    if (a && o[2]) {
      if (c === void 0 && !(l in e))
        return !1;
    } else {
      var f = new qce();
      if (r)
        var d = r(c, u, l, e, t, f);
      if (!(d === void 0 ? Gce(u, c, Xce | Zce, r, f) : d))
        return !1;
    }
  }
  return !0;
}
var Jce = Kce, Qce = Dp;
function eue(e) {
  return e === e && !Qce(e);
}
var nA = eue, tue = nA, nue = Fp;
function rue(e) {
  for (var t = nue(e), n = t.length; n--; ) {
    var r = t[n], i = e[r];
    t[n] = [r, i, tue(i)];
  }
  return t;
}
var iue = rue;
function sue(e, t) {
  return function(n) {
    return n == null ? !1 : n[e] === t && (t !== void 0 || e in Object(n));
  };
}
var rA = sue, aue = Jce, oue = iue, lue = rA;
function cue(e) {
  var t = oue(e);
  return t.length == 1 && t[0][2] ? lue(t[0][0], t[0][1]) : function(n) {
    return n === e || aue(n, e, t);
  };
}
var uue = cue, fue = zE, due = ju;
function hue(e, t) {
  t = fue(t, e);
  for (var n = 0, r = t.length; e != null && n < r; )
    e = e[due(t[n++])];
  return n && n == r ? e : void 0;
}
var iA = hue, pue = iA;
function gue(e, t, n) {
  var r = e == null ? void 0 : pue(e, t);
  return r === void 0 ? n : r;
}
var vue = gue;
function mue(e, t) {
  return e != null && t in Object(e);
}
var yue = mue, xue = yue, bue = UE;
function _ue(e, t) {
  return e != null && bue(e, t, xue);
}
var wue = _ue, $ue = tA, Eue = vue, Aue = wue, kue = Cp, Cue = nA, Due = rA, Sue = ju, Tue = 1, Oue = 2;
function Mue(e, t) {
  return kue(e) && Cue(t) ? Due(Sue(e), t) : function(n) {
    var r = Eue(n, e);
    return r === void 0 && r === t ? Aue(n, e) : $ue(t, r, Tue | Oue);
  };
}
var Fue = Mue;
function Pue(e) {
  return e;
}
var Iue = Pue;
function Rue(e) {
  return function(t) {
    return t == null ? void 0 : t[e];
  };
}
var Bue = Rue, Nue = iA;
function Lue(e) {
  return function(t) {
    return Nue(t, e);
  };
}
var jue = Lue, zue = Bue, Vue = jue, Hue = Cp, Wue = ju;
function Uue(e) {
  return Hue(e) ? zue(Wue(e)) : Vue(e);
}
var Yue = Uue, que = uue, Gue = Fue, Xue = Iue, Zue = Ur, Kue = Yue;
function Jue(e) {
  return typeof e == "function" ? e : e == null ? Xue : typeof e == "object" ? Zue(e) ? Gue(e[0], e[1]) : que(e) : Kue(e);
}
var sA = Jue, Que = qE, efe = ZE, tfe = sA;
function nfe(e, t) {
  var n = {};
  return t = tfe(t), efe(e, function(r, i, s) {
    Que(n, i, t(r, i, s));
  }), n;
}
var rfe = nfe;
const aA = /* @__PURE__ */ Vr(rfe);
function ji(e) {
  this._maxSize = e, this.clear();
}
ji.prototype.clear = function() {
  this._size = 0, this._values = /* @__PURE__ */ Object.create(null);
};
ji.prototype.get = function(e) {
  return this._values[e];
};
ji.prototype.set = function(e, t) {
  return this._size >= this._maxSize && this.clear(), e in this._values || this._size++, this._values[e] = t;
};
var ife = /[^.^\]^[]+|(?=\[\]|\.\.)/g, oA = /^\d+$/, sfe = /^\d/, afe = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g, ofe = /^\s*(['"]?)(.*?)(\1)\s*$/, Pp = 512, K1 = new ji(Pp), J1 = new ji(Pp), Q1 = new ji(Pp), zu = {
  Cache: ji,
  split: L0,
  normalizePath: yd,
  setter: function(e) {
    var t = yd(e);
    return J1.get(e) || J1.set(e, function(r, i) {
      for (var s = 0, a = t.length, o = r; s < a - 1; ) {
        var l = t[s];
        if (l === "__proto__" || l === "constructor" || l === "prototype")
          return r;
        o = o[t[s++]];
      }
      o[t[s]] = i;
    });
  },
  getter: function(e, t) {
    var n = yd(e);
    return Q1.get(e) || Q1.set(e, function(i) {
      for (var s = 0, a = n.length; s < a; )
        if (i != null || !t)
          i = i[n[s++]];
        else
          return;
      return i;
    });
  },
  join: function(e) {
    return e.reduce(function(t, n) {
      return t + (Ip(n) || oA.test(n) ? "[" + n + "]" : (t ? "." : "") + n);
    }, "");
  },
  forEach: function(e, t, n) {
    lfe(Array.isArray(e) ? e : L0(e), t, n);
  }
};
function yd(e) {
  return K1.get(e) || K1.set(
    e,
    L0(e).map(function(t) {
      return t.replace(ofe, "$2");
    })
  );
}
function L0(e) {
  return e.match(ife) || [""];
}
function lfe(e, t, n) {
  var r = e.length, i, s, a, o;
  for (s = 0; s < r; s++)
    i = e[s], i && (ffe(i) && (i = '"' + i + '"'), o = Ip(i), a = !o && /^\d+$/.test(i), t.call(n, i, o, a, s, e));
}
function Ip(e) {
  return typeof e == "string" && e && ["'", '"'].indexOf(e.charAt(0)) !== -1;
}
function cfe(e) {
  return e.match(sfe) && !e.match(oA);
}
function ufe(e) {
  return afe.test(e);
}
function ffe(e) {
  return !Ip(e) && (cfe(e) || ufe(e));
}
const bl = {
  context: "$",
  value: "."
};
function dfe(e, t) {
  return new sr(e, t);
}
class sr {
  constructor(t, n = {}) {
    if (this.key = void 0, this.isContext = void 0, this.isValue = void 0, this.isSibling = void 0, this.path = void 0, this.getter = void 0, this.map = void 0, typeof t != "string")
      throw new TypeError("ref must be a string, got: " + t);
    if (this.key = t.trim(), t === "")
      throw new TypeError("ref must be a non-empty string");
    this.isContext = this.key[0] === bl.context, this.isValue = this.key[0] === bl.value, this.isSibling = !this.isContext && !this.isValue;
    let r = this.isContext ? bl.context : this.isValue ? bl.value : "";
    this.path = this.key.slice(r.length), this.getter = this.path && zu.getter(this.path, !0), this.map = n.map;
  }
  getValue(t, n, r) {
    let i = this.isContext ? r : this.isValue ? t : n;
    return this.getter && (i = this.getter(i || {})), this.map && (i = this.map(i)), i;
  }
  /**
   *
   * @param {*} value
   * @param {Object} options
   * @param {Object=} options.context
   * @param {Object=} options.parent
   */
  cast(t, n) {
    return this.getValue(t, n == null ? void 0 : n.parent, n == null ? void 0 : n.context);
  }
  resolve() {
    return this;
  }
  describe() {
    return {
      type: "ref",
      key: this.key
    };
  }
  toString() {
    return `Ref(${this.key})`;
  }
  static isRef(t) {
    return t && t.__isYupRef;
  }
}
sr.prototype.__isYupRef = !0;
function Uc() {
  return Uc = Object.assign || function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Uc.apply(this, arguments);
}
function hfe(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, s;
  for (s = 0; s < r.length; s++)
    i = r[s], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function _l(e) {
  function t(n, r) {
    let {
      value: i,
      path: s = "",
      label: a,
      options: o,
      originalValue: l,
      sync: c
    } = n, u = hfe(n, ["value", "path", "label", "options", "originalValue", "sync"]);
    const {
      name: f,
      test: d,
      params: h,
      message: p
    } = e;
    let {
      parent: g,
      context: v
    } = o;
    function m(w) {
      return sr.isRef(w) ? w.getValue(i, g, v) : w;
    }
    function x(w = {}) {
      const E = aA(Uc({
        value: i,
        originalValue: l,
        label: a,
        path: w.path || s
      }, h, w.params), m), $ = new qt(qt.formatError(w.message || p, E), i, E.path, w.type || f);
      return $.params = E, $;
    }
    let _ = Uc({
      path: s,
      parent: g,
      type: f,
      createError: x,
      resolve: m,
      options: o,
      originalValue: l
    }, u);
    if (!c) {
      try {
        Promise.resolve(d.call(_, i, _)).then((w) => {
          qt.isError(w) ? r(w) : w ? r(null, w) : r(x());
        }).catch(r);
      } catch (w) {
        r(w);
      }
      return;
    }
    let y;
    try {
      var b;
      if (y = d.call(_, i, _), typeof ((b = y) == null ? void 0 : b.then) == "function")
        throw new Error(`Validation test of type: "${_.type}" returned a Promise during a synchronous validate. This test will finish after the validate call has returned`);
    } catch (w) {
      r(w);
      return;
    }
    qt.isError(y) ? r(y) : y ? r(null, y) : r(x());
  }
  return t.OPTIONS = e, t;
}
let pfe = (e) => e.substr(0, e.length - 1).substr(1);
function lA(e, t, n, r = n) {
  let i, s, a;
  return t ? (zu.forEach(t, (o, l, c) => {
    let u = l ? pfe(o) : o;
    if (e = e.resolve({
      context: r,
      parent: i,
      value: n
    }), e.innerType) {
      let f = c ? parseInt(u, 10) : 0;
      if (n && f >= n.length)
        throw new Error(`Yup.reach cannot resolve an array item at index: ${o}, in the path: ${t}. because there is no value at that index. `);
      i = n, n = n && n[f], e = e.innerType;
    }
    if (!c) {
      if (!e.fields || !e.fields[u])
        throw new Error(`The schema does not contain the path: ${t}. (failed at: ${a} which is a type: "${e._type}")`);
      i = n, n = n && n[u], e = e.fields[u];
    }
    s = u, a = l ? "[" + o + "]" : "." + o;
  }), {
    schema: e,
    parent: i,
    parentPath: s
  }) : {
    parent: i,
    parentPath: t,
    schema: e
  };
}
const gfe = (e, t, n, r) => lA(e, t, n, r).schema;
class Yc {
  constructor() {
    this.list = void 0, this.refs = void 0, this.list = /* @__PURE__ */ new Set(), this.refs = /* @__PURE__ */ new Map();
  }
  get size() {
    return this.list.size + this.refs.size;
  }
  describe() {
    const t = [];
    for (const n of this.list)
      t.push(n);
    for (const [, n] of this.refs)
      t.push(n.describe());
    return t;
  }
  toArray() {
    return Array.from(this.list).concat(Array.from(this.refs.values()));
  }
  resolveAll(t) {
    return this.toArray().reduce((n, r) => n.concat(sr.isRef(r) ? t(r) : r), []);
  }
  add(t) {
    sr.isRef(t) ? this.refs.set(t.key, t) : this.list.add(t);
  }
  delete(t) {
    sr.isRef(t) ? this.refs.delete(t.key) : this.list.delete(t);
  }
  clone() {
    const t = new Yc();
    return t.list = new Set(this.list), t.refs = new Map(this.refs), t;
  }
  merge(t, n) {
    const r = this.clone();
    return t.list.forEach((i) => r.add(i)), t.refs.forEach((i) => r.add(i)), n.list.forEach((i) => r.delete(i)), n.refs.forEach((i) => r.delete(i)), r;
  }
}
function cn() {
  return cn = Object.assign || function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, cn.apply(this, arguments);
}
class Ct {
  constructor(t) {
    this.deps = [], this.tests = void 0, this.transforms = void 0, this.conditions = [], this._mutate = void 0, this._typeError = void 0, this._whitelist = new Yc(), this._blacklist = new Yc(), this.exclusiveTests = /* @__PURE__ */ Object.create(null), this.spec = void 0, this.tests = [], this.transforms = [], this.withMutation(() => {
      this.typeError(ri.notType);
    }), this.type = (t == null ? void 0 : t.type) || "mixed", this.spec = cn({
      strip: !1,
      strict: !1,
      abortEarly: !0,
      recursive: !0,
      nullable: !1,
      presence: "optional"
    }, t == null ? void 0 : t.spec);
  }
  // TODO: remove
  get _type() {
    return this.type;
  }
  _typeCheck(t) {
    return !0;
  }
  clone(t) {
    if (this._mutate)
      return t && Object.assign(this.spec, t), this;
    const n = Object.create(Object.getPrototypeOf(this));
    return n.type = this.type, n._typeError = this._typeError, n._whitelistError = this._whitelistError, n._blacklistError = this._blacklistError, n._whitelist = this._whitelist.clone(), n._blacklist = this._blacklist.clone(), n.exclusiveTests = cn({}, this.exclusiveTests), n.deps = [...this.deps], n.conditions = [...this.conditions], n.tests = [...this.tests], n.transforms = [...this.transforms], n.spec = S0(cn({}, this.spec, t)), n;
  }
  label(t) {
    let n = this.clone();
    return n.spec.label = t, n;
  }
  meta(...t) {
    if (t.length === 0)
      return this.spec.meta;
    let n = this.clone();
    return n.spec.meta = Object.assign(n.spec.meta || {}, t[0]), n;
  }
  // withContext<TContext extends AnyObject>(): BaseSchema<
  //   TCast,
  //   TContext,
  //   TOutput
  // > {
  //   return this as any;
  // }
  withMutation(t) {
    let n = this._mutate;
    this._mutate = !0;
    let r = t(this);
    return this._mutate = n, r;
  }
  concat(t) {
    if (!t || t === this)
      return this;
    if (t.type !== this.type && this.type !== "mixed")
      throw new TypeError(`You cannot \`concat()\` schema's of different types: ${this.type} and ${t.type}`);
    let n = this, r = t.clone();
    const i = cn({}, n.spec, r.spec);
    return r.spec = i, r._typeError || (r._typeError = n._typeError), r._whitelistError || (r._whitelistError = n._whitelistError), r._blacklistError || (r._blacklistError = n._blacklistError), r._whitelist = n._whitelist.merge(t._whitelist, t._blacklist), r._blacklist = n._blacklist.merge(t._blacklist, t._whitelist), r.tests = n.tests, r.exclusiveTests = n.exclusiveTests, r.withMutation((s) => {
      t.tests.forEach((a) => {
        s.test(a.OPTIONS);
      });
    }), r.transforms = [...n.transforms, ...r.transforms], r;
  }
  isType(t) {
    return this.spec.nullable && t === null ? !0 : this._typeCheck(t);
  }
  resolve(t) {
    let n = this;
    if (n.conditions.length) {
      let r = n.conditions;
      n = n.clone(), n.conditions = [], n = r.reduce((i, s) => s.resolve(i, t), n), n = n.resolve(t);
    }
    return n;
  }
  /**
   *
   * @param {*} value
   * @param {Object} options
   * @param {*=} options.parent
   * @param {*=} options.context
   */
  cast(t, n = {}) {
    let r = this.resolve(cn({
      value: t
    }, n)), i = r._cast(t, n);
    if (t !== void 0 && n.assert !== !1 && r.isType(i) !== !0) {
      let s = Ms(t), a = Ms(i);
      throw new TypeError(`The value of ${n.path || "field"} could not be cast to a value that satisfies the schema type: "${r._type}". 

attempted value: ${s} 
` + (a !== s ? `result of cast: ${a}` : ""));
    }
    return i;
  }
  _cast(t, n) {
    let r = t === void 0 ? t : this.transforms.reduce((i, s) => s.call(this, i, t, this), t);
    return r === void 0 && (r = this.getDefault()), r;
  }
  _validate(t, n = {}, r) {
    let {
      sync: i,
      path: s,
      from: a = [],
      originalValue: o = t,
      strict: l = this.spec.strict,
      abortEarly: c = this.spec.abortEarly
    } = n, u = t;
    l || (u = this._cast(u, cn({
      assert: !1
    }, n)));
    let f = {
      value: u,
      path: s,
      options: n,
      originalValue: o,
      schema: this,
      label: this.spec.label,
      sync: i,
      from: a
    }, d = [];
    this._typeError && d.push(this._typeError);
    let h = [];
    this._whitelistError && h.push(this._whitelistError), this._blacklistError && h.push(this._blacklistError), zc({
      args: f,
      value: u,
      path: s,
      sync: i,
      tests: d,
      endEarly: c
    }, (p) => {
      if (p)
        return void r(p, u);
      zc({
        tests: this.tests.concat(h),
        args: f,
        path: s,
        sync: i,
        value: u,
        endEarly: c
      }, r);
    });
  }
  validate(t, n, r) {
    let i = this.resolve(cn({}, n, {
      value: t
    }));
    return typeof r == "function" ? i._validate(t, n, r) : new Promise((s, a) => i._validate(t, n, (o, l) => {
      o ? a(o) : s(l);
    }));
  }
  validateSync(t, n) {
    let r = this.resolve(cn({}, n, {
      value: t
    })), i;
    return r._validate(t, cn({}, n, {
      sync: !0
    }), (s, a) => {
      if (s)
        throw s;
      i = a;
    }), i;
  }
  isValid(t, n) {
    return this.validate(t, n).then(() => !0, (r) => {
      if (qt.isError(r))
        return !1;
      throw r;
    });
  }
  isValidSync(t, n) {
    try {
      return this.validateSync(t, n), !0;
    } catch (r) {
      if (qt.isError(r))
        return !1;
      throw r;
    }
  }
  _getDefault() {
    let t = this.spec.default;
    return t == null ? t : typeof t == "function" ? t.call(this) : S0(t);
  }
  getDefault(t) {
    return this.resolve(t || {})._getDefault();
  }
  default(t) {
    return arguments.length === 0 ? this._getDefault() : this.clone({
      default: t
    });
  }
  strict(t = !0) {
    let n = this.clone();
    return n.spec.strict = t, n;
  }
  _isPresent(t) {
    return t != null;
  }
  defined(t = ri.defined) {
    return this.test({
      message: t,
      name: "defined",
      exclusive: !0,
      test(n) {
        return n !== void 0;
      }
    });
  }
  required(t = ri.required) {
    return this.clone({
      presence: "required"
    }).withMutation((n) => n.test({
      message: t,
      name: "required",
      exclusive: !0,
      test(r) {
        return this.schema._isPresent(r);
      }
    }));
  }
  notRequired() {
    let t = this.clone({
      presence: "optional"
    });
    return t.tests = t.tests.filter((n) => n.OPTIONS.name !== "required"), t;
  }
  nullable(t = !0) {
    return this.clone({
      nullable: t !== !1
    });
  }
  transform(t) {
    let n = this.clone();
    return n.transforms.push(t), n;
  }
  /**
   * Adds a test function to the schema's queue of tests.
   * tests can be exclusive or non-exclusive.
   *
   * - exclusive tests, will replace any existing tests of the same name.
   * - non-exclusive: can be stacked
   *
   * If a non-exclusive test is added to a schema with an exclusive test of the same name
   * the exclusive test is removed and further tests of the same name will be stacked.
   *
   * If an exclusive test is added to a schema with non-exclusive tests of the same name
   * the previous tests are removed and further tests of the same name will replace each other.
   */
  test(...t) {
    let n;
    if (t.length === 1 ? typeof t[0] == "function" ? n = {
      test: t[0]
    } : n = t[0] : t.length === 2 ? n = {
      name: t[0],
      test: t[1]
    } : n = {
      name: t[0],
      message: t[1],
      test: t[2]
    }, n.message === void 0 && (n.message = ri.default), typeof n.test != "function")
      throw new TypeError("`test` is a required parameters");
    let r = this.clone(), i = _l(n), s = n.exclusive || n.name && r.exclusiveTests[n.name] === !0;
    if (n.exclusive && !n.name)
      throw new TypeError("Exclusive tests must provide a unique `name` identifying the test");
    return n.name && (r.exclusiveTests[n.name] = !!n.exclusive), r.tests = r.tests.filter((a) => !(a.OPTIONS.name === n.name && (s || a.OPTIONS.test === i.OPTIONS.test))), r.tests.push(i), r;
  }
  when(t, n) {
    !Array.isArray(t) && typeof t != "string" && (n = t, t = ".");
    let r = this.clone(), i = YE(t).map((s) => new sr(s));
    return i.forEach((s) => {
      s.isSibling && r.deps.push(s.key);
    }), r.conditions.push(new Qse(i, n)), r;
  }
  typeError(t) {
    let n = this.clone();
    return n._typeError = _l({
      message: t,
      name: "typeError",
      test(r) {
        return r !== void 0 && !this.schema.isType(r) ? this.createError({
          params: {
            type: this.schema._type
          }
        }) : !0;
      }
    }), n;
  }
  oneOf(t, n = ri.oneOf) {
    let r = this.clone();
    return t.forEach((i) => {
      r._whitelist.add(i), r._blacklist.delete(i);
    }), r._whitelistError = _l({
      message: n,
      name: "oneOf",
      test(i) {
        if (i === void 0)
          return !0;
        let s = this.schema._whitelist, a = s.resolveAll(this.resolve);
        return a.includes(i) ? !0 : this.createError({
          params: {
            values: s.toArray().join(", "),
            resolved: a
          }
        });
      }
    }), r;
  }
  notOneOf(t, n = ri.notOneOf) {
    let r = this.clone();
    return t.forEach((i) => {
      r._blacklist.add(i), r._whitelist.delete(i);
    }), r._blacklistError = _l({
      message: n,
      name: "notOneOf",
      test(i) {
        let s = this.schema._blacklist, a = s.resolveAll(this.resolve);
        return a.includes(i) ? this.createError({
          params: {
            values: s.toArray().join(", "),
            resolved: a
          }
        }) : !0;
      }
    }), r;
  }
  strip(t = !0) {
    let n = this.clone();
    return n.spec.strip = t, n;
  }
  describe() {
    const t = this.clone(), {
      label: n,
      meta: r
    } = t.spec;
    return {
      meta: r,
      label: n,
      type: t.type,
      oneOf: t._whitelist.describe(),
      notOneOf: t._blacklist.describe(),
      tests: t.tests.map((s) => ({
        name: s.OPTIONS.name,
        params: s.OPTIONS.params
      })).filter((s, a, o) => o.findIndex((l) => l.name === s.name) === a)
    };
  }
}
Ct.prototype.__isYupSchema__ = !0;
for (const e of ["validate", "validateSync"])
  Ct.prototype[`${e}At`] = function(t, n, r = {}) {
    const {
      parent: i,
      parentPath: s,
      schema: a
    } = lA(this, t, n, r.context);
    return a[e](i && i[s], cn({}, r, {
      parent: i,
      path: t
    }));
  };
for (const e of ["equals", "is"])
  Ct.prototype[e] = Ct.prototype.oneOf;
for (const e of ["not", "nope"])
  Ct.prototype[e] = Ct.prototype.notOneOf;
Ct.prototype.optional = Ct.prototype.notRequired;
const Rp = Ct;
function cA() {
  return new Rp();
}
cA.prototype = Rp.prototype;
const nt = (e) => e == null;
function j0() {
  return new Bp();
}
class Bp extends Ct {
  constructor() {
    super({
      type: "boolean"
    }), this.withMutation(() => {
      this.transform(function(t) {
        if (!this.isType(t)) {
          if (/^(true|1)$/i.test(String(t)))
            return !0;
          if (/^(false|0)$/i.test(String(t)))
            return !1;
        }
        return t;
      });
    });
  }
  _typeCheck(t) {
    return t instanceof Boolean && (t = t.valueOf()), typeof t == "boolean";
  }
  isTrue(t = O0.isValue) {
    return this.test({
      message: t,
      name: "is-value",
      exclusive: !0,
      params: {
        value: "true"
      },
      test(n) {
        return nt(n) || n === !0;
      }
    });
  }
  isFalse(t = O0.isValue) {
    return this.test({
      message: t,
      name: "is-value",
      exclusive: !0,
      params: {
        value: "false"
      },
      test(n) {
        return nt(n) || n === !1;
      }
    });
  }
}
j0.prototype = Bp.prototype;
let vfe = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i, mfe = /^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i, yfe = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i, xfe = (e) => nt(e) || e === e.trim(), bfe = {}.toString();
function uA() {
  return new Np();
}
class Np extends Ct {
  constructor() {
    super({
      type: "string"
    }), this.withMutation(() => {
      this.transform(function(t) {
        if (this.isType(t) || Array.isArray(t))
          return t;
        const n = t != null && t.toString ? t.toString() : t;
        return n === bfe ? t : n;
      });
    });
  }
  _typeCheck(t) {
    return t instanceof String && (t = t.valueOf()), typeof t == "string";
  }
  _isPresent(t) {
    return super._isPresent(t) && !!t.length;
  }
  length(t, n = _n.length) {
    return this.test({
      message: n,
      name: "length",
      exclusive: !0,
      params: {
        length: t
      },
      test(r) {
        return nt(r) || r.length === this.resolve(t);
      }
    });
  }
  min(t, n = _n.min) {
    return this.test({
      message: n,
      name: "min",
      exclusive: !0,
      params: {
        min: t
      },
      test(r) {
        return nt(r) || r.length >= this.resolve(t);
      }
    });
  }
  max(t, n = _n.max) {
    return this.test({
      name: "max",
      exclusive: !0,
      message: n,
      params: {
        max: t
      },
      test(r) {
        return nt(r) || r.length <= this.resolve(t);
      }
    });
  }
  matches(t, n) {
    let r = !1, i, s;
    return n && (typeof n == "object" ? {
      excludeEmptyString: r = !1,
      message: i,
      name: s
    } = n : i = n), this.test({
      name: s || "matches",
      message: i || _n.matches,
      params: {
        regex: t
      },
      test: (a) => nt(a) || a === "" && r || a.search(t) !== -1
    });
  }
  email(t = _n.email) {
    return this.matches(vfe, {
      name: "email",
      message: t,
      excludeEmptyString: !0
    });
  }
  url(t = _n.url) {
    return this.matches(mfe, {
      name: "url",
      message: t,
      excludeEmptyString: !0
    });
  }
  uuid(t = _n.uuid) {
    return this.matches(yfe, {
      name: "uuid",
      message: t,
      excludeEmptyString: !1
    });
  }
  //-- transforms --
  ensure() {
    return this.default("").transform((t) => t === null ? "" : t);
  }
  trim(t = _n.trim) {
    return this.transform((n) => n != null ? n.trim() : n).test({
      message: t,
      name: "trim",
      test: xfe
    });
  }
  lowercase(t = _n.lowercase) {
    return this.transform((n) => nt(n) ? n : n.toLowerCase()).test({
      message: t,
      name: "string_case",
      exclusive: !0,
      test: (n) => nt(n) || n === n.toLowerCase()
    });
  }
  uppercase(t = _n.uppercase) {
    return this.transform((n) => nt(n) ? n : n.toUpperCase()).test({
      message: t,
      name: "string_case",
      exclusive: !0,
      test: (n) => nt(n) || n === n.toUpperCase()
    });
  }
}
uA.prototype = Np.prototype;
let _fe = (e) => e != +e;
function fA() {
  return new Lp();
}
class Lp extends Ct {
  constructor() {
    super({
      type: "number"
    }), this.withMutation(() => {
      this.transform(function(t) {
        let n = t;
        if (typeof n == "string") {
          if (n = n.replace(/\s/g, ""), n === "")
            return NaN;
          n = +n;
        }
        return this.isType(n) ? n : parseFloat(n);
      });
    });
  }
  _typeCheck(t) {
    return t instanceof Number && (t = t.valueOf()), typeof t == "number" && !_fe(t);
  }
  min(t, n = Er.min) {
    return this.test({
      message: n,
      name: "min",
      exclusive: !0,
      params: {
        min: t
      },
      test(r) {
        return nt(r) || r >= this.resolve(t);
      }
    });
  }
  max(t, n = Er.max) {
    return this.test({
      message: n,
      name: "max",
      exclusive: !0,
      params: {
        max: t
      },
      test(r) {
        return nt(r) || r <= this.resolve(t);
      }
    });
  }
  lessThan(t, n = Er.lessThan) {
    return this.test({
      message: n,
      name: "max",
      exclusive: !0,
      params: {
        less: t
      },
      test(r) {
        return nt(r) || r < this.resolve(t);
      }
    });
  }
  moreThan(t, n = Er.moreThan) {
    return this.test({
      message: n,
      name: "min",
      exclusive: !0,
      params: {
        more: t
      },
      test(r) {
        return nt(r) || r > this.resolve(t);
      }
    });
  }
  positive(t = Er.positive) {
    return this.moreThan(0, t);
  }
  negative(t = Er.negative) {
    return this.lessThan(0, t);
  }
  integer(t = Er.integer) {
    return this.test({
      name: "integer",
      message: t,
      test: (n) => nt(n) || Number.isInteger(n)
    });
  }
  truncate() {
    return this.transform((t) => nt(t) ? t : t | 0);
  }
  round(t) {
    var n;
    let r = ["ceil", "floor", "round", "trunc"];
    if (t = ((n = t) == null ? void 0 : n.toLowerCase()) || "round", t === "trunc")
      return this.truncate();
    if (r.indexOf(t.toLowerCase()) === -1)
      throw new TypeError("Only valid options for round() are: " + r.join(", "));
    return this.transform((i) => nt(i) ? i : Math[t](i));
  }
}
fA.prototype = Lp.prototype;
var wfe = /^(\d{4}|[+\-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,\.](\d{1,}))?)?(?:(Z)|([+\-])(\d{2})(?::?(\d{2}))?)?)?$/;
function $fe(e) {
  var t = [1, 4, 5, 6, 7, 10, 11], n = 0, r, i;
  if (i = wfe.exec(e)) {
    for (var s = 0, a; a = t[s]; ++s)
      i[a] = +i[a] || 0;
    i[2] = (+i[2] || 1) - 1, i[3] = +i[3] || 1, i[7] = i[7] ? String(i[7]).substr(0, 3) : 0, (i[8] === void 0 || i[8] === "") && (i[9] === void 0 || i[9] === "") ? r = +new Date(i[1], i[2], i[3], i[4], i[5], i[6], i[7]) : (i[8] !== "Z" && i[9] !== void 0 && (n = i[10] * 60 + i[11], i[9] === "+" && (n = 0 - n)), r = Date.UTC(i[1], i[2], i[3], i[4], i[5] + n, i[6], i[7]));
  } else
    r = Date.parse ? Date.parse(e) : NaN;
  return r;
}
let jp = /* @__PURE__ */ new Date(""), Efe = (e) => Object.prototype.toString.call(e) === "[object Date]";
function zp() {
  return new Vu();
}
class Vu extends Ct {
  constructor() {
    super({
      type: "date"
    }), this.withMutation(() => {
      this.transform(function(t) {
        return this.isType(t) ? t : (t = $fe(t), isNaN(t) ? jp : new Date(t));
      });
    });
  }
  _typeCheck(t) {
    return Efe(t) && !isNaN(t.getTime());
  }
  prepareParam(t, n) {
    let r;
    if (sr.isRef(t))
      r = t;
    else {
      let i = this.cast(t);
      if (!this._typeCheck(i))
        throw new TypeError(`\`${n}\` must be a Date or a value that can be \`cast()\` to a Date`);
      r = i;
    }
    return r;
  }
  min(t, n = T0.min) {
    let r = this.prepareParam(t, "min");
    return this.test({
      message: n,
      name: "min",
      exclusive: !0,
      params: {
        min: t
      },
      test(i) {
        return nt(i) || i >= this.resolve(r);
      }
    });
  }
  max(t, n = T0.max) {
    let r = this.prepareParam(t, "max");
    return this.test({
      message: n,
      name: "max",
      exclusive: !0,
      params: {
        max: t
      },
      test(i) {
        return nt(i) || i <= this.resolve(r);
      }
    });
  }
}
Vu.INVALID_DATE = jp;
zp.prototype = Vu.prototype;
zp.INVALID_DATE = jp;
function Afe(e, t, n, r) {
  var i = -1, s = e == null ? 0 : e.length;
  for (r && s && (n = e[++i]); ++i < s; )
    n = t(n, e[i], i, e);
  return n;
}
var kfe = Afe;
function Cfe(e) {
  return function(t) {
    return e == null ? void 0 : e[t];
  };
}
var Dfe = Cfe, Sfe = Dfe, Tfe = {
  // Latin-1 Supplement block.
  À: "A",
  Á: "A",
  Â: "A",
  Ã: "A",
  Ä: "A",
  Å: "A",
  à: "a",
  á: "a",
  â: "a",
  ã: "a",
  ä: "a",
  å: "a",
  Ç: "C",
  ç: "c",
  Ð: "D",
  ð: "d",
  È: "E",
  É: "E",
  Ê: "E",
  Ë: "E",
  è: "e",
  é: "e",
  ê: "e",
  ë: "e",
  Ì: "I",
  Í: "I",
  Î: "I",
  Ï: "I",
  ì: "i",
  í: "i",
  î: "i",
  ï: "i",
  Ñ: "N",
  ñ: "n",
  Ò: "O",
  Ó: "O",
  Ô: "O",
  Õ: "O",
  Ö: "O",
  Ø: "O",
  ò: "o",
  ó: "o",
  ô: "o",
  õ: "o",
  ö: "o",
  ø: "o",
  Ù: "U",
  Ú: "U",
  Û: "U",
  Ü: "U",
  ù: "u",
  ú: "u",
  û: "u",
  ü: "u",
  Ý: "Y",
  ý: "y",
  ÿ: "y",
  Æ: "Ae",
  æ: "ae",
  Þ: "Th",
  þ: "th",
  ß: "ss",
  // Latin Extended-A block.
  Ā: "A",
  Ă: "A",
  Ą: "A",
  ā: "a",
  ă: "a",
  ą: "a",
  Ć: "C",
  Ĉ: "C",
  Ċ: "C",
  Č: "C",
  ć: "c",
  ĉ: "c",
  ċ: "c",
  č: "c",
  Ď: "D",
  Đ: "D",
  ď: "d",
  đ: "d",
  Ē: "E",
  Ĕ: "E",
  Ė: "E",
  Ę: "E",
  Ě: "E",
  ē: "e",
  ĕ: "e",
  ė: "e",
  ę: "e",
  ě: "e",
  Ĝ: "G",
  Ğ: "G",
  Ġ: "G",
  Ģ: "G",
  ĝ: "g",
  ğ: "g",
  ġ: "g",
  ģ: "g",
  Ĥ: "H",
  Ħ: "H",
  ĥ: "h",
  ħ: "h",
  Ĩ: "I",
  Ī: "I",
  Ĭ: "I",
  Į: "I",
  İ: "I",
  ĩ: "i",
  ī: "i",
  ĭ: "i",
  į: "i",
  ı: "i",
  Ĵ: "J",
  ĵ: "j",
  Ķ: "K",
  ķ: "k",
  ĸ: "k",
  Ĺ: "L",
  Ļ: "L",
  Ľ: "L",
  Ŀ: "L",
  Ł: "L",
  ĺ: "l",
  ļ: "l",
  ľ: "l",
  ŀ: "l",
  ł: "l",
  Ń: "N",
  Ņ: "N",
  Ň: "N",
  Ŋ: "N",
  ń: "n",
  ņ: "n",
  ň: "n",
  ŋ: "n",
  Ō: "O",
  Ŏ: "O",
  Ő: "O",
  ō: "o",
  ŏ: "o",
  ő: "o",
  Ŕ: "R",
  Ŗ: "R",
  Ř: "R",
  ŕ: "r",
  ŗ: "r",
  ř: "r",
  Ś: "S",
  Ŝ: "S",
  Ş: "S",
  Š: "S",
  ś: "s",
  ŝ: "s",
  ş: "s",
  š: "s",
  Ţ: "T",
  Ť: "T",
  Ŧ: "T",
  ţ: "t",
  ť: "t",
  ŧ: "t",
  Ũ: "U",
  Ū: "U",
  Ŭ: "U",
  Ů: "U",
  Ű: "U",
  Ų: "U",
  ũ: "u",
  ū: "u",
  ŭ: "u",
  ů: "u",
  ű: "u",
  ų: "u",
  Ŵ: "W",
  ŵ: "w",
  Ŷ: "Y",
  ŷ: "y",
  Ÿ: "Y",
  Ź: "Z",
  Ż: "Z",
  Ž: "Z",
  ź: "z",
  ż: "z",
  ž: "z",
  Ĳ: "IJ",
  ĳ: "ij",
  Œ: "Oe",
  œ: "oe",
  ŉ: "'n",
  ſ: "s"
}, Ofe = Sfe(Tfe), Mfe = Ofe, Ffe = Mfe, Pfe = Bo, Ife = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Rfe = "\\u0300-\\u036f", Bfe = "\\ufe20-\\ufe2f", Nfe = "\\u20d0-\\u20ff", Lfe = Rfe + Bfe + Nfe, jfe = "[" + Lfe + "]", zfe = RegExp(jfe, "g");
function Vfe(e) {
  return e = Pfe(e), e && e.replace(Ife, Ffe).replace(zfe, "");
}
var Hfe = Vfe, Wfe = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function Ufe(e) {
  return e.match(Wfe) || [];
}
var Yfe = Ufe, qfe = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function Gfe(e) {
  return qfe.test(e);
}
var Xfe = Gfe, dA = "\\ud800-\\udfff", Zfe = "\\u0300-\\u036f", Kfe = "\\ufe20-\\ufe2f", Jfe = "\\u20d0-\\u20ff", Qfe = Zfe + Kfe + Jfe, hA = "\\u2700-\\u27bf", pA = "a-z\\xdf-\\xf6\\xf8-\\xff", ede = "\\xac\\xb1\\xd7\\xf7", tde = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", nde = "\\u2000-\\u206f", rde = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", gA = "A-Z\\xc0-\\xd6\\xd8-\\xde", ide = "\\ufe0e\\ufe0f", vA = ede + tde + nde + rde, mA = "['’]", eb = "[" + vA + "]", sde = "[" + Qfe + "]", yA = "\\d+", ade = "[" + hA + "]", xA = "[" + pA + "]", bA = "[^" + dA + vA + yA + hA + pA + gA + "]", ode = "\\ud83c[\\udffb-\\udfff]", lde = "(?:" + sde + "|" + ode + ")", cde = "[^" + dA + "]", _A = "(?:\\ud83c[\\udde6-\\uddff]){2}", wA = "[\\ud800-\\udbff][\\udc00-\\udfff]", es = "[" + gA + "]", ude = "\\u200d", tb = "(?:" + xA + "|" + bA + ")", fde = "(?:" + es + "|" + bA + ")", nb = "(?:" + mA + "(?:d|ll|m|re|s|t|ve))?", rb = "(?:" + mA + "(?:D|LL|M|RE|S|T|VE))?", $A = lde + "?", EA = "[" + ide + "]?", dde = "(?:" + ude + "(?:" + [cde, _A, wA].join("|") + ")" + EA + $A + ")*", hde = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", pde = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", gde = EA + $A + dde, vde = "(?:" + [ade, _A, wA].join("|") + ")" + gde, mde = RegExp([
  es + "?" + xA + "+" + nb + "(?=" + [eb, es, "$"].join("|") + ")",
  fde + "+" + rb + "(?=" + [eb, es + tb, "$"].join("|") + ")",
  es + "?" + tb + "+" + nb,
  es + "+" + rb,
  pde,
  hde,
  yA,
  vde
].join("|"), "g");
function yde(e) {
  return e.match(mde) || [];
}
var xde = yde, bde = Yfe, _de = Xfe, wde = Bo, $de = xde;
function Ede(e, t, n) {
  return e = wde(e), t = n ? void 0 : t, t === void 0 ? _de(e) ? $de(e) : bde(e) : e.match(t) || [];
}
var Ade = Ede, kde = kfe, Cde = Hfe, Dde = Ade, Sde = "['’]", Tde = RegExp(Sde, "g");
function Ode(e) {
  return function(t) {
    return kde(Dde(Cde(t).replace(Tde, "")), e, "");
  };
}
var AA = Ode, Mde = AA, Fde = Mde(function(e, t, n) {
  return e + (n ? "_" : "") + t.toLowerCase();
}), Pde = Fde;
const ib = /* @__PURE__ */ Vr(Pde);
function Ide(e, t, n) {
  var r = -1, i = e.length;
  t < 0 && (t = -t > i ? 0 : i + t), n = n > i ? i : n, n < 0 && (n += i), i = t > n ? 0 : n - t >>> 0, t >>>= 0;
  for (var s = Array(i); ++r < i; )
    s[r] = e[r + t];
  return s;
}
var Rde = Ide, Bde = Rde;
function Nde(e, t, n) {
  var r = e.length;
  return n = n === void 0 ? r : n, !t && n >= r ? e : Bde(e, t, n);
}
var Lde = Nde, jde = "\\ud800-\\udfff", zde = "\\u0300-\\u036f", Vde = "\\ufe20-\\ufe2f", Hde = "\\u20d0-\\u20ff", Wde = zde + Vde + Hde, Ude = "\\ufe0e\\ufe0f", Yde = "\\u200d", qde = RegExp("[" + Yde + jde + Wde + Ude + "]");
function Gde(e) {
  return qde.test(e);
}
var kA = Gde;
function Xde(e) {
  return e.split("");
}
var Zde = Xde, CA = "\\ud800-\\udfff", Kde = "\\u0300-\\u036f", Jde = "\\ufe20-\\ufe2f", Qde = "\\u20d0-\\u20ff", e0e = Kde + Jde + Qde, t0e = "\\ufe0e\\ufe0f", n0e = "[" + CA + "]", z0 = "[" + e0e + "]", V0 = "\\ud83c[\\udffb-\\udfff]", r0e = "(?:" + z0 + "|" + V0 + ")", DA = "[^" + CA + "]", SA = "(?:\\ud83c[\\udde6-\\uddff]){2}", TA = "[\\ud800-\\udbff][\\udc00-\\udfff]", i0e = "\\u200d", OA = r0e + "?", MA = "[" + t0e + "]?", s0e = "(?:" + i0e + "(?:" + [DA, SA, TA].join("|") + ")" + MA + OA + ")*", a0e = MA + OA + s0e, o0e = "(?:" + [DA + z0 + "?", z0, SA, TA, n0e].join("|") + ")", l0e = RegExp(V0 + "(?=" + V0 + ")|" + o0e + a0e, "g");
function c0e(e) {
  return e.match(l0e) || [];
}
var u0e = c0e, f0e = Zde, d0e = kA, h0e = u0e;
function p0e(e) {
  return d0e(e) ? h0e(e) : f0e(e);
}
var g0e = p0e, v0e = Lde, m0e = kA, y0e = g0e, x0e = Bo;
function b0e(e) {
  return function(t) {
    t = x0e(t);
    var n = m0e(t) ? y0e(t) : void 0, r = n ? n[0] : t.charAt(0), i = n ? v0e(n, 1).join("") : t.slice(1);
    return r[e]() + i;
  };
}
var _0e = b0e, w0e = _0e, $0e = w0e("toUpperCase"), E0e = $0e, A0e = Bo, k0e = E0e;
function C0e(e) {
  return k0e(A0e(e).toLowerCase());
}
var D0e = C0e, S0e = D0e, T0e = AA, O0e = T0e(function(e, t, n) {
  return t = t.toLowerCase(), e + (n ? S0e(t) : t);
}), M0e = O0e;
const F0e = /* @__PURE__ */ Vr(M0e);
var P0e = qE, I0e = ZE, R0e = sA;
function B0e(e, t) {
  var n = {};
  return t = R0e(t), I0e(e, function(r, i, s) {
    P0e(n, t(r, i, s), r);
  }), n;
}
var N0e = B0e;
const L0e = /* @__PURE__ */ Vr(N0e);
var Vp = { exports: {} };
Vp.exports = function(e) {
  return FA(j0e(e), e);
};
Vp.exports.array = FA;
function FA(e, t) {
  var n = e.length, r = new Array(n), i = {}, s = n, a = z0e(t), o = V0e(e);
  for (t.forEach(function(c) {
    if (!o.has(c[0]) || !o.has(c[1]))
      throw new Error("Unknown node. There is an unknown node in the supplied edges.");
  }); s--; )
    i[s] || l(e[s], s, /* @__PURE__ */ new Set());
  return r;
  function l(c, u, f) {
    if (f.has(c)) {
      var d;
      try {
        d = ", node was:" + JSON.stringify(c);
      } catch {
        d = "";
      }
      throw new Error("Cyclic dependency" + d);
    }
    if (!o.has(c))
      throw new Error("Found unknown node. Make sure to provided all involved nodes. Unknown node: " + JSON.stringify(c));
    if (!i[u]) {
      i[u] = !0;
      var h = a.get(c) || /* @__PURE__ */ new Set();
      if (h = Array.from(h), u = h.length) {
        f.add(c);
        do {
          var p = h[--u];
          l(p, o.get(p), f);
        } while (u);
        f.delete(c);
      }
      r[--n] = c;
    }
  }
}
function j0e(e) {
  for (var t = /* @__PURE__ */ new Set(), n = 0, r = e.length; n < r; n++) {
    var i = e[n];
    t.add(i[0]), t.add(i[1]);
  }
  return Array.from(t);
}
function z0e(e) {
  for (var t = /* @__PURE__ */ new Map(), n = 0, r = e.length; n < r; n++) {
    var i = e[n];
    t.has(i[0]) || t.set(i[0], /* @__PURE__ */ new Set()), t.has(i[1]) || t.set(i[1], /* @__PURE__ */ new Set()), t.get(i[0]).add(i[1]);
  }
  return t;
}
function V0e(e) {
  for (var t = /* @__PURE__ */ new Map(), n = 0, r = e.length; n < r; n++)
    t.set(e[n], n);
  return t;
}
var H0e = Vp.exports;
const W0e = /* @__PURE__ */ Vr(H0e);
function U0e(e, t = []) {
  let n = [], r = /* @__PURE__ */ new Set(), i = new Set(t.map(([a, o]) => `${a}-${o}`));
  function s(a, o) {
    let l = zu.split(a)[0];
    r.add(l), i.has(`${o}-${l}`) || n.push([o, l]);
  }
  for (const a in e)
    if (jc(e, a)) {
      let o = e[a];
      r.add(a), sr.isRef(o) && o.isSibling ? s(o.path, a) : Zs(o) && "deps" in o && o.deps.forEach((l) => s(l, a));
    }
  return W0e.array(Array.from(r), n).reverse();
}
function sb(e, t) {
  let n = 1 / 0;
  return e.some((r, i) => {
    var s;
    if (((s = t.path) == null ? void 0 : s.indexOf(r)) !== -1)
      return n = i, !0;
  }), n;
}
function PA(e) {
  return (t, n) => sb(e, t) - sb(e, n);
}
function is() {
  return is = Object.assign || function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, is.apply(this, arguments);
}
let ab = (e) => Object.prototype.toString.call(e) === "[object Object]";
function Y0e(e, t) {
  let n = Object.keys(e.fields);
  return Object.keys(t).filter((r) => n.indexOf(r) === -1);
}
const q0e = PA([]);
class Hp extends Ct {
  constructor(t) {
    super({
      type: "object"
    }), this.fields = /* @__PURE__ */ Object.create(null), this._sortErrors = q0e, this._nodes = [], this._excludedEdges = [], this.withMutation(() => {
      this.transform(function(r) {
        if (typeof r == "string")
          try {
            r = JSON.parse(r);
          } catch {
            r = null;
          }
        return this.isType(r) ? r : null;
      }), t && this.shape(t);
    });
  }
  _typeCheck(t) {
    return ab(t) || typeof t == "function";
  }
  _cast(t, n = {}) {
    var r;
    let i = super._cast(t, n);
    if (i === void 0)
      return this.getDefault();
    if (!this._typeCheck(i))
      return i;
    let s = this.fields, a = (r = n.stripUnknown) != null ? r : this.spec.noUnknown, o = this._nodes.concat(Object.keys(i).filter((f) => this._nodes.indexOf(f) === -1)), l = {}, c = is({}, n, {
      parent: l,
      __validating: n.__validating || !1
    }), u = !1;
    for (const f of o) {
      let d = s[f], h = jc(i, f);
      if (d) {
        let p, g = i[f];
        c.path = (n.path ? `${n.path}.` : "") + f, d = d.resolve({
          value: g,
          context: n.context,
          parent: l
        });
        let v = "spec" in d ? d.spec : void 0, m = v == null ? void 0 : v.strict;
        if (v != null && v.strip) {
          u = u || f in i;
          continue;
        }
        p = !n.__validating || !m ? (
          // TODO: use _cast, this is double resolving
          d.cast(i[f], c)
        ) : i[f], p !== void 0 && (l[f] = p);
      } else
        h && !a && (l[f] = i[f]);
      l[f] !== i[f] && (u = !0);
    }
    return u ? l : i;
  }
  _validate(t, n = {}, r) {
    let i = [], {
      sync: s,
      from: a = [],
      originalValue: o = t,
      abortEarly: l = this.spec.abortEarly,
      recursive: c = this.spec.recursive
    } = n;
    a = [{
      schema: this,
      value: o
    }, ...a], n.__validating = !0, n.originalValue = o, n.from = a, super._validate(t, n, (u, f) => {
      if (u) {
        if (!qt.isError(u) || l)
          return void r(u, f);
        i.push(u);
      }
      if (!c || !ab(f)) {
        r(i[0] || null, f);
        return;
      }
      o = o || f;
      let d = this._nodes.map((h) => (p, g) => {
        let v = h.indexOf(".") === -1 ? (n.path ? `${n.path}.` : "") + h : `${n.path || ""}["${h}"]`, m = this.fields[h];
        if (m && "validate" in m) {
          m.validate(f[h], is({}, n, {
            // @ts-ignore
            path: v,
            from: a,
            // inner fields are always strict:
            // 1. this isn't strict so the casting will also have cast inner values
            // 2. this is strict in which case the nested values weren't cast either
            strict: !0,
            parent: f,
            originalValue: o[h]
          }), g);
          return;
        }
        g(null);
      });
      zc({
        sync: s,
        tests: d,
        value: f,
        errors: i,
        endEarly: l,
        sort: this._sortErrors,
        path: n.path
      }, r);
    });
  }
  clone(t) {
    const n = super.clone(t);
    return n.fields = is({}, this.fields), n._nodes = this._nodes, n._excludedEdges = this._excludedEdges, n._sortErrors = this._sortErrors, n;
  }
  concat(t) {
    let n = super.concat(t), r = n.fields;
    for (let [i, s] of Object.entries(this.fields)) {
      const a = r[i];
      a === void 0 ? r[i] = s : a instanceof Ct && s instanceof Ct && (r[i] = s.concat(a));
    }
    return n.withMutation(() => n.shape(r, this._excludedEdges));
  }
  getDefaultFromShape() {
    let t = {};
    return this._nodes.forEach((n) => {
      const r = this.fields[n];
      t[n] = "default" in r ? r.getDefault() : void 0;
    }), t;
  }
  _getDefault() {
    if ("default" in this.spec)
      return super._getDefault();
    if (this._nodes.length)
      return this.getDefaultFromShape();
  }
  shape(t, n = []) {
    let r = this.clone(), i = Object.assign(r.fields, t);
    return r.fields = i, r._sortErrors = PA(Object.keys(i)), n.length && (Array.isArray(n[0]) || (n = [n]), r._excludedEdges = [...r._excludedEdges, ...n]), r._nodes = U0e(i, r._excludedEdges), r;
  }
  pick(t) {
    const n = {};
    for (const r of t)
      this.fields[r] && (n[r] = this.fields[r]);
    return this.clone().withMutation((r) => (r.fields = {}, r.shape(n)));
  }
  omit(t) {
    const n = this.clone(), r = n.fields;
    n.fields = {};
    for (const i of t)
      delete r[i];
    return n.withMutation(() => n.shape(r));
  }
  from(t, n, r) {
    let i = zu.getter(t, !0);
    return this.transform((s) => {
      if (s == null)
        return s;
      let a = s;
      return jc(s, t) && (a = is({}, s), r || delete a[t], a[n] = i(s)), a;
    });
  }
  noUnknown(t = !0, n = M0.noUnknown) {
    typeof t == "string" && (n = t, t = !0);
    let r = this.test({
      name: "noUnknown",
      exclusive: !0,
      message: n,
      test(i) {
        if (i == null)
          return !0;
        const s = Y0e(this.schema, i);
        return !t || s.length === 0 || this.createError({
          params: {
            unknown: s.join(", ")
          }
        });
      }
    });
    return r.spec.noUnknown = t, r;
  }
  unknown(t = !0, n = M0.noUnknown) {
    return this.noUnknown(!t, n);
  }
  transformKeys(t) {
    return this.transform((n) => n && L0e(n, (r, i) => t(i)));
  }
  camelCase() {
    return this.transformKeys(F0e);
  }
  snakeCase() {
    return this.transformKeys(ib);
  }
  constantCase() {
    return this.transformKeys((t) => ib(t).toUpperCase());
  }
  describe() {
    let t = super.describe();
    return t.fields = aA(this.fields, (n) => n.describe()), t;
  }
}
function IA(e) {
  return new Hp(e);
}
IA.prototype = Hp.prototype;
function qc() {
  return qc = Object.assign || function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, qc.apply(this, arguments);
}
function RA(e) {
  return new Wp(e);
}
class Wp extends Ct {
  constructor(t) {
    super({
      type: "array"
    }), this.innerType = void 0, this.innerType = t, this.withMutation(() => {
      this.transform(function(n) {
        if (typeof n == "string")
          try {
            n = JSON.parse(n);
          } catch {
            n = null;
          }
        return this.isType(n) ? n : null;
      });
    });
  }
  _typeCheck(t) {
    return Array.isArray(t);
  }
  get _subType() {
    return this.innerType;
  }
  _cast(t, n) {
    const r = super._cast(t, n);
    if (!this._typeCheck(r) || !this.innerType)
      return r;
    let i = !1;
    const s = r.map((a, o) => {
      const l = this.innerType.cast(a, qc({}, n, {
        path: `${n.path || ""}[${o}]`
      }));
      return l !== a && (i = !0), l;
    });
    return i ? s : r;
  }
  _validate(t, n = {}, r) {
    var i, s;
    let a = [], o = n.sync, l = n.path, c = this.innerType, u = (i = n.abortEarly) != null ? i : this.spec.abortEarly, f = (s = n.recursive) != null ? s : this.spec.recursive, d = n.originalValue != null ? n.originalValue : t;
    super._validate(t, n, (h, p) => {
      if (h) {
        if (!qt.isError(h) || u)
          return void r(h, p);
        a.push(h);
      }
      if (!f || !c || !this._typeCheck(p)) {
        r(a[0] || null, p);
        return;
      }
      d = d || p;
      let g = new Array(p.length);
      for (let v = 0; v < p.length; v++) {
        let m = p[v], x = `${n.path || ""}[${v}]`, _ = qc({}, n, {
          path: x,
          strict: !0,
          parent: p,
          index: v,
          originalValue: d[v]
        });
        g[v] = (y, b) => c.validate(m, _, b);
      }
      zc({
        sync: o,
        path: l,
        value: p,
        errors: a,
        endEarly: u,
        tests: g
      }, r);
    });
  }
  clone(t) {
    const n = super.clone(t);
    return n.innerType = this.innerType, n;
  }
  concat(t) {
    let n = super.concat(t);
    return n.innerType = this.innerType, t.innerType && (n.innerType = n.innerType ? (
      // @ts-expect-error Lazy doesn't have concat()
      n.innerType.concat(t.innerType)
    ) : t.innerType), n;
  }
  of(t) {
    let n = this.clone();
    if (!Zs(t))
      throw new TypeError("`array.of()` sub-schema must be a valid yup schema not: " + Ms(t));
    return n.innerType = t, n;
  }
  length(t, n = ql.length) {
    return this.test({
      message: n,
      name: "length",
      exclusive: !0,
      params: {
        length: t
      },
      test(r) {
        return nt(r) || r.length === this.resolve(t);
      }
    });
  }
  min(t, n) {
    return n = n || ql.min, this.test({
      message: n,
      name: "min",
      exclusive: !0,
      params: {
        min: t
      },
      // FIXME(ts): Array<typeof T>
      test(r) {
        return nt(r) || r.length >= this.resolve(t);
      }
    });
  }
  max(t, n) {
    return n = n || ql.max, this.test({
      message: n,
      name: "max",
      exclusive: !0,
      params: {
        max: t
      },
      test(r) {
        return nt(r) || r.length <= this.resolve(t);
      }
    });
  }
  ensure() {
    return this.default(() => []).transform((t, n) => this._typeCheck(t) ? t : n == null ? [] : [].concat(n));
  }
  compact(t) {
    let n = t ? (r, i, s) => !t(r, i, s) : (r) => !!r;
    return this.transform((r) => r != null ? r.filter(n) : r);
  }
  describe() {
    let t = super.describe();
    return this.innerType && (t.innerType = this.innerType.describe()), t;
  }
  nullable(t = !0) {
    return super.nullable(t);
  }
  defined() {
    return super.defined();
  }
  required(t) {
    return super.required(t);
  }
}
RA.prototype = Wp.prototype;
function G0e(e) {
  return new X0e(e);
}
class X0e {
  constructor(t) {
    this.type = "lazy", this.__isYupSchema__ = !0, this.__inputType = void 0, this.__outputType = void 0, this._resolve = (n, r = {}) => {
      let i = this.builder(n, r);
      if (!Zs(i))
        throw new TypeError("lazy() functions must return a valid schema");
      return i.resolve(r);
    }, this.builder = t;
  }
  resolve(t) {
    return this._resolve(t.value, t);
  }
  cast(t, n) {
    return this._resolve(t, n).cast(t, n);
  }
  validate(t, n, r) {
    return this._resolve(t, n).validate(t, n, r);
  }
  validateSync(t, n) {
    return this._resolve(t, n).validateSync(t, n);
  }
  validateAt(t, n, r) {
    return this._resolve(n, r).validateAt(t, n, r);
  }
  validateSyncAt(t, n, r) {
    return this._resolve(n, r).validateSyncAt(t, n, r);
  }
  describe() {
    return null;
  }
  isValid(t, n) {
    return this._resolve(t, n).isValid(t, n);
  }
  isValidSync(t, n) {
    return this._resolve(t, n).isValidSync(t, n);
  }
}
function Z0e(e) {
  Object.keys(e).forEach((t) => {
    Object.keys(e[t]).forEach((n) => {
      pne[t][n] = e[t][n];
    });
  });
}
function K0e(e, t, n) {
  if (!e || !Zs(e.prototype))
    throw new TypeError("You must provide a yup schema constructor function");
  if (typeof t != "string")
    throw new TypeError("A Method name must be provided");
  if (typeof n != "function")
    throw new TypeError("Method function must be provided");
  e.prototype[t] = n;
}
const J0e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ArraySchema: Wp,
  BaseSchema: Ct,
  BooleanSchema: Bp,
  DateSchema: Vu,
  MixedSchema: Rp,
  NumberSchema: Lp,
  ObjectSchema: Hp,
  StringSchema: Np,
  ValidationError: qt,
  addMethod: K0e,
  array: RA,
  bool: j0,
  boolean: j0,
  date: zp,
  isSchema: Zs,
  lazy: G0e,
  mixed: cA,
  number: fA,
  object: IA,
  reach: gfe,
  ref: dfe,
  setLocale: Z0e,
  string: uA
}, Symbol.toStringTag, { value: "Module" })), Q0e = {
  只能為英文: "只能為英文",
  必須為數字: "必須為數字",
  必須為網址: "必須為網址",
  不能含特殊字元: "不能含特殊字元",
  必須為電子郵件: "必須為電子郵件"
}, ehe = new ok({
  def: "zh-TW",
  locales: {
    "zh-TW": Q0e,
    "zh-CN": {
      只能為英文: "只能为英文",
      必須為數字: "必须为数字",
      必須為網址: "必须为网址",
      不能含特殊字元: "不能含特殊字元",
      必須為電子郵件: "必须为电子邮件"
    },
    "en-US": {
      只能為英文: "Only English",
      必須為數字: "Must be a number",
      必須為網址: "Must be a URL",
      不能含特殊字元: "Cannot contain special characters",
      必須為電子郵件: "Must be an email"
    }
  }
}), the = (e) => {
  const t = (n) => ehe.key(n).get(e);
  return {
    text: {
      handler: (n, r) => {
        let i = n.string();
        return r && r.min != null && (i = i.min(r.min)), r && r.max != null && (i = i.max(r.max)), i;
      }
    },
    number: {
      handler: (n, r) => {
        let i = n.number();
        return r && r.min != null && (i = i.min(r.min)), r && r.max != null && (i = i.max(r.max)), i.typeError(t("必須為數字"));
      }
    },
    enum: {
      handler: (n, r) => n.string().oneOf((r == null ? void 0 : r.keys) || [])
    },
    email: {
      handler: (n) => n.string().trim().email(t("必須為電子郵件"))
    },
    url: {
      handler: (n) => n.string().trim().url(t("必須為網址"))
    },
    english: {
      handler: (n) => n.string().trim().matches(/^[^\u4e00-\u9eff]+$/, t("只能為英文"))
    },
    excludeSpecialChars: {
      handler: (n) => n.string().matches(/^[^()[\]{}<>+*/?"_\\|~`!@#$%^&=]*$/, t("不能含特殊字元"))
    }
  };
}, nhe = yn.checkout("validate");
class rhe {
  constructor(t, n) {
    V(this, "provider");
    V(this, "properties");
    this.provider = t, this.properties = n;
  }
  get(t, n = {}) {
    return this.properties[t].handler.bind(this.provider, n);
  }
  isRequire(t) {
    return this.properties[t].required;
  }
  verify(t) {
    for (let n in this.properties) {
      let r = this.get(n)(t[n]);
      if (r !== !0)
        return r;
    }
    return !0;
  }
  verifyBy(t, n) {
    return this.get(t)(n);
  }
}
const ob = (e) => typeof e == "string" && e.trim() === "" || e == null, lb = ({ rule: e, required: t, requireMessage: n, meta: r }) => ({
  required: t,
  handler: (i, s) => {
    let a = i.required == null ? t : i.required;
    if (a && ob(s))
      return e.requireMessage ? e.requireMessage() : n();
    if (a === !1 && ob(s))
      return !0;
    try {
      e.handler(J0e, r[0]).notRequired().validateSync(s);
    } catch (o) {
      return typeof o == "string" ? o : o.errors[0];
    }
    return !0;
  }
});
class ihe {
  constructor(t) {
    V(this, "options", {
      rules: {},
      requireMessage: () => "required"
    });
    t && Object.assign(this.options, t);
  }
  static getBasicRules(t = "zh-TW") {
    return the(t);
  }
  getRule(t, n, ...r) {
    let i = this.options.rules[t];
    if (i == null)
      throw nhe.create(`Rule ${t} not found.`);
    return lb({
      meta: r,
      required: n,
      requireMessage: this.options.requireMessage,
      rule: i
    });
  }
  customize(t) {
    return lb({
      meta: [],
      required: t.required,
      requireMessage: this.options.requireMessage,
      rule: t
    });
  }
  defineValidation(t) {
    return new rhe(this, t(this.getRule.bind(this), this.customize.bind(this)));
  }
}
class Up {
  static inWorker() {
    return typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope;
  }
  static define(t) {
    if (Up.inWorker()) {
      const n = new Lt(), r = t(n);
      n.on("*", ({ data: i, event: s }) => {
        self.postMessage({
          name: s,
          type: "event",
          data: i,
          isError: !1
        });
      }), self.addEventListener("message", async (i) => {
        const { id: s, type: a, name: o, data: l } = i.data;
        if (a === "method" && r[o])
          try {
            const c = await r[o](...l);
            self.postMessage({
              id: s,
              name: o,
              type: a,
              data: c,
              isError: !1
            });
          } catch (c) {
            const u = mb.basicMessageParser(c) || "Unknown error";
            self.postMessage({
              id: s,
              name: o,
              type: a,
              error: u,
              isError: !0
            });
          }
        else
          self.postMessage({
            id: s,
            name: o,
            type: a,
            error: `Method ${o} not found`,
            isError: !0
          });
      });
    }
    return {
      _event: null,
      _methods: null,
      createInMainProcess: () => {
        const n = new Lt(), r = t(n), i = {
          isClosed: !1
        };
        return {
          on: n.on.bind(n),
          methods: r,
          terminate: () => {
            i.isClosed === !1 && (i.isClosed = !0, n.listeners.clear());
          }
        };
      }
    };
  }
  static from(t) {
    const n = {
      isClosed: !1
    }, r = typeof t == "function" ? new t() : t, i = new Lt(), s = new Lt(), a = new eu(r);
    a.add("message", (l) => {
      let { id: c, type: u, name: f, data: d } = l.data;
      u === "event" && i.emit(f, d), u === "method" && s.emit(c, l.data);
    });
    const o = new Proxy({}, {
      get(l, c) {
        return (...u) => n.isClosed ? Promise.reject(new Error("Worker is closed")) : new Promise((f, d) => {
          const h = Lr.createUuid();
          s.on(h, (p, { off: g }) => {
            g(), p.isError ? d(p.error || new Error("Unknown error")) : f(p.data);
          }), r.postMessage({
            id: h,
            type: "method",
            name: c,
            data: u
          });
        });
      }
    });
    return {
      on: i.on.bind(i),
      methods: o,
      terminate: () => {
        n.isClosed === !1 && (n.isClosed = !0, a.clear(), i.listeners.clear(), s.listeners.clear(), r.terminate());
      }
    };
  }
}
class she extends lk {
  constructor() {
    super({
      name: "root",
      interceptorMessage(n) {
        return $h(n, "Error!");
      }
    });
    const t = () => {
      No().stage !== "prod" && (console.log("interaction fail:"), console.log(this), this.each((r) => {
        const i = new Date(r.createdAt).toISOString();
        console.log(`[${i}]${r.checkoutAt} => ${r.type}: ${r.message}`);
      }));
    };
    this.on("action", (n) => {
      n.type === "wrong" && t(), n.type === "notify" && n.level === "danger" && t();
    });
  }
}
class BA {
  constructor(t) {
    V(this, "params");
    V(this, "aliveMap", /* @__PURE__ */ new Map());
    this.params = t;
  }
  toKey(t) {
    return this.params.ns() + "/" + t;
  }
  create(t, n) {
    const r = Ev(), i = this.toKey(t);
    if (this.aliveMap.has(i))
      return this.aliveMap.get(i);
    let s;
    try {
      s = r.get(i);
    } catch {
      s = n;
    }
    const a = Oe(Ha.setMapValue(n, s));
    return fe(() => a, () => r.set(i, a), {
      deep: !0
    }), this.aliveMap.set(i, a), a;
  }
  remove(t) {
    Ev().remove(this.toKey(t));
  }
}
const ahe = new BA({
  ns: () => {
    const e = No();
    return `lib-query-sync-${e.service}-${e.stage}`;
  }
});
class NA {
}
V(NA, "define", (t) => {
  const n = t.ns(), r = t.defs(), i = t.persist ? ahe.create(n, t.defs()) : Oe(t.defs()), s = new Jc({
    concurrentExecutions: 1
  }), a = {
    installed: !1
  };
  return () => {
    const o = t.router(), l = (_) => `l-${n}-${_}`, c = new Lt(), u = $w(() => {
      h();
    }, 25), f = new Qc({
      delay: 100,
      maxValueLength: 100
    });
    f.on("trigger", ({ values: _ }) => {
      c.emit("change", {
        keys: ck.unique(_)
      });
    });
    const d = () => {
      s.push("", async () => {
        const _ = t.defs(), y = {};
        for (let b in _) {
          y[l(b)] = void 0;
          let w = i[b];
          w != null && w !== _[b] && (Array.isArray(w) && Array.isArray(_[b]) && w.slice().sort().join(",") === _[b].sort().join(",") || (y[l(b)] = w));
        }
        o.pushQuery(y);
      });
    }, h = () => {
      s.push("", async () => {
        let _ = o.getCurrentRoute();
        if (_.query) {
          const y = _.query, b = t.defs();
          for (let w in b) {
            const E = y[l(w)] = y[l(w)] ?? void 0;
            E && (b[w] = E);
          }
          Ha.simpleCheckDeepDiff(i, b) && Object.assign(i, b);
        }
      });
    };
    h();
    const p = o.on("after", () => u.input(""));
    zt(() => {
      p.off(), f.close();
    });
    for (let _ in i)
      fe(() => i[_], () => {
        d(), c.emit("input", { key: _ }), f.input(_);
      }, {
        deep: !0
      });
    const x = {
      state: i,
      reset: () => {
        Object.assign(i, t.defs());
      },
      event: c,
      isChange: () => Ha.simpleCheckDeepDiff(r, i),
      stateToQuery: d,
      paramsToQuery: (_) => {
        const y = {};
        for (let b in _)
          y[l(b)] = _[b];
        return y;
      }
    };
    return a.installed === !1 && (a.installed = !0, t.install && t.install(x)), x;
  };
});
const Yp = async (e) => {
  let t = 1, n = [], r = 100;
  for (; r > 0; ) {
    let i = await e.fetch(t);
    if (n.push(...e.pick(i)), t += 1, r -= 1, e.done(i))
      break;
  }
  return n;
}, ohe = async (e) => await Yp({
  done: (n) => n.meta.pagination.total <= n.meta.pagination.page * n.meta.pagination.pageSize,
  pick: (n) => n.data,
  fetch: async (n) => await e(n)
}), lhe = async (e) => await Yp({
  pick: (n) => n.data,
  done: (n) => !n.links.next,
  fetch: async (n) => await e(n)
}), LA = new wb({
  key: () => "cache",
  ttl: uk.toMs("h", 1),
  pick: async () => {
    try {
      const { data: e } = await rt.get("https://ipapi.co/json/");
      return {
        countryCode: e.country_code,
        lat: e.latitude,
        lng: e.longitude
      };
    } catch {
    }
    try {
      const { data: e } = await rt.get("http://ip-api.com/json");
      return {
        countryCode: e.country,
        lat: e.lat,
        lng: e.lon
      };
    } catch {
    }
    return {
      countryCode: "",
      lat: 0,
      lng: 0
    };
  }
}), che = async () => {
  try {
    return (await LA.get("")).countryCode === "CN";
  } catch {
  }
  try {
    return await rt.get("https://google.com/generate_204"), !1;
  } catch {
  }
  return !0;
}, uhe = async () => {
  const e = await LA.get("");
  return {
    countryCode: e.countryCode,
    lat: e.lat,
    lng: e.lng
  };
}, fhe = () => ({
  total: 1,
  per_page: 1,
  current_page: 1,
  last_page: 1,
  from: 1,
  to: 1,
  data: []
}), dhe = () => ({
  msg: "",
  data: [],
  pagination: {
    page: 1,
    pageSize: 10,
    pageCount: 0,
    total: 0
  }
}), hhe = () => ({
  data: [],
  links: {
    first: "",
    last: "",
    prev: "",
    next: ""
  },
  meta: {
    current_page: 1,
    last_page: 0,
    total: 0,
    from: 0,
    path: "",
    per_page: 10,
    to: 0
  }
}), phe = () => ({
  data: [],
  meta: {
    pagination: {
      page: 1,
      pageSize: 10,
      pageCount: 0,
      total: 0
    }
  }
}), ghe = (e, t) => {
  const n = "lib-v3.1", r = Object.assign({
    version: 1,
    ttl: {}
  }, t || {});
  return {
    get(i, s, { storage: a, isDefault: o, defaultValue: l }) {
      if (o)
        return s;
      const c = Date.now(), u = () => ho.decrypt("crypto-js", s.hash, `${e}/${n}`) !== JSON.stringify(s.data) || s.version !== r.version || s.expiredAt !== -1 && c > s.expiredAt;
      try {
        if (u()) {
          const f = l();
          return a.remove(i), f;
        } else
          return s.data;
      } catch {
        return a.remove(i), l();
      }
    },
    set(i, s) {
      let a = Date.now();
      return {
        hash: ho.encrypt("crypto-js", JSON.stringify(s), `${e}/${n}`),
        data: s,
        version: r.version,
        expiredAt: r.ttl[i] ? a + r.ttl[i] : -1,
        createdAt: a
      };
    }
  };
}, vhe = (e, t) => {
  const n = Object.assign({
    version: 1,
    encrypt: !1,
    ttl: {}
  }, t || {});
  return {
    async get(r, i, { storage: s, isDefault: a, defaultValue: o }) {
      if (a)
        return i;
      const l = Date.now(), c = await k0.load(), { visitorId: u } = await c.get();
      try {
        if (i.version !== n.version || i.expiredAt !== -1 && l > i.expiredAt) {
          const d = await o();
          return await s.remove(r), d;
        } else
          return n.encrypt ? JSON.parse(ho.decrypt("crypto-js", i.data, u)) : i.data;
      } catch {
        return await s.remove(r), await o();
      }
    },
    async set(r, i) {
      const s = Date.now(), a = await k0.load(), { visitorId: o } = await a.get();
      return {
        data: n.encrypt ? ho.encrypt("crypto-js", JSON.stringify(i), o) : i,
        version: n.version,
        expiredAt: n.ttl[r] ? s + n.ttl[r] : -1,
        createdAt: s
      };
    }
  };
}, mhe = (e) => e.map((t) => ({
  key: t.key == null ? Lr.createUuid() : t.key,
  label: typeof t.label == "string" ? () => t.label : t.label,
  style: t.style == null ? () => "" : t.style,
  sortBtn: !!t.sortBtn,
  textAlign: t.textAlign || "center",
  formatter: t.formatter == null ? (n) => n : t.formatter,
  optionShow: t.optionShow == null ? !1 : t.optionShow
})), yhe = (e) => e, xhe = (e) => {
  const t = () => {
    const r = Oe(e.schema()), i = e.schema(), s = fX(), a = new Lt();
    fe(() => r, () => a.emit("update", {}), {
      deep: !0
    });
    const o = () => {
      Object.assign(r, e.schema());
    }, l = () => {
      Object.assign(r, El.jpjs(i));
    }, c = (m) => {
      Object.assign(r, Ha.setMapValue(r, m));
    }, u = (m) => {
      c(m), Object.assign(i, El.jpjs(r));
    }, f = (m) => Ha.simpleCheckDeepDiff(r, m), g = {
      raw: () => El.jpjs(r),
      diff: f,
      clear: o,
      reset: l,
      commit: u,
      assign: c,
      rebuild: () => {
        s.reset(), o(), Object.assign(i, e.schema()), a.emit("rebuild", {});
      },
      isModified: () => f(i)
    }, v = e.mixin({
      data: r,
      commit: u,
      methods: g,
      stateManager: s
    });
    return {
      d: r,
      m: g,
      e: a,
      ...v
    };
  }, n = (r) => {
    let i = t();
    return r && i.m.commit(r), i;
  };
  return {
    _ModelType: null,
    _SchemaType: null,
    gen: t,
    from: n,
    /** 只獲取 schema */
    raw: () => e.schema(),
    /** 同步監聽資料變化 */
    sync: (r, i) => {
      const s = n(r);
      return fe(() => r, () => {
        s.m.diff(r) && s.m.assign(r);
      }, {
        deep: !0
      }), fe(() => s.d, () => {
        i && i(s.d);
      }, {
        deep: !0
      }), s;
    }
  };
};
class bhe {
  constructor(t) {
    V(this, "vueI18n");
    V(this, "namespace");
    this.vueI18n = t.vueI18n, this.namespace = t.namespace;
  }
  get t() {
    return this.vueI18n.global.t;
  }
  tt(t, ...n) {
    return t.slice(0, 2) === "##" ? Va.replaceVar({
      end: "}",
      start: "{",
      text: t.slice(2).trim(),
      vars: n[0] || {}
    }) : this.vueI18n ? this.t(`${this.namespace}.${t}`, n[0]) : t;
  }
  path(t) {
    return `${this.namespace}.${t}`;
  }
  export(t) {
    return (n, ...r) => n.slice(0, 2) === "##" ? Va.replaceVar({
      end: "}",
      start: "{",
      text: n.slice(2).trim(),
      vars: r[0] || {}
    }) : this.vueI18n ? this.t(`${this.namespace}.${n}`, t, r[0]).toString() : n;
  }
}
const jA = (e) => {
  let t = [];
  if (e)
    for (let n of e)
      n && n.name && t.push(n.name.toString()), n.children && (t = t.concat(jA(n.children)));
  return t;
};
class _he extends Lt {
  constructor(n) {
    super();
    V(this, "params");
    V(this, "vueRouter");
    V(this, "interceptLeaves", /* @__PURE__ */ new Map());
    this.params = n, this.vueRouter = n.vueRouter, this.vueRouter.afterEach((r, i) => {
      this.emit("after", {
        to: r,
        from: i
      });
    }), this.vueRouter.beforeEach((r, i, s) => {
      this.emit("before", {
        to: r,
        from: i
      }), s();
    }), this.vueRouter.beforeEach(async () => {
      for (let [r, i] of this.interceptLeaves)
        try {
          await i(), this.interceptLeaves.delete(r);
        } catch {
          return !1;
        }
      return !0;
    });
  }
  get routeMap() {
    return new Set(jA(this.vueRouter.getRoutes()));
  }
  toHome() {
    this.vueRouter && (this.params.home ? this.to(this.params.home(), {}) : this.vueRouter.push("/"));
  }
  to(n, r, i) {
    this.vueRouter && (this.routeMap.has(n) ? this.vueRouter.push({
      name: n,
      params: r,
      query: i == null ? void 0 : i.query
    }) : this.toHome());
  }
  resolve(n, r, i) {
    if (this.vueRouter) {
      if (this.routeMap.has(n))
        return this.vueRouter.resolve({
          name: n,
          params: r,
          query: i == null ? void 0 : i.query
        });
      throw yn.create(`Router ${n} not found.`);
    } else
      throw yn.create("Router Plus not installed.");
  }
  hrefTo(n, r, i) {
    const { href: s } = this.resolve(n, r, i);
    location.href = s;
  }
  back(n = 1) {
    this.vueRouter && this.vueRouter.go(n * -1);
  }
  blank(n, r, i) {
    const s = Ye(), { href: a } = this.resolve(n, r, i);
    s.open(a);
  }
  getCurrentRoute(n) {
    return this.vueRouter ? this.vueRouter.currentRoute.value : {
      name: "",
      query: {},
      params: {}
    };
  }
  interceptLeave(n) {
    const r = Lr.createUuid();
    return this.interceptLeaves.set(r, n), {
      close: () => {
        this.interceptLeaves.delete(r);
      }
    };
  }
  defineTo(n, r, i) {
    return {
      name: n,
      params: r || {},
      ...i || {}
    };
  }
  async pushQuery(n) {
    if (this.vueRouter) {
      const r = this.getCurrentRoute(), i = {
        ...El.jpjs(r.query),
        ...n
      };
      for (let s in i)
        if (i[s] == null) {
          delete i[s];
          continue;
        }
      await this.vueRouter.push({
        query: i
      });
    }
  }
}
const Zhe = ({ store: e, pinia: t }) => {
  e.$useSetup = (n) => (zt(() => {
    e.$destroy();
  }), async () => {
    await e.$install(n);
  }), e.$install = async (n) => {
    e.__runInstall && await e.__runInstall(n);
  }, e.$destroy = () => {
    e.__runDestroy && e.__runDestroy(), e.$dispose(), delete t.state.value[e.$id];
  };
}, Khe = () => {
  const e = Oe({
    isDestroyed: !1,
    installStack: [],
    destroyStack: []
  });
  return {
    onInstall: (t) => {
      e.installStack.push(t);
    },
    onDestroy: (t) => {
      e.destroyStack.push(t);
    },
    isAlive: () => !e.isDestroyed,
    isDestroyed: () => e.isDestroyed,
    genOutput: (t) => Object.assign(t, {
      __runInstall: async (n) => {
        await Promise.all(e.installStack.map((r) => r(n)));
      },
      __runDestroy: () => {
        e.isDestroyed = !0;
        for (const n of e.destroyStack)
          n();
      },
      __lifrCycleState: e
    })
  };
}, whe = yn.checkout("AppleAuth"), $he = "name email", xd = new Lt();
function Ehe() {
  var t;
  if (!((t = Ye().__ng_state.aapple) != null && t.installed))
    throw whe.create("apple login not installed.");
}
class Ahe {
  static async install(t) {
    const n = Ye();
    n.__ng_state.aapple == null && (n.__ng_state.aapple = {
      installed: !1
    }), n.__ng_state.aapple.installed === !1 && (await Ps.importScript("https://appleid.cdn-apple.com/appleauth/static/jsapi/appleid/1/en_US/appleid.auth.js"), n.AppleID.auth.init({
      clientId: t.clientId,
      redirectURI: "https//demo.com",
      scope: $he,
      state: "",
      usePopup: !1
    }), n.__ng_state.aapple.installed = !0);
  }
  static installed() {
    var n;
    return ((n = Ye().__ng_state.aapple) == null ? void 0 : n.installed) ?? !1;
  }
  static get on() {
    return xd.on.bind(xd);
  }
  /**
   * 如果是使用者自己關閉，則回傳 no-action
   */
  static async signIn(t) {
    Ehe();
    const r = await Ye().AppleID.auth.signIn({
      state: (t == null ? void 0 : t.state) ?? "",
      usePopup: (t == null ? void 0 : t.popup) ?? !0,
      redirectURI: t.redirectURI
    });
    return r.authorization.code && r.authorization.id_token ? (xd.emit("login", {
      token: r.authorization.id_token,
      user: r.user
    }), {
      status: "pass",
      response: r
    }) : {
      status: "no-action",
      response: null
    };
  }
}
/*! js-cookie v3.0.5 | MIT */
function wl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      e[r] = n[r];
  }
  return e;
}
var khe = {
  read: function(e) {
    return e[0] === '"' && (e = e.slice(1, -1)), e.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
  },
  write: function(e) {
    return encodeURIComponent(e).replace(
      /%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,
      decodeURIComponent
    );
  }
};
function H0(e, t) {
  function n(i, s, a) {
    if (!(typeof document > "u")) {
      a = wl({}, t, a), typeof a.expires == "number" && (a.expires = new Date(Date.now() + a.expires * 864e5)), a.expires && (a.expires = a.expires.toUTCString()), i = encodeURIComponent(i).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
      var o = "";
      for (var l in a)
        a[l] && (o += "; " + l, a[l] !== !0 && (o += "=" + a[l].split(";")[0]));
      return document.cookie = i + "=" + e.write(s, i) + o;
    }
  }
  function r(i) {
    if (!(typeof document > "u" || arguments.length && !i)) {
      for (var s = document.cookie ? document.cookie.split("; ") : [], a = {}, o = 0; o < s.length; o++) {
        var l = s[o].split("="), c = l.slice(1).join("=");
        try {
          var u = decodeURIComponent(l[0]);
          if (a[u] = e.read(c, u), i === u)
            break;
        } catch {
        }
      }
      return i ? a[i] : a;
    }
  }
  return Object.create(
    {
      set: n,
      get: r,
      remove: function(i, s) {
        n(
          i,
          "",
          wl({}, s, {
            expires: -1
          })
        );
      },
      withAttributes: function(i) {
        return H0(this.converter, wl({}, this.attributes, i));
      },
      withConverter: function(i) {
        return H0(wl({}, this.converter, i), this.attributes);
      }
    },
    {
      attributes: { value: Object.freeze(t) },
      converter: { value: Object.freeze(e) }
    }
  );
}
var Che = H0(khe, { path: "/" });
function W0(e) {
  this.message = e;
}
W0.prototype = new Error(), W0.prototype.name = "InvalidCharacterError";
var cb = typeof window < "u" && window.atob && window.atob.bind(window) || function(e) {
  var t = String(e).replace(/=+$/, "");
  if (t.length % 4 == 1)
    throw new W0("'atob' failed: The string to be decoded is not correctly encoded.");
  for (var n, r, i = 0, s = 0, a = ""; r = t.charAt(s++); ~r && (n = i % 4 ? 64 * n + r : r, i++ % 4) ? a += String.fromCharCode(255 & n >> (-2 * i & 6)) : 0)
    r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(r);
  return a;
};
function Dhe(e) {
  var t = e.replace(/-/g, "+").replace(/_/g, "/");
  switch (t.length % 4) {
    case 0:
      break;
    case 2:
      t += "==";
      break;
    case 3:
      t += "=";
      break;
    default:
      throw "Illegal base64url string!";
  }
  try {
    return function(n) {
      return decodeURIComponent(cb(n).replace(/(.)/g, function(r, i) {
        var s = i.charCodeAt(0).toString(16).toUpperCase();
        return s.length < 2 && (s = "0" + s), "%" + s;
      }));
    }(t);
  } catch {
    return cb(t);
  }
}
function Gc(e) {
  this.message = e;
}
function She(e, t) {
  if (typeof e != "string")
    throw new Gc("Invalid token specified");
  var n = (t = t || {}).header === !0 ? 0 : 1;
  try {
    return JSON.parse(Dhe(e.split(".")[n]));
  } catch (r) {
    throw new Gc("Invalid token specified: " + r.message);
  }
}
Gc.prototype = new Error(), Gc.prototype.name = "InvalidTokenError";
const Gl = yn.checkout("GoogleAuth"), bd = new Lt();
function ub() {
  var t;
  if (!((t = Ye().__ng_state.agoogle) != null && t.installed))
    throw Gl.create("gsi not installed.");
}
class The {
  static async install(t) {
    const n = Ye();
    n.__ng_state.agoogle == null && (n.__ng_state.agoogle = {
      installed: !1
    }), n.__ng_state.agoogle.installed === !1 && (await Ps.importScript("https://accounts.google.com/gsi/client"), google.accounts.id.initialize({
      ux_mode: t.uxMode,
      client_id: t.clientId,
      login_uri: t.loginUri,
      auto_select: !1,
      callback: (r) => {
        bd.emit("login", {
          token: r.credential,
          payload: She(r.credential)
        });
      }
    }), n.__ng_state.agoogle.installed = !0);
  }
  static installed() {
    var n;
    return ((n = Ye().__ng_state.agoogle) == null ? void 0 : n.installed) ?? !1;
  }
  static get on() {
    return bd.on.bind(bd);
  }
  /** 渲染出登入按鈕 */
  static renderButton(t, n) {
    ub(), google.accounts.id.renderButton(t, n);
  }
  /**
   * 如果瀏覽器從未登入過 google 帳號，會打不開，並回傳 no-logged
   * 如果是使用者自己關閉，則回傳 no-action
   */
  static oneTap() {
    if (fk.inAppBrowser())
      throw Gl.create("noSupportBrowser");
    return ub(), new Promise((t, n) => {
      Che.remove("g_state"), google.accounts.id.prompt((r) => {
        if (r.isNotDisplayed()) {
          let i = r.getNotDisplayedReason();
          i === "opt_out_or_no_session" ? t({
            status: "no-logged"
          }) : n(Gl.create(i));
        } else if (r.isSkippedMoment()) {
          let i = ["tap_outside", "user_cancel"], s = r.getSkippedReason();
          i.includes(s) ? t({
            status: "no-action"
          }) : n(Gl.create(s));
        } else
          r.getDismissedReason() === "credential_returned" && t({
            status: "pass"
          });
      });
    });
  }
}
const fb = "public_profile,email", zA = yn.checkout("FacebookAuth"), _d = new Lt();
function wd() {
  var t;
  if (!((t = Ye().__ng_state.afb) != null && t.installed))
    throw zA.create("facebook sdk not installed.");
}
class Ohe {
  static async install(t) {
    const n = Ye();
    n.__ng_state.afb == null && (n.__ng_state.afb = {
      installed: !1,
      clientId: ""
    }), n.__ng_state.afb.installed === !1 && (n.__ng_state.clientId = t.clientId, n.fbAsyncInit = () => {
      FB.init({
        appId: t.clientId,
        xfbml: !0,
        version: "v15.0"
      });
    }, await Ps.importScript("https://connect.facebook.net/en_US/sdk.js"), n.__ng_state.afb.installed = !0);
  }
  static installed() {
    var n;
    return ((n = Ye().__ng_state.afb) == null ? void 0 : n.installed) ?? !1;
  }
  static get on() {
    return _d.on.bind(_d);
  }
  /**
   * 如果是使用者自己關閉，則回傳 no-action
   */
  static signIn() {
    return wd(), new Promise((t, n) => {
      FB.login((r) => {
        r.status === "connected" ? (_d.emit("login", {
          token: r.authResponse.accessToken || ""
        }), t({
          status: "pass",
          response: r.authResponse
        })) : r.status === "unknown" ? t({
          status: "no-action",
          response: null
        }) : n(zA.create(r.status));
      }, {
        scope: fb
      });
    });
  }
  static signOut() {
    return wd(), new Promise((t) => {
      FB.getLoginStatus((n) => {
        n.status === "connected" ? FB.logout((r) => {
          t(r);
        }) : t(null);
      });
    });
  }
  static getLoginUrl(t) {
    wd();
    const n = Ye(), r = new URL("https://www.facebook.com/v15.0/dialog/oauth");
    return r.searchParams.set("scope", fb), r.searchParams.set("client_id", n.__ng_state.clientId), r.searchParams.set("redirect_uri", t.redirectUri), r.searchParams.set("state", (t == null ? void 0 : t.state) ?? ""), r.href;
  }
  // TODO: app 內實作
  static async share(t) {
    return new Promise((n, r) => {
      FB.ui({
        display: "popup",
        method: "share",
        href: t.href
      }, (i) => {
        i.error_message ? r(i.error_message) : n(i);
      });
    });
  }
}
const Mhe = yn.checkout("WechatAuth");
function Fhe() {
  var t;
  if (!((t = Ye().__ng_state.awechat) != null && t.installed))
    throw Mhe.create("gsi not installed.");
}
class Phe {
  static async install(t) {
    const n = Ye();
    n.__ng_state.awechat == null && (n.__ng_state.awechat = {
      config: t,
      installed: !1
    }), n.__ng_state.awechat.installed === !1 && (await Ps.importScript("https://res.wx.qq.com/connect/zh_CN/htmledition/js/wxLogin.js"), n.__ng_state.awechat.installed = !0);
  }
  static installed() {
    var n;
    return ((n = Ye().__ng_state.awechat) == null ? void 0 : n.installed) ?? !1;
  }
  static isWeixinBrowser() {
    const t = navigator.userAgent.toLowerCase();
    return !!/micromessenger/.test(t);
  }
  /**
   * 網頁應用要用 qrcode 登入
   */
  static renderQrcode(t) {
    Fhe();
    const n = Ye(), r = n.__ng_state.awechat.config;
    new n.WxLogin({
      id: t.containerId,
      appid: r.webAppId,
      scope: "snsapi_login",
      redirect_uri: encodeURIComponent(t.redirectUri),
      state: t.state ?? "",
      response_type: "code"
    });
  }
  /**
   * 獲取登入網址，這只能在微信 app 裡面使用，且要加入申請的微信公眾號
   */
  static getLoginUrl(t) {
    const n = Ye(), r = new URL("https://open.weixin.qq.com/connect/oauth2/authorize"), i = n.__ng_state.awechat.config;
    return r.searchParams.set("appid", i.appId), r.searchParams.set("redirect_uri", t.redirectUri), r.searchParams.set("response_type", "code"), r.searchParams.set("scope", "snsapi_userinfo"), r.searchParams.set("state", (t == null ? void 0 : t.state) ?? ""), r.toString() + "#wechat_redirect";
  }
}
const Ihe = (e) => () => {
  const t = Oe({
    title: e.title(),
    confirmText: e.confirmText(),
    cancelText: e.cancelText(),
    isOpen: !1,
    message: "",
    handler: null,
    onReject: void 0
  }), n = ({ message: a, handler: o, onReject: l }) => {
    t.isOpen = !0, t.message = a, t.handler = o, t.onReject = l;
  }, r = () => {
    t.isOpen = !1, t.onReject = void 0;
  }, i = T(() => t.isOpen), s = T(() => ({
    title: t.title,
    confirmText: t.confirmText,
    cancelText: t.cancelText,
    message: t.message,
    isOpen: t.isOpen,
    clickCancel: r,
    clickConfirm: (a) => {
      t.handler(a);
    }
  }));
  return {
    open: n,
    isOpen: i,
    props: s,
    state: t,
    cancel: r
  };
}, Rhe = (e) => ({
  openConfirmPlus: (t) => {
    e().open(t);
  },
  openConfirm: (t, n, r) => {
    e().open({
      message: t,
      handler: n,
      onReject: r
    });
  },
  isCheckingConfirm: () => e().isOpen,
  cancelConfirm: () => {
    e().cancel();
  }
}), Bhe = () => () => {
  const e = Oe({
    messages: []
  }), t = (s) => {
    e.messages.push({
      ...s,
      id: Lr.createUuid(),
      duration: 0,
      clicked: s.type === "danger",
      onClick: () => ""
    });
  }, n = () => {
    e.messages = e.messages.filter((s) => s.duration <= 100);
  }, r = T(() => e.messages), i = T(() => ({
    onclear: n,
    messages: e.messages
  }));
  return {
    push: t,
    props: i,
    clear: n,
    state: e,
    messages: r
  };
}, Nhe = (e) => ({
  showToast: (t, n) => {
    e().push({
      type: t,
      content: n
    });
  },
  pushNotification: (t) => {
    e().push({
      ...t,
      onClick: t.onClick || (() => null)
    });
  }
}), Ir = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof global < "u" ? global : typeof window < "u" ? window : {};
Ir.__ng_state = {};
Ir.__ng_config = {
  libOptions: {
    staticUrl: "",
    notFoundImage: ""
  },
  libEnv: {
    version: 3,
    stage: "",
    service: ""
  }
};
const Ye = () => Ir, Jhe = {
  Camera: Mc,
  CryptoAES: ho,
  Graphql: SZ,
  Request: NJ,
  RuleProvider: ihe,
  PersistState: BA,
  NextgenWorker: Up,
  NextgenInteraction: she,
  NextgenMessageTrace: one,
  QuerySync: NA
}, Qhe = {
  fetch: {
    fetchAll: Yp,
    fetchAllForLaravelPaginate: lhe,
    fetchAllForStrapi: ohe
  },
  ip: {
    getGeoLocation: uhe,
    inChina: che
  },
  message: {
    parseMessage: $h
  },
  serverData: {
    createLaravelPaginate: fhe,
    createLaravelResourcePaginate: hhe,
    createStrapiList: dhe,
    createStrapiListResource: phe
  },
  storage: {
    asyncLoaclStroageIntercept: vhe,
    loaclStroageIntercept: ghe
  },
  table: {
    defineFields: mhe
  },
  text: {
    toHump: U_
  }
}, epe = {
  define: xhe,
  defineSchema: yhe
}, tpe = {
  I18nPlus: bhe,
  RouterPlus: _he
}, npe = {
  NgAMap: gu,
  AppleAuth: Ahe,
  GoogleMap: Xa,
  GoogleAuth: The,
  FacebookService: Ohe,
  WechatService: Phe
}, rpe = {
  createConfirmStore: Ihe,
  createNotificationStore: Bhe,
  confirmStoreToActions: Rhe,
  notificationStoreToActions: Nhe
}, Lhe = () => Ir.__ng_config.libOptions, No = () => Ir.__ng_config.libEnv, ipe = {
  setOptions: (e) => {
    for (let t in e)
      Ir.__ng_config.libOptions[t] = e[t];
  },
  install(e, t) {
    Kn.register(
      Yd,
      qd,
      _a,
      wa,
      Il,
      ns,
      Ml,
      Vd
    );
    for (let n in t.options)
      Ir.__ng_config.libOptions[n] = t.options[n];
    for (let n in t.env)
      Ir.__ng_config.libEnv[n] = t.env[n];
    for (const n in Cy)
      e.component(n, Cy[n]);
    for (const n in Dy)
      e.component(n, Dy[n]);
  }
};
export {
  rpe as LibStores,
  npe as Libraries,
  epe as Model,
  Jhe as Modules,
  ipe as NextgenLib,
  Zhe as NextgenPiniaPlugin,
  Cy as NgComponents,
  Dy as NgLayoutComponents,
  Qhe as Utils,
  tpe as VueExtends,
  Khe as createStoreLifeCycle,
  Xhe as genData,
  Ghe as genRef,
  fX as genStateManager,
  Ye as getGlob,
  No as getLibEnv,
  Lhe as getLibOptions,
  $w as useDebounce,
  Yhe as useListenerGroup,
  qhe as useLoader,
  _o as useSelf
};
//# sourceMappingURL=index.js.map
